<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../../../img/favicon.ico">

	<title>Subsets and LoadMapping - Cora Framework Documentation</title>

        <link href="../../../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../../../css/highlight.css">
        <link href="../../../../css/base.css" rel="stylesheet">
        <link href="../../../../extra.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../../../..">Cora Framework Documentation</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="../../../..">About</a>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Setup <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
<li >
    <a href="../../../../setup/install/">Installation</a>
</li>

                    
                        
<li >
    <a href="../../../../setup/configuration/">Configuration</a>
</li>

                    
                        
<li >
    <a href="../../../../setup/advanced/">Advanced Configuration</a>
</li>

                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Tutorals <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
<li >
    <a href="../../../../tutorials/intro/">Intro to Cora</a>
</li>

                    
                        
<li >
    <a href="../../../../tutorials/composer/">Using Composer</a>
</li>

                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Docs <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
<li >
    <a href="../../release_notes/">Release Notes</a>
</li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" href="">ADM ORM</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../overview/">Overview</a>
</li>

        
            
<li >
    <a href="../implementation/">Implementation</a>
</li>

        
            
<li >
    <a href="../model/">Model</a>
</li>

        
            
<li >
    <a href="../relationships/">Model Relationships</a>
</li>

        
            
<li class="active">
    <a href="./">Subsets and LoadMapping</a>
</li>

        
            
<li >
    <a href="../repository/">Repository</a>
</li>

        
            
<li >
    <a href="../gateway/">Gateway</a>
</li>

        
            
<li >
    <a href="../factory/">Factory</a>
</li>

        
            
<li >
    <a href="../lifecycle/">Lifecycle Callbacks</a>
</li>

        
            
<li >
    <a href="../database_gen/">Automated DB Creation</a>
</li>

        
            
<li >
    <a href="../opt_locking/">Optimistic Locking</a>
</li>

        
    </ul>
  </li>

                    
                        
<li >
    <a href="../../collections/">Collection Class</a>
</li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" href="">Database Class</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../databaseclass/overview/">Overview</a>
</li>

        
            
<li >
    <a href="../../databaseclass/custom_query/">Custom Queries</a>
</li>

        
            
<li >
    <a href="../../databaseclass/methods_utility/">Utility Methods</a>
</li>

        
            
<li >
    <a href="../../databaseclass/methods_select/">SELECT Methods</a>
</li>

        
            
<li >
    <a href="../../databaseclass/methods_update/">UPDATE Methods</a>
</li>

        
            
<li >
    <a href="../../databaseclass/methods_insert/">INSERT Methods</a>
</li>

        
            
<li >
    <a href="../../databaseclass/methods_delete/">DELETE Methods</a>
</li>

        
            
<li >
    <a href="../../databaseclass/methods_create/">CREATE Methods</a>
</li>

        
            
<li >
    <a href="../../databaseclass/databaseresult/">DatabaseResult Class</a>
</li>

        
    </ul>
  </li>

                    
                        
<li >
    <a href="../../dependency-injection/overview/">Dependency Injection</a>
</li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" href="">Events</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../events/overview/">Overview</a>
</li>

        
            
<li >
    <a href="../../events/eventmanager/">Event Manager</a>
</li>

        
            
<li >
    <a href="../../events/eventmapping/">Event Mapping</a>
</li>

        
            
<li >
    <a href="../../events/event/">Event</a>
</li>

        
            
<li >
    <a href="../../events/listener/">Listener</a>
</li>

        
    </ul>
  </li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" href="">MVC Pattern</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../mvc/overview/">Overview</a>
</li>

        
            
<li >
    <a href="../../mvc/models/">Models</a>
</li>

        
            
<li >
    <a href="../../mvc/views/">Views</a>
</li>

        
            
<li >
    <a href="../../mvc/controllers/">Controllers</a>
</li>

        
            
<li >
    <a href="../../mvc/libraries/">Libraries</a>
</li>

        
    </ul>
  </li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" href="">Routing</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../routing/overview/">Overview</a>
</li>

        
            
<li >
    <a href="../../routing/custom_routes/">Custom Routes</a>
</li>

        
    </ul>
  </li>

                    
                        
<li >
    <a href="../../validationclass/overview/">Validate Class</a>
</li>

                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">CS Topics <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
<li >
    <a href="../../../../computerscience/computability/">Computability</a>
</li>

                    
                    </ul>
                </li>
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                <li >
                    <a rel="next" href="../relationships/">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </li>
                <li >
                    <a rel="prev" href="../repository/">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#subsets-and-loadmapping">Subsets and LoadMapping</a></li>
        
    
        <li class="main "><a href="#data-subsets-on-models">Data Subsets on Models</a></li>
        
            <li><a href="#how-to-customize-a-subset">How to Customize a Subset:</a></li>
        
    
        <li class="main "><a href="#loadmapping">LoadMapping</a></li>
        
            <li><a href="#loadmap-creation">LoadMap Creation</a></li>
        
            <li><a href="#use-case-1-map-unmatching-fields">Use Case #1: Map Unmatching Fields</a></li>
        
            <li><a href="#use-case-2-load-additional-related-models">Use Case #2: Load Additional Related Models</a></li>
        
            <li><a href="#use-case-3-efficiently-loading-models">Use Case #3: Efficiently Loading Models</a></li>
        
            <li><a href="#use-case-4-onload-function">Use Case #4: onLoad Function</a></li>
        
            <li><a href="#complicated-example-revisited">Complicated Example Revisited</a></li>
        
            <li><a href="#forced-loading-advanced">Forced Loading Advanced</a></li>
        
    
        <li class="main "><a href="#on-model-loadmaps">On-Model LoadMaps</a></li>
        
            <li><a href="#manual-loadmap-example">Manual LoadMap Example</a></li>
        
            <li><a href="#on-model-loadmap-example">On-Model LoadMap Example</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<h1 id="subsets-and-loadmapping">Subsets and LoadMapping</h1>
<p><span class="text-green">
This page covers some important things to know about working with the active-record like features present on models as well as working with 
LoadMaps and how they can help you.
</span></p>
<h1 id="data-subsets-on-models">Data Subsets on Models</h1>
<p>There are various ways you can fetch a subset of some data in ADM. In the Repositories documentation we talk about <a href="../../../../documentation/v2/ADM/repository/#findall-method">several methods 
for doing so</a>. We also talk about setting <a href="../../../../documentation/v2/ADM/relationships/#model-to-table-rows">model constraints in the Model Relationships "Model to Table Rows"</a> section. What isn't 
discussed elsewhere is how to fetch a subset of a collection when working with models directly. </p>
<p>What do I mean by that? I mean starting with a model (for instance a User) and then fetching some related data from it:</p>
<pre><code>// Starting with a User model...
// Fetch the list of Articles that user has written and count them.
echo $user-&gt;articles-&gt;count();
</code></pre>

<p>Under the hood, repositories still get invoked because Models don't directly interact with the database in ADM, 
but it's still an important distinction between starting with a model or starting with a repository because the execution 
flow will be different. When working with repositories you'll probably be calling findAll() or findOne(), and with 
model relationships you'll be calling the attribute name.</p>
<h3 id="how-to-customize-a-subset">How to Customize a Subset:</h3>
<p>You can call any model relationship as a function and pass it a closure that modifies the return results.</p>
<p>Example:</p>
<pre><code>$recentArticles = $user-&gt;articles(function($query) {
  return $query-&gt;where('published_year', 2018, '&gt;=');
});
</code></pre>

<p>Another Example:</p>
<pre><code>// Pretend we got these vars from somewhere...
$currentPage = 0;
$itemsPerPage = 20;

// Let's fetch a paginated view of the articles this user has written:
$currentPageArticles = $user-&gt;articles(function($query, $page, $itemsPerPage) {
  return $query-&gt;offset($page * $itemsPerPage)
               -&gt;limit($itemsPerPage);
}, [$currentPage, $itemsPerPage]);
</code></pre>

<h1 id="loadmapping">LoadMapping</h1>
<p>LoadMapping solves several model relationship related problems, and while the simplest examples are easy to understand, 
some of the more detailed uses can be kinda confusing. Hopefully after reading this you'll understand what a LoadMap is 
and how it works.</p>
<h2 id="loadmap-creation">LoadMap Creation</h2>
<p>LoadMaps take two arguments as input both of which should be arrays or can be left blank (they are optional). The 
first array is for mapping fields from a database to the model; the second array is for specifying which relationships should be 
loaded by default before the results are given back to you.</p>
<p>Before we dive into explaining anything, here's a look at a complicated LoadMap. Don't worry about this looking super confusing, 
we'll dive into the specifics with the uses cases below then revisit this at the end:</p>
<p><strong>Complicated LoadMap:</strong></p>
<pre><code>$loadMap = new \Cora\Adm\LoadMap([
    'category' =&gt; 'type'
  ], [
    'madeBy' =&gt; new \Cora\Adm\LoadMap([
      'user_firstName' =&gt; 'firstName',
      'user_lastName' =&gt; 'lastName',
      'user_id' =&gt; 'id'
    ], [
      'Job' =&gt; new \Cora\Adm\LoadMap([
        'job_id' =&gt; 'id',
        'job_name' =&gt; 'name',
        'created_date' =&gt; '!created_date'
      ])
    ])
  ],
  function($model, $str) {
    $model-&gt;status = $str;
  },
  ['New']
);
</code></pre>

<h2 id="use-case-1-map-unmatching-fields">Use Case #1: Map Unmatching Fields</h2>
<p>Let's say you get a result from a database, but the field names don't match up 
with what the model is expecting; the first use-case of LoadMaps is mapping arbitrary 
fields to model attributes. The benefit of this capability doesn't make a lot of sense 
at first glance as any changes to database field names can be more permanently mapped to the 
model using the <a href="../../../../documentation/v2/ADM/relationships/#model-attribute-to-table-column">model's "field" descriptor</a>
which is what you'll want to use in most situations. Still, understanding how this remapping 
can be applied is important to understanding how to do <a href="../../../../documentation/v2/ADM/overview/#loadmaps-for-reduced-queries">efficient model loading</a>.</p>
<p>Let's say you grabbed a collection of Users from the database and you want the 
"email" field to be mapped to the "username" attribute on the User models. You could do that using a LoadMap 
like so:</p>
<pre><code>// The first parameter of a LoadMap is for passing an array 
// of mappings.
$loadMap = new \Cora\Adm\LoadMap([
  'email' =&gt; 'username'
]);

// Just add the LoadMap as the 3rd argument to our findAll() or findOne() call
$users = $repo-&gt;findAll(false, false, $loadMap);
</code></pre>

<h2 id="use-case-2-load-additional-related-models">Use Case #2: Load Additional Related Models</h2>
<p>When using models to work with API endpoints, you'll probably want to convert the results
into a format such as JSON. The built-in "toJson" method on Models and Collections is handy for that.
However, when converting your data to JSON, nothing will be dynamically loaded. So if you need the 
data about a User's Job sent (and not just the ID that references their job), you have to make sure 
that Job data is loaded before you call toJson().
In the past this meant iterating through any models in your result and attempting to access the Job 
data so that dynamic loading would be triggered like so:</p>
<pre><code>$users = $repo-&gt;findAll();
foreach($users as $user) {
  // &quot;touch&quot; the job data, even though not doing anything with it here,
  // just to get it to load
  $user-&gt;job-&gt;name;
}
echo $users-&gt;toJson();
</code></pre>

<p>This worked, but always felt sideways because of the way you went about forcing data to load. With 
LoadMaps, you have a better, more clear way of loading the data you need upfront without resorting to 
wonky loops. LoadMaps take an array as the 2nd argument and allow you to specify relationships you want 
loaded right away. For example:</p>
<pre><code>// The second parameter of a LoadMap is for passing an array 
// of relationships you want pre-loaded
$loadMap = new \Cora\Adm\LoadMap([], [
  'job' =&gt; true
]);

// Just add the LoadMap as the 3rd argument to our findAll() call
$users = $repo-&gt;findAll(false, false, $loadMap);
</code></pre>

<p>Using the field mapping feature along with the relationship loading specification might look like this:</p>
<pre><code>// The first parameter is for field mappings
// The second parameter is for relationship pre-loading
$loadMap = new \Cora\Adm\LoadMap([
    'email' =&gt; 'username'
  ], [
    'job' =&gt; true
]);

// Just add the LoadMap as the 3rd argument to our findAll() call
$users = $repo-&gt;findAll(false, false, $loadMap);
</code></pre>

<p>The above will cause the email field to be loaded into the "username" attribute on the User models 
and cause the related Job model to be loaded for each User.</p>
<h2 id="use-case-3-efficiently-loading-models">Use Case #3: Efficiently Loading Models</h2>
<p>Now that we've covered the mapping of attributes and the pre-loading of models, we can talk about 
how to load additional models efficiently. Doing this requires more manual work on the part of the 
programmer, and can significantly increase the code required to fetch your models, so I'd advise 
anyone reading this to refrain from optimizing too early. There's definitely a moderate code readability cost 
and the decision on whether to optimize should take that into account. However, the performance benefit could be huge.</p>
<p>For this example, let's continue to use the User and Job examples, but with one minor change; so far we've had the 
name for a job denoted as its "title". Let's change that so Jobs' have a "name" instead of "title". This way we'll 
have a conflict in naming between a User's name and a Job's name as well as between a Users' ID and a Job's ID. 
These conflicts will help us understand why you may need to have a LoadMap embedded within another LoadMap.</p>
<p>So what we want to do is fetch a list of Users, but also have their Jobs populated with data. If we were to do this 
the simple way and just specify we want the Job data loaded as seen below, it would work but it would execute N+1
queries on the database where N equals the number of users you are fetching:</p>
<pre><code>$loadMap = new \Cora\Adm\LoadMap([], [
  'job' =&gt; true
]);

// Fetches all the data we need, but does a separate query 
// per User fetched to grab their Job data. So N+1 queries.
$users = $repo-&gt;findAll(false, false, $loadMap);
</code></pre>

<p>In order reduce the amount of queries hitting the database, that means we need to do some sort of JOIN when we grab 
the user data and return the Job info along with the rest of the User columns. In addition, the way data gets fetched
using PDO in the default MySQL adaptor means you can't have duplicate field names. If you have a "name" column on the 
Users table and a "name" column on the Jobs table and you do a JOIN, you'll need to alias the Job name or else it will 
overwrite the User name column when PDO turns the results into a PHP array. So our query ultimately needs to look something 
like this:</p>
<pre><code>SELECT 
  users.*, 
  job.id as 'job_id', 
  job.name as 'job_name' 
FROM users JOIN jobs ON (users.job = jobs.id);
</code></pre>

<p>To accomplish such a join, we'll pass in a custom closure to the findAll() method and either use the query builder 
or a manually written query like seen below. Keep in mind, the <code>SELECT * FROM users</code> part of the query will be generated 
by the ORM automatically, so if you go the query building route, you just need to add modifications to that base query:</p>
<p><strong>Using Query Builder:</strong></p>
<pre><code>$users = $repo-&gt;findAll(function($query) {
  // Specify the JOIN we need
  $query-&gt;join('jobs', [['users.job', '=', 'jobs.id']]);

  // Change the select part from &quot;SELECT *&quot; to something else
  $query-&gt;select([&quot;users.*&quot;, &quot;job.id as 'job_id'&quot;, &quot;job.name as 'job_name'&quot;]);
  return $query;
});
</code></pre>

<p><strong>Using Custom Query:</strong></p>
<pre><code>$users = $repo-&gt;findAll(function($query) {
  return $query-&gt;custom(&quot;
    SELECT 
      users.*, 
      job.id as 'job_id', 
      job.name as 'job_name' 
    FROM users JOIN jobs ON (users.job = jobs.id)
  &quot;);
});
</code></pre>

<p>That should get us the data we need in ONE query for all our users and their related jobs without the need to do any 
additional queries. The next step is getting the data populated correctly into the models so that we can do 
<code>$user-&gt;job-&gt;name</code> where Job is a proper Job model. To do that we need to turn to the LoadMap functionality we 
covered in use cases #1 and #2, and then take everything up another notch. Specifically, when we do field mapping like
so:</p>
<pre><code>$loadMap = new \Cora\Adm\LoadMap([
    'email' =&gt; 'username'
  ], [
    'job' =&gt; true
]);
</code></pre>

<p>The field mapping above only applies to the loading of User models! We CANNOT do the following:</p>
<pre><code>$loadMap = new \Cora\Adm\LoadMap([
    'email' =&gt; 'username',
    'job_id' =&gt; 'id',
    'job_name' =&gt; 'name'
  ], [
    'job' =&gt; true
]);
</code></pre>

<p>^ This would NOT WORK like we want. What that would do is override each Users' ID and name with that of their job.
To load the Job ID and Name info into the Job model attached to each user, we need to embed a 2nd LoadMap like so:</p>
<pre><code>$loadMap = new \Cora\Adm\LoadMap([
    'email' =&gt; 'username'
  ], [
    'job' =&gt; new \Cora\Adm\LoadMap([
      'job_id' =&gt; 'id',
      'job_name' =&gt; 'name'
    ])
  ]
);
</code></pre>

<p>Notice that we replaced the boolean true value indicating that we want the Job relationship loaded, and are now 
defining a LoadMap in that spot. This embedded LoadMap will get passed to the Job model when it gets loaded instead
of the ORM doing a new query to fetch the Job info separately. Now it will assume you are defining mappings for it 
to grab data (which we are). </p>
<hr />
<p><strong>Important Sidenote:</strong>    </p>
<p>It's worth noting that in addition to any explicit mapping you define, sub-models (such as Job) 
will also map any other matching fields to their model too. For example: let's say both Users and Jobs 
have a "created_date" field. Even though we didn't fetch the Job's created_date in our query, if the User created_date 
is present, that field will get passed to the Job model and the Job model will assume the field can be loaded for its
created_date. To prevent unwanted mappings from happening you have two options: 1. You can fetch the Job created_date in 
a similar fashion as we did with ID and Name and alias it as job_created_date or something and map that in, OR 2. 
you can explicitly tell the Job model not to map the created_date field to itself like so (notice the exclamation):</p>
<pre><code>$loadMap = new \Cora\Adm\LoadMap([
    'email' =&gt; 'username'
  ], [
    'job' =&gt; new \Cora\Adm\LoadMap([
      'job_id' =&gt; 'id',
      'job_name' =&gt; 'name',
      'created_date' =&gt; '!created_date'
    ])
  ]
);
</code></pre>

<hr />
<p><strong>Putting it all together:</strong>    </p>
<pre><code>$loadMap = new \Cora\Adm\LoadMap([
    'email' =&gt; 'username'
  ], [
    'job' =&gt; new \Cora\Adm\LoadMap([
      'job_id' =&gt; 'id',
      'job_name' =&gt; 'name'
    ])
  ]
);

$users = $repo-&gt;findAll(function($query) {
  return $query-&gt;custom(&quot;
    SELECT 
      users.*, 
      job.id as 'job_id', 
      job.name as 'job_name' 
    FROM users JOIN jobs ON (users.job = jobs.id)
  &quot;);
}, false, $loadMap);
</code></pre>

<p>So we should have enough info now to understand in plain English what is happening above. 
Our LoadMap states that we should load the "email" in as the username on the User models we fetch.
Then the 2nd array states that we should load the Job relationship and pass it the LoadMap embedded 
there, which will map job_id and job_name to the correct fields on the Job model. Finally we're taking
that LoadMap and popping it in as the 3rd argument to our repository call which we customized to do a JOIN
for the extra data.</p>
<p>One handy thing that can save you a lot of code clutter are on-model LoadMaps if you have a situation where 
you always want to fetch additional info with a model. See <a href="../../../../documentation/v2/ADM/subsets_loadmapping/#on-model-loadmaps">HERE</a> 
to jump to that section.</p>
<h2 id="use-case-4-onload-function">Use Case #4: onLoad Function</h2>
<p>In addition to mapping fields to the model and controlling which relationships get loaded, another thing
LoadMaps can do that you might find useful is dynamically setting properties onLoad. Models have an <a href="../../../../documentation/v2/ADM/lifecycle/">onLoad()
function</a> to which you can hard-code stuff. However, if you're running custom 
queries, you may find yourself wanting to do stuff onLoad that isn't built into the models. This is where the 
3rd and 4th parameters on LoadMaps come in handy.</p>
<p>The 3rd LoadMap argument should be a function that takes a self reference to the model as it's first argument like 
so:</p>
<pre><code>$loadMap = new \Cora\Adm\LoadMap([], [],
  function($model) {
    $model-&gt;status = &quot;new&quot;;
  }
);
$users = $repo-&gt;findAll(false, false, $loadMap);
</code></pre>

<p>In the above example we're setting the status of any models fetched to "new". However, in addition to using 
the values in the model, you may want to pass variables into the closure. You can do that with the LoadMap's
4th parameter. Example:</p>
<pre><code>$loadMap = new \Cora\Adm\LoadMap([], [],
  function($model, $str1) {
    $model-&gt;status = $str1;
  },
  ['new']
);
$users = $repo-&gt;findAll(false, false, $loadMap);
</code></pre>

<p>If you need to pass multiple variables in, you can do so like this:</p>
<pre><code>$loadMap = new \Cora\Adm\LoadMap([], [],
  function($model, $var1, $var2) {
    $model-&gt;status = $var1;
    $model-&gt;name   = $var2;
  },
  ['new', 'fooBar']
);
$users = $repo-&gt;findAll(false, false, $loadMap);
</code></pre>

<h2 id="complicated-example-revisited">Complicated Example Revisited</h2>
<p>Now that we've covered all the individual pieces of LoadMaps, it's time to revisit the complicated 
example displayed at the start and make sure you can interpret what it means now:</p>
<p><strong>Complicated LoadMap:</strong></p>
<pre><code>$loadMap = new \Cora\Adm\LoadMap([
    'category' =&gt; 'type'
  ], [
    'madeBy' =&gt; new \Cora\Adm\LoadMap([
      'user_firstName' =&gt; 'firstName',
      'user_lastName' =&gt; 'lastName',
      'user_id' =&gt; 'id'
    ], [
      'Job' =&gt; new \Cora\Adm\LoadMap([
        'job_id' =&gt; 'id',
        'job_name' =&gt; 'name',
        'created_date' =&gt; '!created_date'
      ])
    ])
  ],
  function($model, $str) {
    $model-&gt;status = $str;
  },
  ['New']
);
</code></pre>

<p><strong>Let's step through this:</strong>   </p>
<ul>
<li>The first array that says <code>'category' =&gt; 'type'</code> is a field mapping for whatever model you are 
fetching from the repository (in all our examples it's been User models).</li>
<li>The second array which says <code>'madeBy' =&gt; new LoadMap()</code> states that ADM should load the madeBy 
relationship (which in this example would be another User) and use the LoadMap embedded there as 
the mapping for any model(s) fetched for that relationship.</li>
<li>The <code>'Job' =&gt; new LoadMap()</code> section is the 2nd argument to the <code>madeBy</code> LoadMap in the same way 
that <code>madeBy</code> is the 2nd argument to the root level LoadMap. What this means is that when the 
<code>madeBy</code> User model is fetched, the Job relationship on that model should also be loaded and the 
job name and ID should be mapped using the embedded loadMap there.</li>
<li>Finally the 3rd and 4th arguments are the onLoad function and variables for the root level User models.</li>
</ul>
<p>Hopefully that explains what's going on. As you can see, the structure is recursive in that you can 
embed LoadMaps inside other LoadMaps in a multi-level way to accomodate any level of depth you need 
to handle when deciding what you want loaded on a model and giving you the ability to map variables from your 
custom JOINed query to model relationships that are buried multiple levels deep in your returned models.</p>
<p>It's probably also clear that this functionality can easily get very complex if you need to load anything deeper 
than immediate relationships, so use it as you see fit. It's a powerful feature.</p>
<h2 id="forced-loading-advanced">Forced Loading Advanced</h2>
<p>In one of the sections above we spoke about loading additional related models and how to force certain relationships to be 
pre-loaded, especially in the context of returning data from an API endpoint. One of the examples given was:</p>
<pre><code>// The second parameter of a LoadMap is for passing an array 
// of relationships you want pre-loaded
$loadMap = new \Cora\Adm\LoadMap([], [
  'job' =&gt; true
]);

// Just add the LoadMap as the 3rd argument to our findAll() call
$users = $repo-&gt;findAll(false, false, $loadMap);
</code></pre>

<p>One thing that's important to know is that the boolean true for loading the "job" relationship as seen 
in that example is the same as doing:</p>
<pre><code>$loadMap = new \Cora\Adm\LoadMap([], [
  'job' =&gt; new \Cora\Adm\LoadMap([], [], true)
]);
</code></pre>

<p>That third argument to the LoadMap specifies that the 'job' relationship needs to be fetched on its own using a separate query.
Why would you need to specify that? Well, when you define a LoadMap within another LoadMap, there is an assumption made that the 
main query which will be run will return all the data needed for any SINGULAR nested models. Because of this assumption, dynamic 
loading is disabled for singular relationships so that the LoadMap can map the data to the model. </p>
<p>I realize that's a mouthful, so let's look at an example that will hopefully make sense of what we're talking about. 
Notice the line <code>'role' =&gt; new \Cora\Adm\LoadMap()</code> in the following because it's the nested LoadMap we're talking about:</p>
<pre><code>// Create LoadMap
$loadMap = new \Cora\Adm\LoadMap([], [
  'role' =&gt; new \Cora\Adm\LoadMap([
    'role_id' =&gt; 'id'
  ])
]);

// Custom data fetch to fetch Users with their Role info in one query
$users = $repo-&gt;findAll(function($query) {
  $query-&gt;join('roles', [['users.role', '=', 'roles.id']])
        -&gt;select([&quot;users.*&quot;, &quot;roles.id as 'role_id'&quot;, &quot;role.title&quot;]);
  return $query;
}, false, $loadMap);
</code></pre>

<p>Because the "role" relationship is defined using a nested LoadMap, ADM assumes we will be doing a customized query 
with a JOIN (which we are doing in the example). This way, no extra queries are needed to fetch the Role model data,
which makes the code super fast. </p>
<p>However, what if each Role had a list of Permissions attached to it, and you wanted those fetched too? Well you can 
specify you want that additional relationship loaded using the second LoadMap parameter like so:</p>
<pre><code>// Create LoadMap
$loadMap = new \Cora\Adm\LoadMap([], [
  'role' =&gt; new \Cora\Adm\LoadMap([
    'role_id' =&gt; 'id'
  ], [
    'permissions' =&gt; true
  ])
]);

// Custom data fetch to fetch Users with their Role info in one query
$users = $repo-&gt;findAll(function($query) {
  $query-&gt;join('roles', [['users.role', '=', 'roles.id']])
        -&gt;select([&quot;users.*&quot;, &quot;roles.id as 'role_id'&quot;, &quot;role.title&quot;]);
  return $query;
}, false, $loadMap);
</code></pre>

<p>Now the Users and Roles will be fetched the same as before, but as each Role is loaded the permissions attached to 
it will also be fetched in a separate query.</p>
<p>Next, what if each Permission had a reference to a group of Users who have that permission and we wanted that User Group
loaded? Forcing that info to load would look like this:</p>
<pre><code>// Create LoadMap
$loadMap = new \Cora\Adm\LoadMap([], [
  'role' =&gt; new \Cora\Adm\LoadMap([
    'role_id' =&gt; 'id'
  ], [
    'permissions' =&gt; new \Cora\Adm\LoadMap([], [
      'userGroup' =&gt; true
    ], true)
  ])
]);
</code></pre>

<p>Finally, what if each User Permission Group had a User who was the designated moderator for some reason? Forcing 
that Moderator user model to load would look something like:</p>
<pre><code>// Create LoadMap
$loadMap = new \Cora\Adm\LoadMap([], [
  'role' =&gt; new \Cora\Adm\LoadMap([
    'role_id' =&gt; 'id'
  ], [
    'permissions' =&gt; new \Cora\Adm\LoadMap([], [
      'userGroup' =&gt; new \Cora\Adm\LoadMap([], [
        'moderator' =&gt; true
      ], true)
    ], true)
  ])
]);
</code></pre>

<h3 id="blank-models-when-force-loading">Blank Models When Force Loading</h3>
<p>What we were doing above with "true" booleans is what I call Forced Loading. You're telling ADM to always load that 
relationship when present. However, what happens when a relationship you're attempting to force load is null?</p>
<p>This question is especially important when working with APIs because changes in the format of the response can 
be annoying to deal with. For example, imagine this is the response some front-end javascript received from your 
API:</p>
<pre><code>[
  {
    name: &quot;User 1&quot;,
    userGroup: {
      name: &quot;Moderators&quot;
    }
  },
  {
    name: &quot;User 2&quot;,
    userGroup: null
  }
]
</code></pre>

<p>If you were to try doing a foreach loop and access the name of the UserGroup the user is in like so: 
<code>user.userGroup.name</code>, you'll likely encounter a null reference error because the 2nd user doesn't have a group.</p>
<p>When force loading singular models using a LoadMap, ADM will utilize blank models in order to standarize the response 
you give back if you do an automated toJson() call. In the case of plural relationships such as "permissions", 
if there are no related permissions, it will return an empty array.</p>
<p>To see how this works let's use a slightly simplified version of the LoadMap we recently defined as seen here:</p>
<pre><code>// Create LoadMap
$loadMap = new \Cora\Adm\LoadMap([], [
  'role' =&gt; new \Cora\Adm\LoadMap([], [
    'permissions' =&gt; new \Cora\Adm\LoadMap([], [
      'userGroup' =&gt; new \Cora\Adm\LoadMap([], [
        'moderator' =&gt; true
      ], true)
    ], true)
  ], true)
]);
</code></pre>

<p>And let's pretend we're doing code like the following that uses the data:</p>
<pre><code>foreach (users as user) {
  foreach (user.role.permissions as permission) {
    echo permission.userGroup.moderator.name
  }
}
</code></pre>

<p>Because of the system ADM employs to load blank models, the above pseudo code should run fine even if there are 
null values present in the data.</p>
<ul>
<li>First off, if there's no User models returned, then the loop never starts. </li>
<li>Even if a user has no assigned Role, a blank role will be returned for them causing the <code>user.role.permissions</code> reference 
to not error.</li>
<li>If a user has no permissions, then the Permissions relationship will be an empty array and never run the 2nd loop.</li>
<li>Once a Permission is in hand, "userGroup" is a singular relationship and we're forcing it to be loaded just like Role. 
What this means is that if the result of that relationship is null, ADM will return a blank dummy object with the correct properties
instead of null.</li>
<li>Finally, and for the 3rd time, moderator is a singular relationship and will also return a dummy object if null, one that has a blank 
string for the name property.</li>
</ul>
<p>In this way, relationships that you are forcing to load using a LoadMap should be fairly consistent and hopefully 
not require a ton of work arounds to deal with imperfect data.</p>
<h1 id="on-model-loadmaps">On-Model LoadMaps</h1>
<p>There may be situations where you ALWAYS want to fetch some additional information with a model. For instance, 
with your User models, maybe you always want to fetch their primaryRole information. When that happens you can 
use on-model LoadMaps combined with model constraints to remove the need to manually specify a custom query and 
LoadMap each time you need to grab those models out of a repository. Below we'll show a manual query and LoadMap
(with simple User model), and then show the equivalent functionality using an on-model LoadMap.</p>
<h2 id="manual-loadmap-example">Manual LoadMap Example</h2>
<p><strong>Model:</strong>   </p>
<pre><code>class User extends \Cora\App\Model {
  public $model_attributes = [
    'id' =&gt; [
      'type'          =&gt; 'int',
      'primaryKey'    =&gt; true
    ],
    'email' =&gt; [
      'type'  =&gt; 'varchar',
      'index' =&gt; true
    ],
    'firstName' =&gt; [
      'type' =&gt; 'varchar'
    ],
    'lastName' =&gt; [
      'type' =&gt; 'varchar'
    ],
    'primaryRole' =&gt; [
      'model' =&gt; 'Role'
    ]
  ];
}
</code></pre>

<p><strong>Fetching Models From Repository:</strong>   </p>
<pre><code>// Define LoadMap
$loadMap = new \Cora\Adm\LoadMap([], [
  'primaryRole' =&gt; new \Cora\Adm\LoadMap()
]);

// Fetch models using modified query and passing LoadMap
$users = $repo-&gt;findAll(function($query) {
  // Specify the JOIN we need
  return $query-&gt;join('roles', [['users.primaryRole', '=', 'roles.role_id']]);
}, false, $loadMap);
</code></pre>

<h2 id="on-model-loadmap-example">On-Model LoadMap Example</h2>
<p>The following model definition and repo use is equivalent to the manual example shown above.</p>
<p><strong>Model:</strong>   </p>
<pre><code>class User extends \Cora\App\Model {
  public $model_attributes = [
    'id' =&gt; [
      'type'          =&gt; 'int',
      'primaryKey'    =&gt; true
    ],
    'email' =&gt; [
      'type'  =&gt; 'varchar',
      'index' =&gt; true
    ],
    'firstName' =&gt; [
      'type' =&gt; 'varchar'
    ],
    'lastName' =&gt; [
      'type' =&gt; 'varchar'
    ],
    'primaryRole' =&gt; [
      'model' =&gt; 'Role'
    ]
  ];

  public static function model_loadMap() 
  {
    return new \Cora\Adm\LoadMap([], [
      'primaryRole' =&gt; new \Cora\Adm\LoadMap()
    ]);
  }

  public static function model_constraints($query) 
  {
    return $query-&gt;join('roles', [['users.primaryRole', '=', 'roles.role_id']]);
  }
}
</code></pre>

<p><strong>Fetching Models From Repository:</strong>   </p>
<pre><code>$users = $repo-&gt;findAll();
</code></pre>

<div class="alert alert-warning">
    NOTICE: If you have an on-model LoadMap defined and then pass a custom one to the repo when fetching models,
    the one passed in will override the on-model version.
</div></div>
        </div>

        <footer class="col-md-12">
            <hr>
            
            <center>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</center>
        </footer>

        <script src="../../../../js/jquery-1.10.2.min.js"></script>
        <script src="../../../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../../../js/highlight.pack.js"></script>
        <script>var base_url = '../../../..';</script>
        <script data-main="../../../../mkdocs/js/search.js" src="../../../../mkdocs/js/require.js"></script>
        <script src="../../../../js/base.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                        <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            From here you can search these documents. Enter
                            your search terms below.
                        </p>
                        <form role="form">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                            </div>
                        </form>
                        <div id="mkdocs-search-results"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>
    </body>
</html>