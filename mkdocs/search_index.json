{
    "docs": [
        {
            "location": "/",
            "text": "About Cora\n\n\nCora is an MVC style framework for rapidly building scalable web applications. \nThe goal of the project is to make a powerful and well-built infrastructure that is EASY TO USE and well documented. \nThis is a project aimed at experienced world-class developers and the just starting out novice alike. We don't shy away\nfrom advanced design patterns, but rather make every effort to encapsulate that complexity away from the developer\nso that they can focus on creating apps, not wrestling with a framework. Our hope\nis that this results in cleaner, more understandable code for all involved.\n\n\nCore Values\n\n\n\n\nCora should be easy to use.\n\n\nYou shouldn't need to spend a lot of time configuring things to get up and running.\n\n\nYou shouldn't need a degree in computer science to understand what is going on.\n\n\nYou shouldn't need to take a class on how to use the framework.\n\n\nThe framework should make your life as a developer easier, and help you work faster and better.\n\n\n\n\n\n\nLearning should fun.\n\n\nDocumentation should be useful to both experienced and novice developers alike.\n\n\nDocumentation should provide the needed info to experienced developers at a glance.\n\n\nMore in-depth documentation should be written in a ELI5 (Explain it Like I'm 5) style of explanation.\n\n\nDocumentation should be full of great examples to help bring understanding of the concepts.\n\n\n\n\n\n\nFlexible, Powerful, and Simple - Choose 3.\n\n\nCora should be able to accomodate a variety of programming styles.\n\n\nCora should be integratable into existing software projects.\n\n\nCora should provide developers with powerful tools to help make developing easier/faster.\n\n\nCora should be fully extendable and customizable.\n\n\nCora should do all this while staying simple.\n\n\n\n\n\n\n\n\nBeing a Trend-Setter for PHP\n\n\nPHP originally gained massive popularity for it's ease of entry and wide availability. While the wide availability is still there, \nit feels as though that focus on making PHP accessible to the masses has fallen off in recent years. As a result it could be argued that PHP\nhas lost its sense of identity, leaving it only as a mediocre contender amongst the group of popular programming languages where it can be argued that PHP has a syntax that\nis sub-par and lots of left-over baggage from it's pre-OOP days.\n\n\nIt's the hope of the Cora project to bring back that sense of excitement and identity that made PHP a standout language for so many years.\n\n\nSincerely, \n\nJosiah Bubna & Team\n\n\n\n\nNext: Installation",
            "title": "About"
        },
        {
            "location": "/#about-cora",
            "text": "Cora is an MVC style framework for rapidly building scalable web applications. \nThe goal of the project is to make a powerful and well-built infrastructure that is EASY TO USE and well documented. \nThis is a project aimed at experienced world-class developers and the just starting out novice alike. We don't shy away\nfrom advanced design patterns, but rather make every effort to encapsulate that complexity away from the developer\nso that they can focus on creating apps, not wrestling with a framework. Our hope\nis that this results in cleaner, more understandable code for all involved.",
            "title": "About Cora"
        },
        {
            "location": "/#core-values",
            "text": "Cora should be easy to use.  You shouldn't need to spend a lot of time configuring things to get up and running.  You shouldn't need a degree in computer science to understand what is going on.  You shouldn't need to take a class on how to use the framework.  The framework should make your life as a developer easier, and help you work faster and better.    Learning should fun.  Documentation should be useful to both experienced and novice developers alike.  Documentation should provide the needed info to experienced developers at a glance.  More in-depth documentation should be written in a ELI5 (Explain it Like I'm 5) style of explanation.  Documentation should be full of great examples to help bring understanding of the concepts.    Flexible, Powerful, and Simple - Choose 3.  Cora should be able to accomodate a variety of programming styles.  Cora should be integratable into existing software projects.  Cora should provide developers with powerful tools to help make developing easier/faster.  Cora should be fully extendable and customizable.  Cora should do all this while staying simple.",
            "title": "Core Values"
        },
        {
            "location": "/#being-a-trend-setter-for-php",
            "text": "PHP originally gained massive popularity for it's ease of entry and wide availability. While the wide availability is still there, \nit feels as though that focus on making PHP accessible to the masses has fallen off in recent years. As a result it could be argued that PHP\nhas lost its sense of identity, leaving it only as a mediocre contender amongst the group of popular programming languages where it can be argued that PHP has a syntax that\nis sub-par and lots of left-over baggage from it's pre-OOP days.  It's the hope of the Cora project to bring back that sense of excitement and identity that made PHP a standout language for so many years.  Sincerely,  \nJosiah Bubna & Team   Next: Installation",
            "title": "Being a Trend-Setter for PHP"
        },
        {
            "location": "/setup/install/",
            "text": "Installation and Setup\n\n\nThere are three main ways you can download and start using Cora. The easiest is going to be just using Composer, \nthe 2nd easiest would be to clone the Github repository, and lastly you could just download the ZIP off Github.\nSee below for instructions for each. First before you do that though, make sure you have the needed supporting software\nrunning on your machine.\n\n\nSetting Up A Computer For PHP Development\n\n\nThroughout this documentation there are a few pieces of software which are assumed to be on your computer. If you don't have these programs,\nthen you'll need to get them if you want to follow along with any examples we give.\n\n\nRequired: \"AMP\" stack\n \n\nFirstly, it is necessary you have some sort of \"AMP\" stack available on your computer. If you aren't familiar with this term, it's usually short for\nApache+MySQL+PHP, but is used as a catch-all term for having a web server (like Apache), a database solution (such as MySQL),\nand a programming language (such as PHP or Python). If you are just getting into development work and do not already have this\nsetup available on your computer, see below for some recommendations on getting that in place:\n\n\n\n\nIf you are using Windows or Linux, we'd recommend trying \nXAMPP\n.\n\n\nIf you are using a Mac, we'd recommend trying \nMAMP\n.\n\n\n\n\nRequired: Git\n \n\nGit is a type of version control software. Its most important feature is it allows multiple developers \nto work on a project at the same time by automatically (mostly) combining the code written and allowing \neach developer to grab the latest version of the codebase when someone else submits changes. However, \nit's also highly useful when working alone too. It will allow you to easily undo code if you break something \nand want to return your project to an earlier point in time, it will allow you to work on multiple in-progress \nnew features simultaneously without worrying about one partially finished feature screwing things up for another piece, etc.\nSo it's essential if you end up working in a team, and useful if you're by yourself, and overall a REALLY good habit to get used\nto using it. Pretty much all software developers use Git nowadays.\n\n\nTo install Git:\n\n\n\n\nYour best bet is probably to download Github Desktop which includes a copy of Git with it: \nGithub Desktop\n.\n\n\nAlternatively you can check out the installation options \nhere\n.\n\n\n\n\nRequired: Terminal/Powershell Window\n \n\nGraphical User Interfaces (GUIs) are what made computing friendly for the average Joe Shmo and lead us to the digitally connected society \nwe have today. However, if you're planning on getting into development work, you'll find it much easier to do if you get familar with using a terminal.\nA terminal is just a text interface where you can give your computer commands. If you want to learn more about how to use terminals, try Googling \n\"beginnners guide to using a terminal\" and some results will pop up.\n\n\n\n\nUsing Windows\n: Search your computer for \"Powershell\". Then make a shortcut to Windows Powershell where you can easily access it. It's important to note that the Git install adds Unix style commands to it which you will need to follow along with our tutorials - SO MAKE SURE YOU INSTALL GIT from the instructions above!\n\n\nUsing a Mac\n: We'd recommend you download \niTerm2\n.\n\n\nUsing Linux\n: Let's be honest... you don't need me to tell you how to access the terminal. \ncough\n likey Ctrl+Alt+T \ncough\n\n\n\n\nHighly Recommended: Composer\n \n\nComposer is a dependancy manager that helps you install and update software libraries (aka code written by other people that\nyou end up using in your project). This includes Cora itself! You can use Composer as an easy way to install Cora (instructions in the \nInstallation Using Composer section below) and update to the latest version of Cora later on down the road if a newer release comes out\nafter you've already started your project (see \nHERE\n for details on using Composer with Cora).\n\n\n\n\nTo download Composer go here \nhttps://getcomposer.org/\n.\n\n\n\n\nInstallation Using Composer\n\n\nOpen up a Terminal window and navigate to the location where you'd like to put the Cora folder that holds the project files. \nIf you are installing to your root web directory, typically this will be named \"htdocs\" or \"public_html\". \n\n\nMac\n\n\nFor instance: if you're using a Mac and installed MAMP, you probably want to navigate to\n\n\ncd /Applications/MAMP/htdocs\n\n\n\n\nWindows\n\n\nIf you're using Windows and installed XAMPP, you likely want to go to\n\n\ncd C:\\xampp\\htdocs\n\n\n\n\nGet Cora\n\n\nOnce you are at the location you want to install Cora to, type:\n\n\nphp composer.phar create-project cora/cora\n\n\n\n\nOR if you installed Composer globally as part of your PATH (which we'd recommend doing if you know how) type:\n\n\ncomposer create-project cora/cora\n\n\n\n\nThat's it!\n If all went well you should now have a folder named \"Cora\" in your specified directory.\n\n\nInstallation Using Git\n\n\nOpen up a Terminal window and navigate to the location where you'd like to put the Cora folder that holds the project files. \nIf you are installing to your root web directory, typically this will be named \"htdocs\" or \"public_html\". \nFor instance: if you're using a Mac and installed MAMP, you probably want to navigate to\n\n\ncd /Applications/MAMP/htdocs\n\n\n\n\nIf you're using Windows and installed XAMPP, you likely want to go to\n\n\ncd C:\\xampp\\htdocs\n\n\n\n\nOnce you are at the location you want to install Cora to, type:\n\n\ngit clone https://github.com/joebubna/Cora.git\n\n\n\n\nThat's it!\n If all went well you should now have a folder named \"Cora\" in your specified directory.\n\n\nInstallation From ZIP File\n\n\nGo to \nhttps://github.com/joebubna/Cora\n and click the \"Download ZIP\" button on the right hand side\nof the page. Use your Finder or File Explorer in your OS and go to your web directory (probably either \"C:\\xampp\\htdocs\" if you're on Windows\nor \"/Applications/MAMP/htdocs\" if you're on a Mac). Unpack the contents of the ZIP file into this directory.\n\n\nThat's it!\n If all went well you should now have a folder named \"Cora\" in your specified directory.\n\n\nConfiguration to Get it Working\n\n\nThere's a few configuration options that might need to be setup first before you can start using Cora. Click below to continue to the Configuration instructions. \n\n\n\n\nNext: Configuration",
            "title": "Installation"
        },
        {
            "location": "/setup/install/#installation-and-setup",
            "text": "There are three main ways you can download and start using Cora. The easiest is going to be just using Composer, \nthe 2nd easiest would be to clone the Github repository, and lastly you could just download the ZIP off Github.\nSee below for instructions for each. First before you do that though, make sure you have the needed supporting software\nrunning on your machine.",
            "title": "Installation and Setup"
        },
        {
            "location": "/setup/install/#setting-up-a-computer-for-php-development",
            "text": "Throughout this documentation there are a few pieces of software which are assumed to be on your computer. If you don't have these programs,\nthen you'll need to get them if you want to follow along with any examples we give.  Required: \"AMP\" stack   \nFirstly, it is necessary you have some sort of \"AMP\" stack available on your computer. If you aren't familiar with this term, it's usually short for\nApache+MySQL+PHP, but is used as a catch-all term for having a web server (like Apache), a database solution (such as MySQL),\nand a programming language (such as PHP or Python). If you are just getting into development work and do not already have this\nsetup available on your computer, see below for some recommendations on getting that in place:   If you are using Windows or Linux, we'd recommend trying  XAMPP .  If you are using a Mac, we'd recommend trying  MAMP .   Required: Git   \nGit is a type of version control software. Its most important feature is it allows multiple developers \nto work on a project at the same time by automatically (mostly) combining the code written and allowing \neach developer to grab the latest version of the codebase when someone else submits changes. However, \nit's also highly useful when working alone too. It will allow you to easily undo code if you break something \nand want to return your project to an earlier point in time, it will allow you to work on multiple in-progress \nnew features simultaneously without worrying about one partially finished feature screwing things up for another piece, etc.\nSo it's essential if you end up working in a team, and useful if you're by yourself, and overall a REALLY good habit to get used\nto using it. Pretty much all software developers use Git nowadays.  To install Git:   Your best bet is probably to download Github Desktop which includes a copy of Git with it:  Github Desktop .  Alternatively you can check out the installation options  here .   Required: Terminal/Powershell Window   \nGraphical User Interfaces (GUIs) are what made computing friendly for the average Joe Shmo and lead us to the digitally connected society \nwe have today. However, if you're planning on getting into development work, you'll find it much easier to do if you get familar with using a terminal.\nA terminal is just a text interface where you can give your computer commands. If you want to learn more about how to use terminals, try Googling \n\"beginnners guide to using a terminal\" and some results will pop up.   Using Windows : Search your computer for \"Powershell\". Then make a shortcut to Windows Powershell where you can easily access it. It's important to note that the Git install adds Unix style commands to it which you will need to follow along with our tutorials - SO MAKE SURE YOU INSTALL GIT from the instructions above!  Using a Mac : We'd recommend you download  iTerm2 .  Using Linux : Let's be honest... you don't need me to tell you how to access the terminal.  cough  likey Ctrl+Alt+T  cough   Highly Recommended: Composer   \nComposer is a dependancy manager that helps you install and update software libraries (aka code written by other people that\nyou end up using in your project). This includes Cora itself! You can use Composer as an easy way to install Cora (instructions in the \nInstallation Using Composer section below) and update to the latest version of Cora later on down the road if a newer release comes out\nafter you've already started your project (see  HERE  for details on using Composer with Cora).   To download Composer go here  https://getcomposer.org/ .",
            "title": "Setting Up A Computer For PHP Development"
        },
        {
            "location": "/setup/install/#installation-using-composer",
            "text": "Open up a Terminal window and navigate to the location where you'd like to put the Cora folder that holds the project files. \nIf you are installing to your root web directory, typically this will be named \"htdocs\" or \"public_html\".",
            "title": "Installation Using Composer"
        },
        {
            "location": "/setup/install/#mac",
            "text": "For instance: if you're using a Mac and installed MAMP, you probably want to navigate to  cd /Applications/MAMP/htdocs",
            "title": "Mac"
        },
        {
            "location": "/setup/install/#windows",
            "text": "If you're using Windows and installed XAMPP, you likely want to go to  cd C:\\xampp\\htdocs",
            "title": "Windows"
        },
        {
            "location": "/setup/install/#get-cora",
            "text": "Once you are at the location you want to install Cora to, type:  php composer.phar create-project cora/cora  OR if you installed Composer globally as part of your PATH (which we'd recommend doing if you know how) type:  composer create-project cora/cora  That's it!  If all went well you should now have a folder named \"Cora\" in your specified directory.",
            "title": "Get Cora"
        },
        {
            "location": "/setup/install/#installation-using-git",
            "text": "Open up a Terminal window and navigate to the location where you'd like to put the Cora folder that holds the project files. \nIf you are installing to your root web directory, typically this will be named \"htdocs\" or \"public_html\". \nFor instance: if you're using a Mac and installed MAMP, you probably want to navigate to  cd /Applications/MAMP/htdocs  If you're using Windows and installed XAMPP, you likely want to go to  cd C:\\xampp\\htdocs  Once you are at the location you want to install Cora to, type:  git clone https://github.com/joebubna/Cora.git  That's it!  If all went well you should now have a folder named \"Cora\" in your specified directory.",
            "title": "Installation Using Git"
        },
        {
            "location": "/setup/install/#installation-from-zip-file",
            "text": "Go to  https://github.com/joebubna/Cora  and click the \"Download ZIP\" button on the right hand side\nof the page. Use your Finder or File Explorer in your OS and go to your web directory (probably either \"C:\\xampp\\htdocs\" if you're on Windows\nor \"/Applications/MAMP/htdocs\" if you're on a Mac). Unpack the contents of the ZIP file into this directory.  That's it!  If all went well you should now have a folder named \"Cora\" in your specified directory.",
            "title": "Installation From ZIP File"
        },
        {
            "location": "/setup/install/#configuration-to-get-it-working",
            "text": "There's a few configuration options that might need to be setup first before you can start using Cora. Click below to continue to the Configuration instructions.    Next: Configuration",
            "title": "Configuration to Get it Working"
        },
        {
            "location": "/setup/configuration/",
            "text": "Configuring Cora\n\n\nIF you installed Cora to your root web directory, it should already be working. Test by going to\n\n\nhttp://localhost/cora\n\n\n\n\nIf it loads something, then Cora is working. If it doesn't work, then you probably either need to enable .htaccess files usage in apache,\nenable mod_rewrite in apache, you changed the name of something before reaching this article, or you didn't install Cora to your root web directory.\nIf you are using one of the suggested AMP packages from the installation page, everything should theoretically be working though.\n\n\nIf you didn't install Cora into your root directory, no worries, you'll just need to run through the following config instructions first before\nthings will work.\n\n\nStep 1: Change the Name of the Directory to Match Your Project\n\n\nBy default, the folder for Cora that got copied into your web directory should be named \"cora\". Just a guess, but you probably want to change\nthis to match the name of the project you plan on building. If for instance you want to create an app called \"My Awesome Site\", go ahead and rename\nthat cora directory to \"MyAwesomeSite\".\n\n\nStep 2: Change Your .htaccess File to Match Your Directory Name\n\n\nContinuing our \"MyAwesomeSite\" example, next you would need to open up the hidden \".htaccess\" file located within that directory and change the third line\ndown to:\n\n\nRewriteBase /MyAwesomeSite\n\n\n\n\nOR, if you installed Cora into a subfolder within your web directory, then you will need to include the full path from your root like so:\n\n\nRewriteBase /someFolder/MyAwesomeSite\n\n\n\n\nPerformance Note\n \n\nWhile on this topic, it should be noted that using a .htaccess file does have a performance cost. If you are planning on making an enterprise level app\nthat serves a large number of users, you'll probably want to eventually get rid of the .htaccess file and instead place the mod_rewrite rules into your server config.\nDoing this is beyond the scope of this documentation, but it's just something of which you should be aware.\n\n\nStep 3: Update the Site_Url in Your Config\n\n\nNext you need to open up the \"cora/config/config.php\" file in your project. The full path to this file should look something similar to this:\n\n\n/htdocs/MyAwesomeSite/cora/config/config.php\n\n\n\n\nThe first thing you should see are some commented out examples of commonly changed options like:\n\n\n#$config['debug'] = true;\n#$config['debugHide'] = false;\n#$config['site_url'] = '/cora/';\n#$config['cora_extension'] = 'MyApp';\n\n\n\n\nNote that this config file overrides any defaults that are located in\n\n\n/htdocs/MyAwesomeSite/vendor/cora/cora-framework/system/config/config.php\n\n\n\n\nGo ahead and uncomment the line for 'site_url' and change the value to match your new directory name. If your project is embedded in\nsub-directories, you do not need to include the full path, just the name of the folder the Cora project files are within. Example:\n\n\n$config['site_url'] = '/MyAwesomeSite/';\n\n\n\n\nStep 4: Create Your Project Controller\n\n\nGo ahead and open up any of the example controllers that are included in the controllers directory. The class declaration should look something like:\n\n\nclass Articles extends \\MyApp {\n\n\n\n\nAnytime you create a new controller, you want to have it extend from some \"base\" controller, which in the case above is \"MyApp\". This allows you to\nhave shared data and methods across all your controllers when necessary. Although you can leave the name of this base controller as \"MyApp\" if you want to,\nwe're guessing you'll probably want to change this to something more official sounding that matches the name of your project.\n\n\nNavigate to the \"cora/extensions/MyApp.php\" file in your project and make a copy of it, renaming the copy to \"MyAwesomeSite.php\". After you do this, make sure you open\nthe file and change the class name to MyAwesomeSite too. It should look like the following:\n\n\nclass MyAwesomeSite extends Cora\n\n\n\n\nThen go back and edit the Articles controller to extend from your new base class. Note that once you complete this setup guide and confirm everything is working, you'll then be able to go back and delete the MyApp file later if you want.\n\n\nStep 5: Make All Controllers Extend From Project Controller\n\n\nNow that you have your base project controller ready, you need to open up each of the controllers under your \"controllers\" directory and change them\nto extend from your new base controller instead of MyApp. They should all follow this format:\n\n\nclass Articles extends \\MyAwesomeSite {\n\n\n\n\nStep 6: Configure Your Database\n\n\nNext you need to open up the \"cora/config/database.php\" file in your project.\nThe full path to this file should look something similar to this:\n\n\n/htdocs/MyAwesomeSite/cora/config/database.php\n\n\n\n\nWithin this file you'll find a listing of connections and a way to set the\ndefault connection. You need to edit this with the connection info for your\ndatabase(s). It follows this format:\n\n\n$dbConfig['defaultConnection'] = 'MyFavoriteConnection';\n$dbConfig['connections'] = [\n    'Connection1' => [\n        'adaptor'   => 'MySQL',\n        'host'      => 'localhost:3306',\n        'dbName'    => 'cora',\n        'dbUser'    => 'root',\n        'dbPass'    => 'root'\n    ],\n    'Connection2' => [\n        'adaptor'   => 'MySQL',\n        'host'      => 'localhost:3306',\n        'dbName'    => 'cora2',\n        'dbUser'    => 'root',\n        'dbPass'    => 'root'\n    ],\n    'MyFavoriteConnection' => [\n        'adaptor'   => 'MySQL',\n        'host'      => 'localhost:3306',\n        'dbName'    => 'cora3',\n        'dbUser'    => 'root',\n        'dbPass'    => 'root'\n    ]\n];\n\n\n\n\nIf you are using a package like XAMPP, MAMP, etc, you'll probably want to go to\n\n\nhttp://localhost/phpmyadmin\n\n\n\n\nand create a database first before you can fill in this database config. So look\ninto doing that if you haven't already.\n\n\nFinished\n\n\nThat's it! You should be able to run your project and play around with it and the included demos now.\nIf you are an experienced user who wants to know about the advanced configuration options within Cora, or how Cora can be\nincorporated into an existing software project, click \nhere\n to view the advanced configuration tutorial.\nOtherwise, click below to continue on to the introductory tutorial to help you get acquainted with Cora.\n\n\n\n\nNext: Introduction to Cora",
            "title": "Configuration"
        },
        {
            "location": "/setup/configuration/#configuring-cora",
            "text": "IF you installed Cora to your root web directory, it should already be working. Test by going to  http://localhost/cora  If it loads something, then Cora is working. If it doesn't work, then you probably either need to enable .htaccess files usage in apache,\nenable mod_rewrite in apache, you changed the name of something before reaching this article, or you didn't install Cora to your root web directory.\nIf you are using one of the suggested AMP packages from the installation page, everything should theoretically be working though.  If you didn't install Cora into your root directory, no worries, you'll just need to run through the following config instructions first before\nthings will work.",
            "title": "Configuring Cora"
        },
        {
            "location": "/setup/configuration/#step-1-change-the-name-of-the-directory-to-match-your-project",
            "text": "By default, the folder for Cora that got copied into your web directory should be named \"cora\". Just a guess, but you probably want to change\nthis to match the name of the project you plan on building. If for instance you want to create an app called \"My Awesome Site\", go ahead and rename\nthat cora directory to \"MyAwesomeSite\".",
            "title": "Step 1: Change the Name of the Directory to Match Your Project"
        },
        {
            "location": "/setup/configuration/#step-2-change-your-htaccess-file-to-match-your-directory-name",
            "text": "Continuing our \"MyAwesomeSite\" example, next you would need to open up the hidden \".htaccess\" file located within that directory and change the third line\ndown to:  RewriteBase /MyAwesomeSite  OR, if you installed Cora into a subfolder within your web directory, then you will need to include the full path from your root like so:  RewriteBase /someFolder/MyAwesomeSite  Performance Note   \nWhile on this topic, it should be noted that using a .htaccess file does have a performance cost. If you are planning on making an enterprise level app\nthat serves a large number of users, you'll probably want to eventually get rid of the .htaccess file and instead place the mod_rewrite rules into your server config.\nDoing this is beyond the scope of this documentation, but it's just something of which you should be aware.",
            "title": "Step 2: Change Your .htaccess File to Match Your Directory Name"
        },
        {
            "location": "/setup/configuration/#step-3-update-the-site_url-in-your-config",
            "text": "Next you need to open up the \"cora/config/config.php\" file in your project. The full path to this file should look something similar to this:  /htdocs/MyAwesomeSite/cora/config/config.php  The first thing you should see are some commented out examples of commonly changed options like:  #$config['debug'] = true;\n#$config['debugHide'] = false;\n#$config['site_url'] = '/cora/';\n#$config['cora_extension'] = 'MyApp';  Note that this config file overrides any defaults that are located in  /htdocs/MyAwesomeSite/vendor/cora/cora-framework/system/config/config.php  Go ahead and uncomment the line for 'site_url' and change the value to match your new directory name. If your project is embedded in\nsub-directories, you do not need to include the full path, just the name of the folder the Cora project files are within. Example:  $config['site_url'] = '/MyAwesomeSite/';",
            "title": "Step 3: Update the Site_Url in Your Config"
        },
        {
            "location": "/setup/configuration/#step-4-create-your-project-controller",
            "text": "Go ahead and open up any of the example controllers that are included in the controllers directory. The class declaration should look something like:  class Articles extends \\MyApp {  Anytime you create a new controller, you want to have it extend from some \"base\" controller, which in the case above is \"MyApp\". This allows you to\nhave shared data and methods across all your controllers when necessary. Although you can leave the name of this base controller as \"MyApp\" if you want to,\nwe're guessing you'll probably want to change this to something more official sounding that matches the name of your project.  Navigate to the \"cora/extensions/MyApp.php\" file in your project and make a copy of it, renaming the copy to \"MyAwesomeSite.php\". After you do this, make sure you open\nthe file and change the class name to MyAwesomeSite too. It should look like the following:  class MyAwesomeSite extends Cora  Then go back and edit the Articles controller to extend from your new base class. Note that once you complete this setup guide and confirm everything is working, you'll then be able to go back and delete the MyApp file later if you want.",
            "title": "Step 4: Create Your Project Controller"
        },
        {
            "location": "/setup/configuration/#step-5-make-all-controllers-extend-from-project-controller",
            "text": "Now that you have your base project controller ready, you need to open up each of the controllers under your \"controllers\" directory and change them\nto extend from your new base controller instead of MyApp. They should all follow this format:  class Articles extends \\MyAwesomeSite {",
            "title": "Step 5: Make All Controllers Extend From Project Controller"
        },
        {
            "location": "/setup/configuration/#step-6-configure-your-database",
            "text": "Next you need to open up the \"cora/config/database.php\" file in your project.\nThe full path to this file should look something similar to this:  /htdocs/MyAwesomeSite/cora/config/database.php  Within this file you'll find a listing of connections and a way to set the\ndefault connection. You need to edit this with the connection info for your\ndatabase(s). It follows this format:  $dbConfig['defaultConnection'] = 'MyFavoriteConnection';\n$dbConfig['connections'] = [\n    'Connection1' => [\n        'adaptor'   => 'MySQL',\n        'host'      => 'localhost:3306',\n        'dbName'    => 'cora',\n        'dbUser'    => 'root',\n        'dbPass'    => 'root'\n    ],\n    'Connection2' => [\n        'adaptor'   => 'MySQL',\n        'host'      => 'localhost:3306',\n        'dbName'    => 'cora2',\n        'dbUser'    => 'root',\n        'dbPass'    => 'root'\n    ],\n    'MyFavoriteConnection' => [\n        'adaptor'   => 'MySQL',\n        'host'      => 'localhost:3306',\n        'dbName'    => 'cora3',\n        'dbUser'    => 'root',\n        'dbPass'    => 'root'\n    ]\n];  If you are using a package like XAMPP, MAMP, etc, you'll probably want to go to  http://localhost/phpmyadmin  and create a database first before you can fill in this database config. So look\ninto doing that if you haven't already.",
            "title": "Step 6: Configure Your Database"
        },
        {
            "location": "/setup/configuration/#finished",
            "text": "That's it! You should be able to run your project and play around with it and the included demos now.\nIf you are an experienced user who wants to know about the advanced configuration options within Cora, or how Cora can be\nincorporated into an existing software project, click  here  to view the advanced configuration tutorial.\nOtherwise, click below to continue on to the introductory tutorial to help you get acquainted with Cora.   Next: Introduction to Cora",
            "title": "Finished"
        },
        {
            "location": "/setup/advanced/",
            "text": "Advanced Config Options\n\n\nDebugging\n\n\n$config['debug'] = false;\n$config['debugHide'] = false;\n\n\n\n\nThese options are for helping you problem solve if the router doesn't seem to be finding your\ncontroller. The \"hide\" option just makes the routing messages show up in the HTML comments.\n\n\nCase-Sensitivity\n\n\n$config['lowercase_url'] = true;\n\n\n\n\nBy default Cora converts URLs into lowercase so that you can have consistent behavior on case-sensitive servers (e.g. Linux systems) regardless of whether\nor not a user types capital letters into the URL. However, if you wanted your URLs to be case-sensitive, you can disable this option in the config.\n\n\nDefault Controller\n\n\n$config['default_controller'] = 'Home';\n\n\n\n\nIf a user just goes to your homepage 'www.mysite.com`, what controller should this request\nbe routed to? You can set that here.\n\n\nRESTful Routing\n\n\n$config['enable_RESTful'] = true;\n\n\n\n\nWe'd recommend against it, but if you want to turn off RESTful routing in Cora, you may do so.\nTo learn more about how routing works within Cora, see \nHERE\n.\n\n\nFile Paths\n\n\n$config['basedir'] = dirname(__FILE__).'/../../../../../';\n\n/**\n *  Path to models/classes directory relative to this file.\n */\n$config['pathToModels'] = $config['basedir'].'classes/';\n\n/**\n *  Path to views directory relative to this file.\n */\n$config['pathToViews'] = $config['basedir'].'views/';\n\n/**\n *  Path to controllers directory relative to this file.\n */\n$config['pathToControllers'] = $config['basedir'].'controllers/';\n\n/**\n *  Path to libraries directory relative to this file.\n */\n$config['pathToLibraries'] = $config['basedir'].'libraries/';\n\n/**\n *  Path to events directory relative to this file.\n */\n$config['pathToEvents'] = $config['basedir'].'events/';\n\n/**\n *  Path to listeners directory relative to this file.\n */\n$config['pathToListeners'] = $config['basedir'].'listeners/';\n\n/**\n *  Path to App's Cora directory relative to this file.\n */\n$config['pathToCora'] = $config['basedir'].'cora/';\n\n\n\n\nBy default all these folders are set to be in your project's root - on the same level as the 'vendor' directory.\nHowever, you can obviously change this however you want. Another thing to take special notice of is that the\nfolder names themselves are defined here and can be changed. This might come in useful if you are integrating Cora\ninto an existing software project that already has its class files located in a specific directory somewhere.\n\n\nFile Naming Conventions\n\n\n/**\n *  Model/Class file prefix. I.e. If your class files are named \"class.MyClass.inc.php\"\n *  then enter 'class.' for Prefix and '.inc' for postfix.\n */\n$config['modelsPrefix'] = 'class.';\n$config['modelsPostfix'] = '';\n\n/**\n *  View file prefix / postfix.\n */\n$config['viewsPrefix'] = 'view.';\n$config['viewsPostfix'] = '';\n\n/**\n *  Controller file prefix / postfix.\n */\n$config['controllersPrefix'] = 'controller.';\n$config['controllersPostfix'] = '';\n\n/**\n *  Library file prefix / postfix.\n */\n$config['librariesPrefix'] = '';\n$config['librariesPostfix'] = '';\n\n/**\n *  Event file prefix / postfix.\n */\n$config['eventsPrefix'] = 'event.';\n$config['eventsPostfix'] = '';\n\n/**\n *  Listener file prefix / postfix.\n */\n$config['listenerPrefix'] = 'listen.';\n$config['listenerPostfix'] = '';\n\n\n\n\nHere you can set optional prefix and postfix naming conventions for your files. For instance, if your views\nare named \"view.someView.php\", you tell Cora about that \"view.\" prefix here and then you don't have to worry about the prefix or postfix\nin your controllers. For example: you would be able to load the above view by\n\n\n$this->load->view('someView');",
            "title": "Advanced Configuration"
        },
        {
            "location": "/setup/advanced/#advanced-config-options",
            "text": "",
            "title": "Advanced Config Options"
        },
        {
            "location": "/setup/advanced/#debugging",
            "text": "$config['debug'] = false;\n$config['debugHide'] = false;  These options are for helping you problem solve if the router doesn't seem to be finding your\ncontroller. The \"hide\" option just makes the routing messages show up in the HTML comments.",
            "title": "Debugging"
        },
        {
            "location": "/setup/advanced/#case-sensitivity",
            "text": "$config['lowercase_url'] = true;  By default Cora converts URLs into lowercase so that you can have consistent behavior on case-sensitive servers (e.g. Linux systems) regardless of whether\nor not a user types capital letters into the URL. However, if you wanted your URLs to be case-sensitive, you can disable this option in the config.",
            "title": "Case-Sensitivity"
        },
        {
            "location": "/setup/advanced/#default-controller",
            "text": "$config['default_controller'] = 'Home';  If a user just goes to your homepage 'www.mysite.com`, what controller should this request\nbe routed to? You can set that here.",
            "title": "Default Controller"
        },
        {
            "location": "/setup/advanced/#restful-routing",
            "text": "$config['enable_RESTful'] = true;  We'd recommend against it, but if you want to turn off RESTful routing in Cora, you may do so.\nTo learn more about how routing works within Cora, see  HERE .",
            "title": "RESTful Routing"
        },
        {
            "location": "/setup/advanced/#file-paths",
            "text": "$config['basedir'] = dirname(__FILE__).'/../../../../../';\n\n/**\n *  Path to models/classes directory relative to this file.\n */\n$config['pathToModels'] = $config['basedir'].'classes/';\n\n/**\n *  Path to views directory relative to this file.\n */\n$config['pathToViews'] = $config['basedir'].'views/';\n\n/**\n *  Path to controllers directory relative to this file.\n */\n$config['pathToControllers'] = $config['basedir'].'controllers/';\n\n/**\n *  Path to libraries directory relative to this file.\n */\n$config['pathToLibraries'] = $config['basedir'].'libraries/';\n\n/**\n *  Path to events directory relative to this file.\n */\n$config['pathToEvents'] = $config['basedir'].'events/';\n\n/**\n *  Path to listeners directory relative to this file.\n */\n$config['pathToListeners'] = $config['basedir'].'listeners/';\n\n/**\n *  Path to App's Cora directory relative to this file.\n */\n$config['pathToCora'] = $config['basedir'].'cora/';  By default all these folders are set to be in your project's root - on the same level as the 'vendor' directory.\nHowever, you can obviously change this however you want. Another thing to take special notice of is that the\nfolder names themselves are defined here and can be changed. This might come in useful if you are integrating Cora\ninto an existing software project that already has its class files located in a specific directory somewhere.",
            "title": "File Paths"
        },
        {
            "location": "/setup/advanced/#file-naming-conventions",
            "text": "/**\n *  Model/Class file prefix. I.e. If your class files are named \"class.MyClass.inc.php\"\n *  then enter 'class.' for Prefix and '.inc' for postfix.\n */\n$config['modelsPrefix'] = 'class.';\n$config['modelsPostfix'] = '';\n\n/**\n *  View file prefix / postfix.\n */\n$config['viewsPrefix'] = 'view.';\n$config['viewsPostfix'] = '';\n\n/**\n *  Controller file prefix / postfix.\n */\n$config['controllersPrefix'] = 'controller.';\n$config['controllersPostfix'] = '';\n\n/**\n *  Library file prefix / postfix.\n */\n$config['librariesPrefix'] = '';\n$config['librariesPostfix'] = '';\n\n/**\n *  Event file prefix / postfix.\n */\n$config['eventsPrefix'] = 'event.';\n$config['eventsPostfix'] = '';\n\n/**\n *  Listener file prefix / postfix.\n */\n$config['listenerPrefix'] = 'listen.';\n$config['listenerPostfix'] = '';  Here you can set optional prefix and postfix naming conventions for your files. For instance, if your views\nare named \"view.someView.php\", you tell Cora about that \"view.\" prefix here and then you don't have to worry about the prefix or postfix\nin your controllers. For example: you would be able to load the above view by  $this->load->view('someView');",
            "title": "File Naming Conventions"
        },
        {
            "location": "/tutorials/intro/",
            "text": "Intro\n\n\nThis page is not written yet! In the meantime, please play around in the demo project and refer to the articles under the \"Documentation\" tab for documentation on specific classes.\n\n\nAnother good resource at this point is to view a presentation I made on Cora which has explanations of how the routing works and displaying data. That presentation can be found here: \nCora Presentation on Google Docs.",
            "title": "Intro to Cora"
        },
        {
            "location": "/tutorials/intro/#intro",
            "text": "This page is not written yet! In the meantime, please play around in the demo project and refer to the articles under the \"Documentation\" tab for documentation on specific classes.  Another good resource at this point is to view a presentation I made on Cora which has explanations of how the routing works and displaying data. That presentation can be found here:  Cora Presentation on Google Docs.",
            "title": "Intro"
        },
        {
            "location": "/tutorials/composer/",
            "text": "Using Composer with Cora\n\n\nTest",
            "title": "Using Composer"
        },
        {
            "location": "/tutorials/composer/#using-composer-with-cora",
            "text": "Test",
            "title": "Using Composer with Cora"
        },
        {
            "location": "/documentation/v2/amblend/overview/",
            "text": "What is AmBlend?\n\n\nTL;DR It makes grabbing objects from and saving objects to a database super easy.\n\n\nIn short, AmBlend is the ORM tool developed for, and included with Cora.\nAn ORM (Object Relational Mapping) tool is something that handles moving data to and\nfrom objects and the database. This is useful when doing OO (object oriented) programming\nas it allows developers to focus on the core functionality and features of their application\nand not on the nitty-gritty grunt work of how to fetch and persist (aka 'save') data. This generally results\nin less code that needs to be written, and faster development times.\n\n\nAs an added bonus, using AmBlend allows Cora to build your database for you automatically\nbased on the definitions of your models, if you so desire.\n\n\nHow Does AmBlend Differ From Other ORMs?\n\n\nORM implementations basically boil down into two basic types: Active-Record or Data-Mapper.\nBoth have their pros and cons, but AmBlend was designed as a \"blend\" of both approaches ('AM'\nshort for Active-record and data-Mapper) with the goal of taking the best aspects of each and blending them\ninto a new paradigm. Below are the stereotypical strengths and weaknesses of each approach compared to AmBlend:\n\n\n\n  \n\n    \nProperty:\n\n    \nActive-Record\n\n    \nData-Mapper\n\n    \nAmBlend\n\n  \n\n  \n\n    \nEasy to Setup\n\n    \nYes\n\n    \nNo\n\n    \nYes\n\n  \n\n  \n\n    \nEasy to Use\n\n    \nYes\n\n    \nNo\n\n    \nYes\n\n  \n\n  \n\n    \nEasy to Test\n\n    \nNo\n\n    \nYes\n\n    \nYes\n\n  \n\n  \n\n  \nSRP\n Compliant\n\n    \nNo\n\n    \nYes\n\n    \nYes\n\n  \n\n  \n\n    \nDomain and Database Separation\n\n    \nNo\n\n    \nYes\n\n    \nYes\n\n  \n\n  \n\n    \nPerformance Optimization\n\n    \nDepends\n\n    \nDepends\n\n    \nYes*\n\n  \n\n\n\n\n\n*\n As much as possible, flexibility and optimization were kept in mind when building AmBlend. An explanation of the specific optimizations\nin place can be found in the optimizations section.\n\n\nFor more information about how AmBlend is implemented, see AmBlend's \"Implementation\" page.\n\n\nHow-to-Use Basics\n\n\nFirst you need to have your models extend from Cora's Model class, and add an associative array\nwhich defines the attributes of that model. See below for an example User model\nwhich has an ID, a couple strings in Name and Email, and a Job attribute which\nis another model representing the job of this user.\n\n\n\n\nDefine some Cora models:\n\n\nclass User extends \\Cora\\Model {\n\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar'\n        ],\n        'job' => [\n            'model' => 'job'\n        ]\n    ];\n\n    public function __construct($name = null, $email = null)\n    {\n        $this->name = $name;\n        $this->email = $email;\n    }\n}\n\nclass Job extends \\Cora\\Model {\n\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'title' => [\n            'type' => 'varchar'\n        ],\n        'description' => [\n            'type' => 'varchar'\n        ]\n    ];\n\n    public function __construct($title = null, $description = null)\n    {\n        $this->title = $title;\n        $this->description = $description;\n    }\n}\n\n\n\n\nNotice you didn't have to use any special comments with @ symbols or anything else;\nyou inform Cora about what your model's attributes are using a normal array.\nFurthermore, there's nothing special about the constructors (you can write them\njust like you would any other class), AND there's nothing special about the\nproperties of a model either. If you want to add additional normal properties\nto the model that's all\nperfectly fine. All that's important to know is that unless a property is defined\nin the \"model_attributes\" array, AmBlend won't try to save it to a database.\nTo say that another way, you can add whatever properties you want\nto a model, AmBlend will just ignore them unless you also add that property to the\nmodel_attributes array. In that sense, you can use and create Cora models just\nlike you would any normal class. The only thing you need to be careful of is to not override\nthe _ \n get() and _ \n set() methods.\n\n\nNext you need to create your database(s).\n\n\n\n\nCreate Your Database:\n\n\nThe easiest way to create your database is to use AmBlend's automated database\ncreation tool! In order to take advantage of this feature, you need to make sure\nyou've setup your database configuration. If you haven't done that yet,\n\nClick Here\n to view\ninstructions on doing so. The other thing you'll need (as of me writing this),\nis command line access. In the future, an in-browser\nvisual interface to the database creation tool may be added, but for now it's just\na command line tool.\n\n\n\n\n\nIf on a shared hosting environment:\n  \n\nBecause the database creation feature is a command line tool...\nwhat this means for people who will be hosting their app in\na shared hosting environment without command line access is that you'll need to\ngenerate your database on your local machine and then use a tool (such as PhpMyAdmin)\nto export your generated database into an SQL file you can upload.\n\n\n\n\nTo automatically generate a database based on your model definitions you need\nto do the following:\n\n\n\n\nOpen a Terminal.\n\n\nIf on a Mac, open your Applications, click the Utilities folder, and then\nselect the \"Terminal\" application.\n\n\nIf on a PC, hit your Windows Key + R to open the \"Run\" window, then type\nin \"cmd\" and hit enter.\n\n\nIf on Linux you don't need me to tell you how to do this, but since I can't\nhelp myself I'll mention that Ubuntu and Mint both map the terminal to\nCtrl+Alt+T.\n\n\n\n\n\n\nNavigate to your project's directory.\n\n\nIf you are XAMPP, MAMP, etc, that will likely be wherever you installed\nthat and then in the \"htdocs\" folder within.\n\n\n\n\n\n\nOnce at the root of your project, type \"php Amblend.php dbBuild\" to have\nAmBlend build your database for you.\n\n\nIf you get an error about PHP not being a recognized command, that means\nPHP is not a part of your operating system's PATH. Google \"add php to path\"\nor something similar if you aren't sure how to do this.\n\n\n\n\n\n\n\n\nIf all went well, you should see a flurry of output to the console and your database\nshould be ready to go!\n\n\nOf course, if you want to read through the documentation\nin the Models page to fully understand how the mappings work for the purpose of\nsetting your database(s) up manually, you can, although that takes more expertise\nand effort.\n\n\n\n\nStart Using AmBlend:\n\n\nAnd ... wait for it ... congratulations! You're now ready to start using AmBlend.\nSo we're all good to go, but how do we actually fetch models from and save models\nto the database? The answer is we need to use a Repository.\nSee below for an example Users controller where we use AmBlend to interact with\nour database. This Users controller will be very simple, we'll just have a method\nfor registering a new user, and an ultra simple Profile method that just echoes\nout the user's job title.\n\n\nUsing AmBlend in a Controller:\n\n\nclass Users extends \\MyApp\n{\n    protected $repo;\n    protected $db;\n\n    public function __construct()\n    {\n        parent::__construct();\n        $this->repo = \\Cora\\RepositoryFactory::make('User');\n    }\n\n    /**\n     *  Create a new user.\n     */\n    public function register()\n    {\n        // Grab our inputs. We'll just use fake data instead of\n        // actually capturing it from a form.\n        $name = 'Bob';                // $this->input->post('name');\n        $email = 'Bob@fakeEmail.com'; // $this->input->post('email');\n\n        // Create a new User.\n        $user = new User($name, $email);\n\n        // Assign the user a job.\n        $user->job = new Job('Athlete', 'Track and Field');\n\n        // Save the user to the database.\n        $this->repo->save($user);\n\n        // When the user was saved to the database, AmBlend\n        // assigned the object the unique ID the database provided it.\n        // Let's echo this user's ID.\n        echo $user->id;\n    }\n\n    /**\n     *  Display a user's profile.\n     *  In this case, just echo their job title.\n     */\n    public function profile($id)\n    {\n        $user = $this->repo->find($id);\n        echo $user->job->title;\n    }\n}\n\n\n\n\nIf you have the Cora demo project installed, you can run this code and see it\nworking in action. First you'll want to go to:\n\n\nhttp://localhost/{myProjectName}/users/register\n\n\n\n\n^ Replace \"{myProjectName}\" with the name of the folder your Cora demo project\nis in. This should create our user \"Bob\" and then echo out to the browser\nthe ID number assigned to him. If you use that ID, you can then go to the profile\npage at:\n\n\nhttp://localhost/{myProjectName}/users/profile/{id}\n\n\n\n\n^ Where {id} is the ID of Bob. If Bob's ID is \"2\":\n\n\nhttp://localhost/{myProjectName}/users/profile/2\n\n\n\n\nAnd just like that, AmBlend saved our user Bob to the database as represented\nby the User object, saved a separate Job object to the database that represents\nthe job Bob does, and automatically handled setting up the associations for you\nbetween the objects. This is why you can do:\n\n\necho $user->job->title;\n\n\n\n\non the profile page and have it work so effortlessly. Behind-the-scenes\nAmBlend is doing all the heavy-lifting busy work for you to make saving and\nretrieving objects along with any other objects associated with them a breeze.\n\n\n\n\nExplanation Pitstop:\n \n\nSo the one thing I didn't talk about in the code above is what's happening\nin the constructor for our Users controller where we are creating our Repository object.\n\n\nIn programming lingo a \"factory\" is a class that handles creating objects for you.\nThe easiest way to get a Repository of a certain type is to use Cora's RepositoryFactory\nclass' Make method and telling it what type of repository you want to create.\nSo the code as seen below is just the simplest way of creating a User class repository:\n\n\n$this->repo = \\Cora\\RepositoryFactory::make('User');\n\n\n\n\nFor more information about the Repository, Gateway, Factory pattern I recommend\nreading the documentation page for each under the AmBlend ORM section.\n\n\n\n\nOptimizing Performance\n\n\nOk, now that's we've seen the bare basics of how AmBlend works, let's talk for a minute\nabout how it tries to make your app lean and fast. In general, ORMs get a bad rap\nfor being inefficient, and rightfully so. I've read the horror stories of engineers\ncalled in to speed up programs only to find out the ORM used by the program is spitting\nout super ugly and inefficient queries that are like trying to kill a fly with a\nheavy machine gun! In terms of AmBlend, my goal here is to describe\nexactly how it works so you can make your own judgements about when or when not to use it.\n\n\n\"Light\" Classes:\n\n\nFirst up, when grabbing data from a row in the database for the purpose of populating\nan object, by default, AmBlend will grab all the data in that row. That is to say:\n\n\n$user = $this->repo->find($id);\n\n\n\n\nIs the SQL equivalent to doing:\n\n\nSELECT * FROM users WHERE id = :id\n\n\n\n\nOne of the optimizations in AmBlend is the ability to dynamically create \"light\"\nversions of a class by not grabbing all the class data, and instead only grabbing\nthe data you need. This is possible because AmBlend uses Cora's Database class\nto interact with the persistence layer, and allows you to pass a partial query\nalong to the repository when asking for models. See below for example. You can\nadd the following method to the Users controller we previously used to see this in\naction:\n\n\npublic function lightClassDemo($id)\n{\n    $this->db->where('id', $id);\n    $this->db->select(['id', 'name']);\n    $user = $this->repo->findOne($this->db);  \n    var_dump($user);\n}\n\n\n\n\nIs equivalent to doing:\n\n\nSELECT id, name FROM users WHERE id = :id\n\n\n\n\nWhat we're leaving out here is the user's email and their job, maybe because whatever we're\ndoing with the object doesn't require that info. It's a general rule when optimizing\nperformance to only grab what you need, and with this functionality, AmBlend\ngives you that capability.\n\n\n(Note that you can use findAll() to similarly fetch\na collection of \"light\" objects.)\n\n\nCollection Subsets:\n\n\nAlright, say you want to print out a list of users, but you don't want to list all\nusers, just the ones that are Admins. Using the same methodology we\nused in the previous section to create a \"light\" version of a class, we can also\nlimit the objects we are grabbing to a subset of a whole collection. (Note: this\nexample assumes there's some sort of \"type\" attribute on the user model):\n\n\npublic function subsetDemo()\n{\n    $this->db->where('type', 'Admin');\n    $users = $this->repo->findAll($this->db);\n\n    foreach ($users as $user) {\n        echo $user->name.'<br>';\n    }\n}\n\n\n\n\nThis is yet another example of how AmBlend let's you only fetch the data you need,\nso you aren't wasting system resources.\n\n\nDynamic Loading\n\n\nAKA - How related objects are fetched:\n\n\nAlright, now that we've talked about how data on the class' main table can be limited\n(\"light\" classes) and how repositories can be asked to return only a subset of\nobjects in a collection... let's continue our discussion of performance by going\nover HOW AmBlend grabs related objects.\n\n\nBy \"related objects\" what I'm referring to is say the Job object associated with\na user from one of our previous examples on this page. Another example would be\nif you were creating a blogging site and each user had a collection of \"articles\"\nthey've written where each article is its own object. If you are an experienced\ndeveloper who's concerned about performance, how AmBlend grabs these related objects\nfrom a database is something you should know.\n\n\nThe answer to that question is that AmBlend only grabs related objects \"on-demand\"\nutilizing what I call Dynamic Loading. The way in which this is done varies a little\nbit depending on how the data is stored, but all follows the same concept.\nGoing back to the \"User has a Job\" example, the way we defined the Job attribute\non our User model as a simple, single related object means that our Users table\nwill have a \"job\" column that stores the ID of that user's job.\n\n\n\n\nIn the case of Bob as seen in the image of his Users table entry above, grabbing\nhis whole user object and doing a var_dump as seen in this code:\n\n\npublic function profile($id)\n{\n    $user = $this->repo->find($id);\n    var_dump($user);\n}\n\n\n\n\nHas the following applicable output:\n\n\nprotected 'model_data' =>\n    array (size=5)\n      'name' => string 'bob' (length=3)\n      'type' => string 'admin' (length=5)\n      'id' => string '1' (length=1)\n      'email' => string 'bob@fakeEmail.com' (length=17)\n      'job' => string '3' (length=1)\n\n\n\n\nAs you can see, the \"job\" attribute is NOT an object at this point, it's just\nan ID number that references a job object. However, through the power of AmBlend's\ndynamic loading, if you try and access Bob's job property, it will be fetched\nfrom the persistence layer and an object will replace the ID. To see this in\naction, let's echo out Bob's job title, and then do a var_dump afterwards to see\nthe difference:\n\n\npublic function profile($id)\n{\n    $user = $this->repo->find($id);\n    echo $user->job->title;\n    var_dump($user);\n}\n\n\n\n\nAnd the result of the var_dump now looks like:\n\n\nprotected 'model_data' =>\n    array (size=5)\n      'name' => string 'bob' (length=3)\n      'type' => string 'admin' (length=5)\n      'id' => string '1' (length=1)\n      'email' => string 'bob@fakeEmail.com' (length=17)\n      'job' =>\n        object(Job)[11]\n          public 'model_attributes' =>\n            array (size=3)\n              ...\n          protected 'model_data' =>\n            array (size=3)\n              ...\n\n\n\n\nAs you can see, the \"job\" attribute is no longer just an ID, it's been replaced\nby a full Job object!\n\n\n\n\nFor object collections or single objects that use a relation table:\n\n\nThis works similarly, but slightly different for related objects that use a\nrelation table or an \"owner\" type column on the related object's table. If Bob's\nUser table entry looked like this:\n\n\n\n\n(Notice the lack of a \"job\" column)\n\n\nAnd Jobs were getting related to Users by utilizing a separate relation table,\nthen the var_dump on User would look like this:\n\n\nprotected 'model_data' =>\n    array (size=5)\n      'name' => string 'bob' (length=3)\n      'type' => string 'admin' (length=5)\n      'id' => string '1' (length=1)\n      'email' => string 'bob@fakeEmail.com' (length=17)\n      'job' => int 1\n\n\n\n\nIn this scenario, the \"job\" attribute is NOT the ID of the related job object,\nbut rather just a boolean placeholder to let AmBlend's Dynamic Loading system know that\na related job exists, and that if Job is called for, it needs to use the reference\ntable to go fetch it!\n\n\nThis is obviously a slight difference, but one that could trip you up if you\ndon't realize how it's working.\n\n\n\n\nPerformance considerations of dynamic loading:\n\n\n\n    WARNING: So the info I'm about to talk about below is intended for experienced\n    enterprise-level developers! It's very \"nitty-gritty\", so don't say I didn't\n    warn you. If you get lost, don't worry, just skip this section.\n\n\n\n\nAlright, now that you should have an understanding of how AmBlend grabs related\nobjects (\"on-demand\" using dynamic loading), you can weigh the performance cost.\nOn one hand, the fact that AmBlend grabs only as little data as possible and grabs\nextra stuff as needed helps keep your objects lean. However, because a separate\nquery is run each time you need to fetch a related object, this has the potential\nto bombard your database with hundreds or even thousands of small queries for\nindividual objects. For example, let's pretend we have 1,000 users in our\nusers table and we execute the following code on a Users repository:\n\n\n// Fetches ALL users\n$users = $this->repo->findAll();\n\nforeach ($users as $user) {\n    echo $user->job->title;\n}\n\n\n\n\nThe loop will run 1,000 times, and since each Job will be fetched\nindividually using a separate query at the time it tries to get accessed, it will\nresult in the equivalent of 1,000 of these queries:\n\n\nSELECT * FROM jobs WHERE `id` = :id\n\n\n\n\nI'm not a database mega-expert, but I'm sure that doing\n1,000 small queries is less efficient than if you just did one larger query to\ngrab all the data you needed in one go. Maybe if you consider the fact that you'd\nthen have to loop through the results of the larger query to assign each row of\ndata to an object it might come out as a wash, but that's for you to decide and\nnot me. The point I want to communicate is that this is how it works when you\ntry and access related objects to whatever the primary object you're using is.\n\n\nIf you wanted to grab all the Jobs from the database and have AmBlend return\nthem for you as objects, but you DON'T want to go through that process of executing\n1,000 individual queries... you have a few options:\n\n\n\n\nAvoiding Lots of Mini-Queries - Option #0:\n\n\n(Yes, I did just call this option zero. On purpose.)\n\n\nThe fact of the matter is, looping through 1,000 users and accessing information\nabout each, is not a typical usage example. If you're building an object oriented\nreporting system, I could see this being the case, but in 95% of situations you're\nprobably iterating over a small collection. If you are making some sort of users\nlist, chances are you'll be using a pagination setup, and so you probably only\nneed to loop over a few dozen users at a time.\n\n\nIf you're building say a Forum post system, again you're probably only iterating\nover a few dozen users, and using a pagination system again if things get too long.\n\n\nIn my experience exploring things such as string matching algorithms,\nwhen dealing with small data sets, a simple brute-force solution\nusually performs as well or better than a fancy more eloquent one due to the\noverhead cost of setting up fancy solutions.\n\n\nSo if you're concerned about performance, do a little testing. You might find\nthe simplest option may be the best option.\n\n\n\n\nAvoiding Lots of Mini-Queries - Option #1:\n\n\nYou can just create a Jobs repository and ask for all the jobs. This will execute\na single query to fetch a collection of all the Jobs. The downside here is that\nunless you create a backwords reference from a Job to a User (our example from earlier on\nthis page didn't have one), you won't know what User(s) that Job is associated with.\nAlso worth noting, if you end up adding a backreference and using it, you might\nend up in the same individual queries situation.\n\n\nBut depending on what you're doing, just grabbing all the jobs this way and then\nmaybe doing some mapping between the collection of Jobs and the collection of Users\n(if necessary for the task) could be an option.\n\n\n\n\nAvoiding Lots of Mini-Queries - Option #2:\n\n\nIf you don't need the full related object, but just a piece of information from it,\nyou can add a join to the Repository query. For instance, let's say you don't need\nthe full Job object, but just need a user's job title. You can do the following:\n\n\npublic function joinDemo($id)\n{\n    $this->db->where('users.id', $id)\n             ->select(['users.id', 'users.name', 'jobs.title as job_title'])\n             ->join('ref_users_jobs', [['users.id', '=', 'ref_users_jobs.user']])\n             ->join('jobs', [['ref_users_jobs.job', '=', 'jobs.id']]);\n    $user = $this->repo->findOne($this->db);  \n    echo $user->job_title;\n}\n\n\n\n\n(NOTE: the above example is taken directly from the Cora demo project and Jobs are related\n    to Users via a relation table - which is different from our previous example on\n    this page where a Job ID was stored directly in the Users table)\n\n\nLooking at the select() method above, in addition to grabbing the user's ID and\nname, we are also doing some joins and then grabbing the user's job title.\nSince \"job_title\" is NOT defined in the User class attributes definition, AmBlend\nwill pass it into the object as a property, but it will not do anything further.\nWhat this means is that if you alter the title and then tell AmBlend to save\nthis user, the job title will NOT get saved since it's not technically part of the class\ndefinition. The job title is just merely extra data you asked AmBlend to grab, which it did.\n\n\nThis can be useful if you just need some simple read-only data about a user though!\nAs you can see in the code snippet above we were able to\necho out the title. I'm sure if you're an experienced developer and reading this\nyou can see how this could be useful as long as you're careful about when/how you\nuse it. It's just important to keep in mind that any object properties not defined\nin the model_attributes array are ignored when an object is saved.\n\n\nIt's also worth noting here that a (probably more convenient) way of doing the same\nthing is to utilize a model's lifecycle hooks to run some custom queries when a\nmodel is fetched or saved! By doing so you can fetch the extra data anytime you\nwould normally fetch an instance of the model, and you can save the extra data\nwhenever you tell a repository to save it. See the LifeCycle Hooks section for\nmore information.\n\n\n\n\nAvoiding Lots of Mini-Queries -  Option #3:\n\n\nYou can pass a custom built Gateway to a Repository that does whatever queries you\nwant and manipulates data in whatever way you want. AmBlend is great because it\nhandles the generic day-to-day fetching and persisting of objects for you, which is\nreally nice, BUT that doesn't mean you can't override its default behavior if you need\nto handle more complicated tasks. See the section below on how you can modify or\nreplace the default Gateway (the class in charge of fetching data from the persistence layer)\nwith a custom one of your own making.\n\n\nLimiting Resource Creation\n\n\nAnother optimization made in AmBlend is statically declared data when possible.\nSpecifically, since most apps are likely created using a single\ndatabase, the default database adaptor is stored statically. What this means is\nthat each time you trigger something like Dynamic Loading on an object that uses\nthe app's default database, AmBlend isn't creating a new database object each time,\nbut rather using the statically stored version if it exists. This means less\nwork to get setup.\n\n\nIt's a small thing, but every little improvement helps in the long run.\n\n\nOverriding Default Behavior\n\n\nSo one of the criticisms of the ActiveRecord pattern is it ties an object too\nclosely to a single table, and doesn't give the flexibility in how an object\nis fetched and saved that a developer might want. In most cases, this really isn't a problem (ActiveRecord\nis the most popular ORM pattern in use as of this writing to my knowledge after all).\nIn addition, as you've probably noticed if you've read this far down the page,\ngrabbing related objects from various different tables is an absolute BREEZE using\nAmBlend! However, there still may be situations that come up where a developer\nfeels the need for advanced models that are composed of direct data from multiple\ntables (\"direct data\" meaning numbers, strings, dates, etc).\n\n\nThe first thing I would caution a developer if they feel like they need to do this\nis to sleep on it, and re-examine what they're trying to accomplish. Does your\nobject REALLY need its data grabbed from multiple tables/sources? Can the data you\nwant to grab from a 2nd table be grabbed from a related object, rather than shoving it\ninto your current one? What about just doing a good old fashioned direct query\nusing Cora's database class? There are lifecycle hooks you can use when fetching\nor saving a model to run your custom query for fetching/saving this extra data.\nThe point I'm trying to make is that the option I'm going to share below,\nyou probably don't ever need to use... but I'll share it anyway because\nknowledge is power... or something like that.\n\n\nWriting Your Own Gateway:\n\n\nAlright, I'm not actually going to go into too much depth on this, as if you're\na developer who feels the need to write your own Gateway for fetching/persisting\nan object, you probably are pretty competent in your knowledge and skills. Instead\nI'll just gloss over the high-level process of doing this in Cora to save you\ntime having to dig as much into the code.\n\n\nThe steps I would take are as follows:\n\n\n\n\nEither extend Cora's Gateway class and override whatever method(s) you want,\n or copy+paste the existing class into a new file, delete the contents of the methods,\n and save it as whatever you want (something like \"UserGateway\" would make sense for\n a User class). Obviously don't forget to implement the methods with your own code.\n\n\nNow that you have your fancy custom Gateway ready to go, you just need to pass\n it into a Repository in place of the default one included in Cora. The way to\n go about doing this is to NOT use the RepositoryFactory like we've been using in\n our examples, and instead just go through the simple process of initializing a\n Repository for yourself like so:\n\n\n\n\n// Create the Factory and Gateway the repository will use.\n$factory = new Factory($class);\n$gateway = new UserGateway(...insert your parameters...);\n\n// Pass a gateway and factory to the repository.\n$repo    = new Repository($gateway, $factory);\n\n\n\n\nAs you can see, the process of replacing the gateway for an object repository is\ntrivial. The hard part is actually implementing the custom Gateway. Anyways, that's\nthe gist of it... happy coding!\n\n\nUsing a different database layer\n\n\nAmBlend provides a lot of ways to customize the way it gets data. If you just want to do some \nsimple modifications to the query it runs to get the data that populates the models, then read \nthe \"Light\" classes section of this document. However, at the time of this writing there are \nlimitations to the flexibility of the query builder for AmBlend (check the documentation for \nCora's Database class for the latest features and limitations). If you feel like the query builder \nthat powers AmBlend is just not cutting it for what you want to do, you can bypass it to fetch \nmodels using another database library.\n\n\nYou'll still need to have Cora's Database class setup in order to dynamically fetch related data for \na model or to save it back to the persistence layer, but using another library to fetch a list of \nmodels is easy. In the example below we'll use PDO combined with Cora's model factory to fetch a list\nof models.\n\n\nExample:\n\n\n// Grab database object and Cora model factory\n$db = new PDO($dsn, $user, $pass, $options);\n$factory = new \\Cora\\Factory('User');\n\n// Create query and get results. Here we'll grab users who have \"Rick\" in their name. \n// The only required data is the ID, but fetch any columns from the table that will be used.\n$sth = $db->prepare(\"SELECT user_id, name FROM `users` WHERE `name` LIKE '%Rick%' \");\n$sth->execute();\n$results = $sth->fetchAll(\\PDO::FETCH_ASSOC);\n\n// Use the factory to create Cora models. Note: Use make() if expecting a single model.\n$users = $factory->makeGroup($results);\n\n// Showing that it worked\nforeach ($users as $user) {\n    echo \"<h1>$user->name</h1>\";\n}\n\n\n\n\nTesting\n\n\nAlright, the first important thing to realize about AmBlend when considering testing\nis the Data-Mapper pattern it follows. Because the logic to persist a model is\nseparate from the model itself, you can do any of the following as suits your needs\nfor testing:\n\n\n\n\nYou can use a test Gateway to return fixed dummy data (see the \"writing your\n own gateway\" description above for more info). If you plan on leaving Dynamic Loading\n on, you'll also need to pass in to the Factory a database object you want used\n for testing (Dynamic Loading will use that DAO).\n\n\nYou can pass in a database object to a Test database connection in order to grab\n your testing data. This would look like so, where you need to pass the database object\n to both the Factory and Gateway:\n\n\n\n\n$db = \\Cora\\Database::getDb('name_of_test_db_connection');\n$class = 'User';\n$factory = new Factory($class, $db);\n$gateway = new Gateway($db);\n$repo    = new Repository($gateway, $factory);\n\n\n\n\n\n\nAnd last but not least, you can just create classes of whatever model you need\n by hand (not using the Repository/Gateway/Factory) and populate them with whatever\n you want. This works because Cora models are just normal everyday classes that you\n can use just like any other class. The one thing you'll want to be sure to do in this\n situation though is to turn off Dynamic Loading (see below).\n\n\n\n\nTurning off Dynamic Loading:\n\n\nLet's quickly talk about Dynamic Loading and how to turn it off. You'll\nrecall from previous discussions that Dynamic Loading is a nifty little feature\nthat allows a model to request additional related objects from a Repository on-demand.\nIf you are expecting this behavior, and want the model to be able to request related\nmodels on-demand, you don't need to do anything and can just leave this feature on.\nHowever, if you want full control over the model, and would like to turn Dynamic Loading\noff, you just need to flip the following boolean on the model:\n\n\n$user = $this->repo->find($id);\n$user->model_dynamicOff = true;",
            "title": "Overview"
        },
        {
            "location": "/documentation/v2/amblend/overview/#what-is-amblend",
            "text": "TL;DR It makes grabbing objects from and saving objects to a database super easy.  In short, AmBlend is the ORM tool developed for, and included with Cora.\nAn ORM (Object Relational Mapping) tool is something that handles moving data to and\nfrom objects and the database. This is useful when doing OO (object oriented) programming\nas it allows developers to focus on the core functionality and features of their application\nand not on the nitty-gritty grunt work of how to fetch and persist (aka 'save') data. This generally results\nin less code that needs to be written, and faster development times.  As an added bonus, using AmBlend allows Cora to build your database for you automatically\nbased on the definitions of your models, if you so desire.",
            "title": "What is AmBlend?"
        },
        {
            "location": "/documentation/v2/amblend/overview/#how-does-amblend-differ-from-other-orms",
            "text": "ORM implementations basically boil down into two basic types: Active-Record or Data-Mapper.\nBoth have their pros and cons, but AmBlend was designed as a \"blend\" of both approaches ('AM'\nshort for Active-record and data-Mapper) with the goal of taking the best aspects of each and blending them\ninto a new paradigm. Below are the stereotypical strengths and weaknesses of each approach compared to AmBlend:  \n   \n     Property: \n     Active-Record \n     Data-Mapper \n     AmBlend \n   \n   \n     Easy to Setup \n     Yes \n     No \n     Yes \n   \n   \n     Easy to Use \n     Yes \n     No \n     Yes \n   \n   \n     Easy to Test \n     No \n     Yes \n     Yes \n   \n   \n   SRP  Compliant \n     No \n     Yes \n     Yes \n   \n   \n     Domain and Database Separation \n     No \n     Yes \n     Yes \n   \n   \n     Performance Optimization \n     Depends \n     Depends \n     Yes* \n     *  As much as possible, flexibility and optimization were kept in mind when building AmBlend. An explanation of the specific optimizations\nin place can be found in the optimizations section.  For more information about how AmBlend is implemented, see AmBlend's \"Implementation\" page.",
            "title": "How Does AmBlend Differ From Other ORMs?"
        },
        {
            "location": "/documentation/v2/amblend/overview/#how-to-use-basics",
            "text": "First you need to have your models extend from Cora's Model class, and add an associative array\nwhich defines the attributes of that model. See below for an example User model\nwhich has an ID, a couple strings in Name and Email, and a Job attribute which\nis another model representing the job of this user.",
            "title": "How-to-Use Basics"
        },
        {
            "location": "/documentation/v2/amblend/overview/#define-some-cora-models",
            "text": "class User extends \\Cora\\Model {\n\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar'\n        ],\n        'job' => [\n            'model' => 'job'\n        ]\n    ];\n\n    public function __construct($name = null, $email = null)\n    {\n        $this->name = $name;\n        $this->email = $email;\n    }\n}\n\nclass Job extends \\Cora\\Model {\n\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'title' => [\n            'type' => 'varchar'\n        ],\n        'description' => [\n            'type' => 'varchar'\n        ]\n    ];\n\n    public function __construct($title = null, $description = null)\n    {\n        $this->title = $title;\n        $this->description = $description;\n    }\n}  Notice you didn't have to use any special comments with @ symbols or anything else;\nyou inform Cora about what your model's attributes are using a normal array.\nFurthermore, there's nothing special about the constructors (you can write them\njust like you would any other class), AND there's nothing special about the\nproperties of a model either. If you want to add additional normal properties\nto the model that's all\nperfectly fine. All that's important to know is that unless a property is defined\nin the \"model_attributes\" array, AmBlend won't try to save it to a database.\nTo say that another way, you can add whatever properties you want\nto a model, AmBlend will just ignore them unless you also add that property to the\nmodel_attributes array. In that sense, you can use and create Cora models just\nlike you would any normal class. The only thing you need to be careful of is to not override\nthe _   get() and _   set() methods.  Next you need to create your database(s).",
            "title": "Define some Cora models:"
        },
        {
            "location": "/documentation/v2/amblend/overview/#create-your-database",
            "text": "The easiest way to create your database is to use AmBlend's automated database\ncreation tool! In order to take advantage of this feature, you need to make sure\nyou've setup your database configuration. If you haven't done that yet, Click Here  to view\ninstructions on doing so. The other thing you'll need (as of me writing this),\nis command line access. In the future, an in-browser\nvisual interface to the database creation tool may be added, but for now it's just\na command line tool.   If on a shared hosting environment:   \n\nBecause the database creation feature is a command line tool...\nwhat this means for people who will be hosting their app in\na shared hosting environment without command line access is that you'll need to\ngenerate your database on your local machine and then use a tool (such as PhpMyAdmin)\nto export your generated database into an SQL file you can upload.  To automatically generate a database based on your model definitions you need\nto do the following:   Open a Terminal.  If on a Mac, open your Applications, click the Utilities folder, and then\nselect the \"Terminal\" application.  If on a PC, hit your Windows Key + R to open the \"Run\" window, then type\nin \"cmd\" and hit enter.  If on Linux you don't need me to tell you how to do this, but since I can't\nhelp myself I'll mention that Ubuntu and Mint both map the terminal to\nCtrl+Alt+T.    Navigate to your project's directory.  If you are XAMPP, MAMP, etc, that will likely be wherever you installed\nthat and then in the \"htdocs\" folder within.    Once at the root of your project, type \"php Amblend.php dbBuild\" to have\nAmBlend build your database for you.  If you get an error about PHP not being a recognized command, that means\nPHP is not a part of your operating system's PATH. Google \"add php to path\"\nor something similar if you aren't sure how to do this.     If all went well, you should see a flurry of output to the console and your database\nshould be ready to go!  Of course, if you want to read through the documentation\nin the Models page to fully understand how the mappings work for the purpose of\nsetting your database(s) up manually, you can, although that takes more expertise\nand effort.",
            "title": "Create Your Database:"
        },
        {
            "location": "/documentation/v2/amblend/overview/#start-using-amblend",
            "text": "And ... wait for it ... congratulations! You're now ready to start using AmBlend.\nSo we're all good to go, but how do we actually fetch models from and save models\nto the database? The answer is we need to use a Repository.\nSee below for an example Users controller where we use AmBlend to interact with\nour database. This Users controller will be very simple, we'll just have a method\nfor registering a new user, and an ultra simple Profile method that just echoes\nout the user's job title.  Using AmBlend in a Controller:  class Users extends \\MyApp\n{\n    protected $repo;\n    protected $db;\n\n    public function __construct()\n    {\n        parent::__construct();\n        $this->repo = \\Cora\\RepositoryFactory::make('User');\n    }\n\n    /**\n     *  Create a new user.\n     */\n    public function register()\n    {\n        // Grab our inputs. We'll just use fake data instead of\n        // actually capturing it from a form.\n        $name = 'Bob';                // $this->input->post('name');\n        $email = 'Bob@fakeEmail.com'; // $this->input->post('email');\n\n        // Create a new User.\n        $user = new User($name, $email);\n\n        // Assign the user a job.\n        $user->job = new Job('Athlete', 'Track and Field');\n\n        // Save the user to the database.\n        $this->repo->save($user);\n\n        // When the user was saved to the database, AmBlend\n        // assigned the object the unique ID the database provided it.\n        // Let's echo this user's ID.\n        echo $user->id;\n    }\n\n    /**\n     *  Display a user's profile.\n     *  In this case, just echo their job title.\n     */\n    public function profile($id)\n    {\n        $user = $this->repo->find($id);\n        echo $user->job->title;\n    }\n}  If you have the Cora demo project installed, you can run this code and see it\nworking in action. First you'll want to go to:  http://localhost/{myProjectName}/users/register  ^ Replace \"{myProjectName}\" with the name of the folder your Cora demo project\nis in. This should create our user \"Bob\" and then echo out to the browser\nthe ID number assigned to him. If you use that ID, you can then go to the profile\npage at:  http://localhost/{myProjectName}/users/profile/{id}  ^ Where {id} is the ID of Bob. If Bob's ID is \"2\":  http://localhost/{myProjectName}/users/profile/2  And just like that, AmBlend saved our user Bob to the database as represented\nby the User object, saved a separate Job object to the database that represents\nthe job Bob does, and automatically handled setting up the associations for you\nbetween the objects. This is why you can do:  echo $user->job->title;  on the profile page and have it work so effortlessly. Behind-the-scenes\nAmBlend is doing all the heavy-lifting busy work for you to make saving and\nretrieving objects along with any other objects associated with them a breeze.   Explanation Pitstop:   \nSo the one thing I didn't talk about in the code above is what's happening\nin the constructor for our Users controller where we are creating our Repository object.  In programming lingo a \"factory\" is a class that handles creating objects for you.\nThe easiest way to get a Repository of a certain type is to use Cora's RepositoryFactory\nclass' Make method and telling it what type of repository you want to create.\nSo the code as seen below is just the simplest way of creating a User class repository:  $this->repo = \\Cora\\RepositoryFactory::make('User');  For more information about the Repository, Gateway, Factory pattern I recommend\nreading the documentation page for each under the AmBlend ORM section.",
            "title": "Start Using AmBlend:"
        },
        {
            "location": "/documentation/v2/amblend/overview/#optimizing-performance",
            "text": "Ok, now that's we've seen the bare basics of how AmBlend works, let's talk for a minute\nabout how it tries to make your app lean and fast. In general, ORMs get a bad rap\nfor being inefficient, and rightfully so. I've read the horror stories of engineers\ncalled in to speed up programs only to find out the ORM used by the program is spitting\nout super ugly and inefficient queries that are like trying to kill a fly with a\nheavy machine gun! In terms of AmBlend, my goal here is to describe\nexactly how it works so you can make your own judgements about when or when not to use it.",
            "title": "Optimizing Performance"
        },
        {
            "location": "/documentation/v2/amblend/overview/#light-classes",
            "text": "First up, when grabbing data from a row in the database for the purpose of populating\nan object, by default, AmBlend will grab all the data in that row. That is to say:  $user = $this->repo->find($id);  Is the SQL equivalent to doing:  SELECT * FROM users WHERE id = :id  One of the optimizations in AmBlend is the ability to dynamically create \"light\"\nversions of a class by not grabbing all the class data, and instead only grabbing\nthe data you need. This is possible because AmBlend uses Cora's Database class\nto interact with the persistence layer, and allows you to pass a partial query\nalong to the repository when asking for models. See below for example. You can\nadd the following method to the Users controller we previously used to see this in\naction:  public function lightClassDemo($id)\n{\n    $this->db->where('id', $id);\n    $this->db->select(['id', 'name']);\n    $user = $this->repo->findOne($this->db);  \n    var_dump($user);\n}  Is equivalent to doing:  SELECT id, name FROM users WHERE id = :id  What we're leaving out here is the user's email and their job, maybe because whatever we're\ndoing with the object doesn't require that info. It's a general rule when optimizing\nperformance to only grab what you need, and with this functionality, AmBlend\ngives you that capability.  (Note that you can use findAll() to similarly fetch\na collection of \"light\" objects.)",
            "title": "\"Light\" Classes:"
        },
        {
            "location": "/documentation/v2/amblend/overview/#collection-subsets",
            "text": "Alright, say you want to print out a list of users, but you don't want to list all\nusers, just the ones that are Admins. Using the same methodology we\nused in the previous section to create a \"light\" version of a class, we can also\nlimit the objects we are grabbing to a subset of a whole collection. (Note: this\nexample assumes there's some sort of \"type\" attribute on the user model):  public function subsetDemo()\n{\n    $this->db->where('type', 'Admin');\n    $users = $this->repo->findAll($this->db);\n\n    foreach ($users as $user) {\n        echo $user->name.'<br>';\n    }\n}  This is yet another example of how AmBlend let's you only fetch the data you need,\nso you aren't wasting system resources.",
            "title": "Collection Subsets:"
        },
        {
            "location": "/documentation/v2/amblend/overview/#dynamic-loading",
            "text": "AKA - How related objects are fetched:  Alright, now that we've talked about how data on the class' main table can be limited\n(\"light\" classes) and how repositories can be asked to return only a subset of\nobjects in a collection... let's continue our discussion of performance by going\nover HOW AmBlend grabs related objects.  By \"related objects\" what I'm referring to is say the Job object associated with\na user from one of our previous examples on this page. Another example would be\nif you were creating a blogging site and each user had a collection of \"articles\"\nthey've written where each article is its own object. If you are an experienced\ndeveloper who's concerned about performance, how AmBlend grabs these related objects\nfrom a database is something you should know.  The answer to that question is that AmBlend only grabs related objects \"on-demand\"\nutilizing what I call Dynamic Loading. The way in which this is done varies a little\nbit depending on how the data is stored, but all follows the same concept.\nGoing back to the \"User has a Job\" example, the way we defined the Job attribute\non our User model as a simple, single related object means that our Users table\nwill have a \"job\" column that stores the ID of that user's job.   In the case of Bob as seen in the image of his Users table entry above, grabbing\nhis whole user object and doing a var_dump as seen in this code:  public function profile($id)\n{\n    $user = $this->repo->find($id);\n    var_dump($user);\n}  Has the following applicable output:  protected 'model_data' =>\n    array (size=5)\n      'name' => string 'bob' (length=3)\n      'type' => string 'admin' (length=5)\n      'id' => string '1' (length=1)\n      'email' => string 'bob@fakeEmail.com' (length=17)\n      'job' => string '3' (length=1)  As you can see, the \"job\" attribute is NOT an object at this point, it's just\nan ID number that references a job object. However, through the power of AmBlend's\ndynamic loading, if you try and access Bob's job property, it will be fetched\nfrom the persistence layer and an object will replace the ID. To see this in\naction, let's echo out Bob's job title, and then do a var_dump afterwards to see\nthe difference:  public function profile($id)\n{\n    $user = $this->repo->find($id);\n    echo $user->job->title;\n    var_dump($user);\n}  And the result of the var_dump now looks like:  protected 'model_data' =>\n    array (size=5)\n      'name' => string 'bob' (length=3)\n      'type' => string 'admin' (length=5)\n      'id' => string '1' (length=1)\n      'email' => string 'bob@fakeEmail.com' (length=17)\n      'job' =>\n        object(Job)[11]\n          public 'model_attributes' =>\n            array (size=3)\n              ...\n          protected 'model_data' =>\n            array (size=3)\n              ...  As you can see, the \"job\" attribute is no longer just an ID, it's been replaced\nby a full Job object!",
            "title": "Dynamic Loading"
        },
        {
            "location": "/documentation/v2/amblend/overview/#for-object-collections-or-single-objects-that-use-a-relation-table",
            "text": "This works similarly, but slightly different for related objects that use a\nrelation table or an \"owner\" type column on the related object's table. If Bob's\nUser table entry looked like this:   (Notice the lack of a \"job\" column)  And Jobs were getting related to Users by utilizing a separate relation table,\nthen the var_dump on User would look like this:  protected 'model_data' =>\n    array (size=5)\n      'name' => string 'bob' (length=3)\n      'type' => string 'admin' (length=5)\n      'id' => string '1' (length=1)\n      'email' => string 'bob@fakeEmail.com' (length=17)\n      'job' => int 1  In this scenario, the \"job\" attribute is NOT the ID of the related job object,\nbut rather just a boolean placeholder to let AmBlend's Dynamic Loading system know that\na related job exists, and that if Job is called for, it needs to use the reference\ntable to go fetch it!  This is obviously a slight difference, but one that could trip you up if you\ndon't realize how it's working.",
            "title": "For object collections or single objects that use a relation table:"
        },
        {
            "location": "/documentation/v2/amblend/overview/#performance-considerations-of-dynamic-loading",
            "text": "WARNING: So the info I'm about to talk about below is intended for experienced\n    enterprise-level developers! It's very \"nitty-gritty\", so don't say I didn't\n    warn you. If you get lost, don't worry, just skip this section.  Alright, now that you should have an understanding of how AmBlend grabs related\nobjects (\"on-demand\" using dynamic loading), you can weigh the performance cost.\nOn one hand, the fact that AmBlend grabs only as little data as possible and grabs\nextra stuff as needed helps keep your objects lean. However, because a separate\nquery is run each time you need to fetch a related object, this has the potential\nto bombard your database with hundreds or even thousands of small queries for\nindividual objects. For example, let's pretend we have 1,000 users in our\nusers table and we execute the following code on a Users repository:  // Fetches ALL users\n$users = $this->repo->findAll();\n\nforeach ($users as $user) {\n    echo $user->job->title;\n}  The loop will run 1,000 times, and since each Job will be fetched\nindividually using a separate query at the time it tries to get accessed, it will\nresult in the equivalent of 1,000 of these queries:  SELECT * FROM jobs WHERE `id` = :id  I'm not a database mega-expert, but I'm sure that doing\n1,000 small queries is less efficient than if you just did one larger query to\ngrab all the data you needed in one go. Maybe if you consider the fact that you'd\nthen have to loop through the results of the larger query to assign each row of\ndata to an object it might come out as a wash, but that's for you to decide and\nnot me. The point I want to communicate is that this is how it works when you\ntry and access related objects to whatever the primary object you're using is.  If you wanted to grab all the Jobs from the database and have AmBlend return\nthem for you as objects, but you DON'T want to go through that process of executing\n1,000 individual queries... you have a few options:   Avoiding Lots of Mini-Queries - Option #0:  (Yes, I did just call this option zero. On purpose.)  The fact of the matter is, looping through 1,000 users and accessing information\nabout each, is not a typical usage example. If you're building an object oriented\nreporting system, I could see this being the case, but in 95% of situations you're\nprobably iterating over a small collection. If you are making some sort of users\nlist, chances are you'll be using a pagination setup, and so you probably only\nneed to loop over a few dozen users at a time.  If you're building say a Forum post system, again you're probably only iterating\nover a few dozen users, and using a pagination system again if things get too long.  In my experience exploring things such as string matching algorithms,\nwhen dealing with small data sets, a simple brute-force solution\nusually performs as well or better than a fancy more eloquent one due to the\noverhead cost of setting up fancy solutions.  So if you're concerned about performance, do a little testing. You might find\nthe simplest option may be the best option.   Avoiding Lots of Mini-Queries - Option #1:  You can just create a Jobs repository and ask for all the jobs. This will execute\na single query to fetch a collection of all the Jobs. The downside here is that\nunless you create a backwords reference from a Job to a User (our example from earlier on\nthis page didn't have one), you won't know what User(s) that Job is associated with.\nAlso worth noting, if you end up adding a backreference and using it, you might\nend up in the same individual queries situation.  But depending on what you're doing, just grabbing all the jobs this way and then\nmaybe doing some mapping between the collection of Jobs and the collection of Users\n(if necessary for the task) could be an option.   Avoiding Lots of Mini-Queries - Option #2:  If you don't need the full related object, but just a piece of information from it,\nyou can add a join to the Repository query. For instance, let's say you don't need\nthe full Job object, but just need a user's job title. You can do the following:  public function joinDemo($id)\n{\n    $this->db->where('users.id', $id)\n             ->select(['users.id', 'users.name', 'jobs.title as job_title'])\n             ->join('ref_users_jobs', [['users.id', '=', 'ref_users_jobs.user']])\n             ->join('jobs', [['ref_users_jobs.job', '=', 'jobs.id']]);\n    $user = $this->repo->findOne($this->db);  \n    echo $user->job_title;\n}  (NOTE: the above example is taken directly from the Cora demo project and Jobs are related\n    to Users via a relation table - which is different from our previous example on\n    this page where a Job ID was stored directly in the Users table)  Looking at the select() method above, in addition to grabbing the user's ID and\nname, we are also doing some joins and then grabbing the user's job title.\nSince \"job_title\" is NOT defined in the User class attributes definition, AmBlend\nwill pass it into the object as a property, but it will not do anything further.\nWhat this means is that if you alter the title and then tell AmBlend to save\nthis user, the job title will NOT get saved since it's not technically part of the class\ndefinition. The job title is just merely extra data you asked AmBlend to grab, which it did.  This can be useful if you just need some simple read-only data about a user though!\nAs you can see in the code snippet above we were able to\necho out the title. I'm sure if you're an experienced developer and reading this\nyou can see how this could be useful as long as you're careful about when/how you\nuse it. It's just important to keep in mind that any object properties not defined\nin the model_attributes array are ignored when an object is saved.  It's also worth noting here that a (probably more convenient) way of doing the same\nthing is to utilize a model's lifecycle hooks to run some custom queries when a\nmodel is fetched or saved! By doing so you can fetch the extra data anytime you\nwould normally fetch an instance of the model, and you can save the extra data\nwhenever you tell a repository to save it. See the LifeCycle Hooks section for\nmore information.   Avoiding Lots of Mini-Queries -  Option #3:  You can pass a custom built Gateway to a Repository that does whatever queries you\nwant and manipulates data in whatever way you want. AmBlend is great because it\nhandles the generic day-to-day fetching and persisting of objects for you, which is\nreally nice, BUT that doesn't mean you can't override its default behavior if you need\nto handle more complicated tasks. See the section below on how you can modify or\nreplace the default Gateway (the class in charge of fetching data from the persistence layer)\nwith a custom one of your own making.",
            "title": "Performance considerations of dynamic loading:"
        },
        {
            "location": "/documentation/v2/amblend/overview/#limiting-resource-creation",
            "text": "Another optimization made in AmBlend is statically declared data when possible.\nSpecifically, since most apps are likely created using a single\ndatabase, the default database adaptor is stored statically. What this means is\nthat each time you trigger something like Dynamic Loading on an object that uses\nthe app's default database, AmBlend isn't creating a new database object each time,\nbut rather using the statically stored version if it exists. This means less\nwork to get setup.  It's a small thing, but every little improvement helps in the long run.",
            "title": "Limiting Resource Creation"
        },
        {
            "location": "/documentation/v2/amblend/overview/#overriding-default-behavior",
            "text": "So one of the criticisms of the ActiveRecord pattern is it ties an object too\nclosely to a single table, and doesn't give the flexibility in how an object\nis fetched and saved that a developer might want. In most cases, this really isn't a problem (ActiveRecord\nis the most popular ORM pattern in use as of this writing to my knowledge after all).\nIn addition, as you've probably noticed if you've read this far down the page,\ngrabbing related objects from various different tables is an absolute BREEZE using\nAmBlend! However, there still may be situations that come up where a developer\nfeels the need for advanced models that are composed of direct data from multiple\ntables (\"direct data\" meaning numbers, strings, dates, etc).  The first thing I would caution a developer if they feel like they need to do this\nis to sleep on it, and re-examine what they're trying to accomplish. Does your\nobject REALLY need its data grabbed from multiple tables/sources? Can the data you\nwant to grab from a 2nd table be grabbed from a related object, rather than shoving it\ninto your current one? What about just doing a good old fashioned direct query\nusing Cora's database class? There are lifecycle hooks you can use when fetching\nor saving a model to run your custom query for fetching/saving this extra data.\nThe point I'm trying to make is that the option I'm going to share below,\nyou probably don't ever need to use... but I'll share it anyway because\nknowledge is power... or something like that.",
            "title": "Overriding Default Behavior"
        },
        {
            "location": "/documentation/v2/amblend/overview/#writing-your-own-gateway",
            "text": "Alright, I'm not actually going to go into too much depth on this, as if you're\na developer who feels the need to write your own Gateway for fetching/persisting\nan object, you probably are pretty competent in your knowledge and skills. Instead\nI'll just gloss over the high-level process of doing this in Cora to save you\ntime having to dig as much into the code.  The steps I would take are as follows:   Either extend Cora's Gateway class and override whatever method(s) you want,\n or copy+paste the existing class into a new file, delete the contents of the methods,\n and save it as whatever you want (something like \"UserGateway\" would make sense for\n a User class). Obviously don't forget to implement the methods with your own code.  Now that you have your fancy custom Gateway ready to go, you just need to pass\n it into a Repository in place of the default one included in Cora. The way to\n go about doing this is to NOT use the RepositoryFactory like we've been using in\n our examples, and instead just go through the simple process of initializing a\n Repository for yourself like so:   // Create the Factory and Gateway the repository will use.\n$factory = new Factory($class);\n$gateway = new UserGateway(...insert your parameters...);\n\n// Pass a gateway and factory to the repository.\n$repo    = new Repository($gateway, $factory);  As you can see, the process of replacing the gateway for an object repository is\ntrivial. The hard part is actually implementing the custom Gateway. Anyways, that's\nthe gist of it... happy coding!",
            "title": "Writing Your Own Gateway:"
        },
        {
            "location": "/documentation/v2/amblend/overview/#using-a-different-database-layer",
            "text": "AmBlend provides a lot of ways to customize the way it gets data. If you just want to do some \nsimple modifications to the query it runs to get the data that populates the models, then read \nthe \"Light\" classes section of this document. However, at the time of this writing there are \nlimitations to the flexibility of the query builder for AmBlend (check the documentation for \nCora's Database class for the latest features and limitations). If you feel like the query builder \nthat powers AmBlend is just not cutting it for what you want to do, you can bypass it to fetch \nmodels using another database library.  You'll still need to have Cora's Database class setup in order to dynamically fetch related data for \na model or to save it back to the persistence layer, but using another library to fetch a list of \nmodels is easy. In the example below we'll use PDO combined with Cora's model factory to fetch a list\nof models.  Example:  // Grab database object and Cora model factory\n$db = new PDO($dsn, $user, $pass, $options);\n$factory = new \\Cora\\Factory('User');\n\n// Create query and get results. Here we'll grab users who have \"Rick\" in their name. \n// The only required data is the ID, but fetch any columns from the table that will be used.\n$sth = $db->prepare(\"SELECT user_id, name FROM `users` WHERE `name` LIKE '%Rick%' \");\n$sth->execute();\n$results = $sth->fetchAll(\\PDO::FETCH_ASSOC);\n\n// Use the factory to create Cora models. Note: Use make() if expecting a single model.\n$users = $factory->makeGroup($results);\n\n// Showing that it worked\nforeach ($users as $user) {\n    echo \"<h1>$user->name</h1>\";\n}",
            "title": "Using a different database layer"
        },
        {
            "location": "/documentation/v2/amblend/overview/#testing",
            "text": "Alright, the first important thing to realize about AmBlend when considering testing\nis the Data-Mapper pattern it follows. Because the logic to persist a model is\nseparate from the model itself, you can do any of the following as suits your needs\nfor testing:   You can use a test Gateway to return fixed dummy data (see the \"writing your\n own gateway\" description above for more info). If you plan on leaving Dynamic Loading\n on, you'll also need to pass in to the Factory a database object you want used\n for testing (Dynamic Loading will use that DAO).  You can pass in a database object to a Test database connection in order to grab\n your testing data. This would look like so, where you need to pass the database object\n to both the Factory and Gateway:   $db = \\Cora\\Database::getDb('name_of_test_db_connection');\n$class = 'User';\n$factory = new Factory($class, $db);\n$gateway = new Gateway($db);\n$repo    = new Repository($gateway, $factory);   And last but not least, you can just create classes of whatever model you need\n by hand (not using the Repository/Gateway/Factory) and populate them with whatever\n you want. This works because Cora models are just normal everyday classes that you\n can use just like any other class. The one thing you'll want to be sure to do in this\n situation though is to turn off Dynamic Loading (see below).",
            "title": "Testing"
        },
        {
            "location": "/documentation/v2/amblend/overview/#turning-off-dynamic-loading",
            "text": "Let's quickly talk about Dynamic Loading and how to turn it off. You'll\nrecall from previous discussions that Dynamic Loading is a nifty little feature\nthat allows a model to request additional related objects from a Repository on-demand.\nIf you are expecting this behavior, and want the model to be able to request related\nmodels on-demand, you don't need to do anything and can just leave this feature on.\nHowever, if you want full control over the model, and would like to turn Dynamic Loading\noff, you just need to flip the following boolean on the model:  $user = $this->repo->find($id);\n$user->model_dynamicOff = true;",
            "title": "Turning off Dynamic Loading:"
        },
        {
            "location": "/documentation/v2/amblend/implementation/",
            "text": "Implementation Details\n\n\nObviously a developer can dig through the code to see exactly how things work, but as that's a more extreme measure most people probably\ndon't bother with (and honestly AmBlend is kinda complicated),\nhere's the general understanding of how AmBlend is implemented. We'll start by talking about the ActiveRecord and Data-Mapper\npatterns as those are an important segway into understanding the implementation of AmBlend.\n\n\nORM Basics\n\n\nAlright, so first off, Object Relational Mapping only makes sense to use when you are doing object oriented programming. If you aren't familiar with OO programming,\nI'd recommend you look into it, as it makes keeping your app well organized way easier. Assuming however that you have a basic understanding of what objects are,\nlet's discuss what an ORM does.\n\n\nSay you have a simple User object that looks like this:\n\n\nclass User\n{\n    public $name;\n    public $email;\n\n    public function __construct($name, $email)\n    {\n        $this->name = $name;\n        $this->email = $email;\n    }\n}\n\n\n\n\nBecause HTTP is a stateless protocol, each time someone makes a new request to your webapp, the application has to be reinitialized from scratch. This means any\ndata that's needed for your app to run must be fetched from various sources when setting up, and must be saved back to a permanent storage space after use (or\nelse the data will simply be thrown out and lost). Aside from data you only need to keep temporarily (Google 'php sessions tutorial'), anything you want\nto store permanently you'll probably be saving to a database. If you've worked with objects in the past outside of a framework, your solution to saving an object\nmight have been to add a \"save\" method that executes some SQL (structured query language):\n\n\nclass User\n{\n    public $id;\n    public $name;\n    public $email;\n\n    public function __construct($container, $name = null, $email = null)\n    {\n        $this->db = $container['db'];\n        $this->name = $name;\n        $this->email = $email;\n    }\n\n    public function save()\n    {\n        // If this user already exists in the DB, then just update it.\n        if (isset($this->id)) {\n            $this->db->query(\"UPDATE users SET name = :name, email = :email WHERE id = :user_id\");\n            $this->db->bind(':name', $this->name);\n            $this->db->bind(':email', $this->email);\n            $this->db->bind(':id', $this->id);\n            $this->db->execute()\n        }\n        // Otherwise create a new user record.\n        else {\n            $db->query(\"INSERT INTO users VALUES (NULL, :name, :email)\");\n            $this->db->bind(':name', $this->name);\n            $this->db->bind(':email', $this->email);\n            if ($this->db->execute()) {\n                $this->id = $db->lastInsertId();\n            }   \n        }\n    }\n}\n\n\n\n\nHere we've changed the code to allow us to pass in a container with a database adaptor, and we either insert or update\na user in the database when the save() method is called. Already you can see that this is quickly adding a lot of lines of code\nto our user model, and this is for a simple example which only contains a name and email. What's more, we haven't even added any code\nyet for fetching users from the database! We only added code to save a user.\n\n\nThe goal of an ORM like AmBlend is to free you from having to implement methods to save and grab the model data from the database.\nThis not only allows you to get rid of a lot of code clutter from your classes, it also saves you time by freeing you from having\nto implement error-prone, busy-work like writing all those SQL queries. Using AmBlend, your model and the controller code to create\na new user would look something like this:\n\n\nclass User extends \\Cora\\Model {\n\n    public $model_attributes = [\n        'id' => [],\n        'name' => [],\n        'email' => []\n    ];\n\n    public function __construct($name = null, $type = null)\n    {\n        $this->name = $name;\n        $this->type = $type;\n    }\n}\n\n\n///////////////////////////////////////////\n// Controller code to create a new user\n///////////////////////////////////////////\nclass Users extends \\MyApp {\n    public function register()\n    {\n        $repo = \\Cora\\RepositoryFactory::make('User');\n        $user = new User('testUser', 'testUser31@gmail.com');\n        $repo->save($user);\n    }\n}\n\n\n\n\nLet's quickly discuss ActiveRecord vs. Data-Mapper implementations\nwhich will then segway into how AmBlend is implemented in the next section.\n\n\nActiveRecord Pattern\n\n\nIn terms of functionality, ActiveRecord basically works just like the example from the above section where I showed what your code might look like if you implemented\nhandling database persistance on your own. The difference being that your model will extend from a base class that handles the database related logic for you.\nSo you won't have to write (typically) the SQL queries to save your objects, but the logic will still be a part of your model. ActiveRecord generally looks like this:\n\n\nclass User extends ActiveRecordModel\n{\n    public $name;\n    public $email;\n\n    public function __construct($name, $email)\n    {\n        $this->name = $name;\n        $this->email = $email;\n    }\n}\n\nclass ActiveRecordModel\n{\n    // Save record to database.\n    public function save()\n    {\n        // SAVING TO DB LOGIC\n    }\n\n    // Fetch record from database.\n    public function fetch($parameters)\n    {\n        // FETCHING FROM DB LOGIC\n    }\n}\n\n\n\n\nThere's a few different main complaints people have about the ActiveRecord pattern, and they're all kinda interrelated. Let's start\nby mentioning its lack of SRP adherance. SRP stands for Single Responsibility Principle, and basically means each class should only\nhandle a single part of a software's functionality. In doing so, you help your app stay logically sensible and readable, and make\ntesting easier. If software doesn't adhere to the SRP, then it runs the risk of becoming a confusing mess of spaghetti code that's hard\nto test, hard to understand, hard to upgrade and maintain, etc.\n\n\nThis of course leads into and overlaps the other two main complaints about AR, those being that it can be hard to test (depends on just how much \"magic\"\nhappens under the surface) and that there's generally a lack of separation between the domain (aka 'the app logic') and the storage medium (database).\nThe testing issues usually are the result of \"magic\" in the form of data being passively fetched from a database, which if you're trying to test\nyour app independent of the storage medium, can obviously be frustrating. Similarly, the lack of domain/database separation also stems from how closely tied\nto the database the ActiveRecord pattern is coupled by nature of how it works.\n\n\nWhy is important to keep the domain (app) logic decoupled from the database? Several reasons, the most important probably being:\n\n\n\n\n\n\nStorage mediums can and do change! You may be using the MySQL database today, but tomorrow you might need to use MongoDb, or save your data to\n XML files, or whatever. If you need to swap out the storage system your app uses, it shouldn't break all your code and force you to rewrite the app.\n\n\n\n\n\n\nYou want to be able to test and know that your code, your logic, works like you intend it to. Although most databases used nowadays aren't going\n to have a lot of obvious bugs, the fact of the matter remains that the storage layer is still powered by software, and as such, could have bugs\n in its implementation. That's why you need to be able to test YOUR code and know it's working, independent of any bugs related to the storage & retrieval of data.\n\n\n\n\n\n\nOn the flip side, ActiveRecord's strengths are that it's super easy to use and requires little to no setup (which are awesome positives!). For these reasons, it's an extremely popular ORM\npattern used by many frameworks.\n\n\nData-Mapper Pattern\n\n\nThe \nData-Mapper pattern\n utilizes a completely different approach from anything we've talked about so far.\nWhen using a data mapper, your models are COMPLETELY SEPARATED from the storage layer. They don't know how to save themselves, or fetch records, or anything else, because\nhandling persistence to a storage medium is outside their responsibility! Using this pattern, it's the Data Mapper's job to know how to save and fetch objects.\nIt 'maps' different kinds of data used in your app to some sort of storage point. This\nis obviously a complete 180 from the ActiveRecord pattern where objects have to know how to fetch and save from the storage layer themselves.\n\n\nAn ultra simplistic representation of the Data Mapper pattern might look like the below. Notice the User class doesn't extend anything, and a User object must\nbe passed in to the Data Mapper for it to save the user.\n\n\nclass User\n{\n    public $name;\n    public $email;\n\n    public function __construct($name, $email)\n    {\n        $this->name = $name;\n        $this->email = $email;\n    }\n}\n\nclass DataMapper\n{\n    // Save record to database.\n    public function save($objectToBeSaved)\n    {\n        // SAVING TO DB LOGIC\n    }\n\n    // Fetch record from database. Some options are passed in to determine what to fetch.\n    public function fetch($filterParameters)\n    {\n        // FETCHING FROM DB LOGIC\n    }\n}\n\n\n\n\nAs SRP purists will delight to tell you, the data mapper pattern adheres to the Single Responsibility Principle quite well. Furthermore, because an object\nis simply an object and has nothing magical or special about it, this makes testing way more straightforword. Need to save an object to a different storage medium?\nYou have the option of just passing the object to a different data mapper! Need to map parts of your object to one storage medium, and another part of the same\nobject to a different storage location? Using Data Mapper you can write the functionality to handle this without adding all sorts of unrelated logical clutter to your models!\nIn these and other ways, the Data Mapper pattern is much more flexible than ActiveRecord.\n\n\nThe downsides to this Data Mapper pattern are that it can be a little hard to understand and use, and it can require more setup time and thought because it doesn't necessarily have the 1-to-1 type of relationship with a database many AR implementations possess.\n\n\nUnderstanding AmBlend's Implementation\n\n\n\n    WARNING: The following two paragraphs are chock-full of\n    fancy terminology you may not understand. Don't freak out! Just keep reading\n    and all will be explained by the end of this section.\n\n\n\n\nAlright, with the understandings from the previous section in place, we're now\nready to talk about how AmBlend implements object relational mapping. In short,\nAmBlend uses a generalized Repository-Gateway-Factory design pattern where the\nGateway (which acts as the mapper between the domain and the persistence layer) asks\nthe model for various pieces of information about itself and the data it has ownership over.\nThe Gateway does this via the utility methods the Cora Model class provides. This\nseparation of concerns with the Gateway acting as the mapper between the persistence\nlayer and the domain, is in-line with using a Data Mapper and provides\nyou with all the benefits of that pattern.\n\n\nHowever, AmBlend, as discussed previously, is not just a pure Data-Mapper implementation,\nbut instead a blend of both ActiveRecord and Data-Mapper. The goal of AmBlend is\nto provide the ease of use ActiveRecord is famous for, but\nalso the separation of concerns and flexibility that Data Mapper excels at.\nThe way AmBlend accomplishes this is by using the repository-gateway-factory pattern\nAND by having its models inherit methods from Cora's\nModel class. This inheritance is obviously similar to ActiveRecord, however,\nunlike AR, those methods do not directly interact with the persistence\nlayer. Instead, they help other classes (particularly the Gateway) understand and\nuse the attributes defined in the model. They also provide the model with\nknowledge of the repository's existence, so the model can ask the repository to\nfetch data dynamically (\nClick Here\n\nto read about how that works).\n\n\nPHEWWW! Was that a mouthful or what? Hold on a sec, I think I need to cram a few\nmore buzzwords in those two paragraphs... Seriously though, now that's I've given\nthe highly compact description of how AmBlend works, let's slow down a bit and kinda\nwalk through it bit-by-bit.\n\n\nSo there's really two different logic flows that are important for understanding exactly\nwhat's going on, the regular logic flow of fetching objects from a repository,\nand the logic flow of fetching related objects dynamically. First let's look at\nwhat happens when we want to fetch from a repository.\n\n\n\n\nFetching from a Repository\n\n\n(typical Data-Mapper type implementation):\n\n\n\u00a0\n\n\n\nThe Code (an example of a User repository in use within a Controller):\n   \n\n\n// Repository Setup (if not using RepositoryFactory)\n$db = \\Cora\\Database::getDb('name_of_db_connection');\n$factory = new Factory('User');\n$gateway = new Gateway($db);\n$repo    = new Repository($gateway, $factory);\n\n// Grab a user from repository. This triggers the logic flow seen in the diagram below.\n$user = $repo->findBy('email', 'Bob@fakeEmail.com');\n\n\n\n\n\u00a0\n\n\n\nThe Logic Flow Chart - Diagram A:\n \n\n\n\u00a0\n\n\n\n\n\u00a0\n\n\n\nAs can be seen, there's nothing too fancy here. This is a normal looking Repository\npattern, where the Gateway is acting as our Data Mapper.\nIf you aren't familiar with it, here's a description of what the objects\nresponsibilities are:\n\n\n\n\nThe Repository:\n The Repository is the access point that parts of your application\ninteract with when they need to get objects out of, or save objects to, the persistence layer (usually a database).\nIf you create a \"User\" repository, it handles grabbing and saving Users, if you create an \"Orders\"\nrepository, it handles grabbing and saving Orders, and so forth.\n\n\nThe Gateway:\n The Gateway is the class who's responsibility it is to interact directly\nwith the persistence layer and grab data from whatever database, or text file, or API,\nit needs to interact with in order to get you the raw data you need. It also interacts\nwith the storage mediums to save objects when an object needs to be persisted.\n\n\nThe Factory:\n The Factory is a class that makes objects. If you have a \"User\" factory,\nthen it's going to create User objects for you. In AmBlend, the Factory is given\nthe raw data (an array) from the Gateway and returns back objects.\n\n\n\n\n\n\nNext let's look at the logic flow of fetching related objects dynamically. On the\nsurface this might seem like a small change (judging from the diagram), but really\nit's much different as in this scenario a model itself is the one creating and\nusing a Repository (via the methods built into its Cora Model class parent).\n\n\n\n\nDynamically Fetching a Related Object:\n\n\n(still Data-Mapping, but incorporates ActiveRecord type use of Cora Model class)\n\n\n\u00a0\n\n\n\nThe Code (accessing a related object to a User):\n   \n\n\n// Repository Setup (this time we're using RepositoryFactory)\n$repo = \\Cora\\RepositoryFactory::make(User::class);\n\n// Grab a user from repository. This triggers the logic flow seen in the diagram A.\n$user = $repo->findBy('email', 'Bob@fakeEmail.com');\n\n// Access a related object (Job is a class). This triggers the logic in diagram B below.\necho $user->job->title;\n\n\n\n\n\u00a0\n\n\n\nThe Logic Flow Chart - Diagram B:\n \n\n\n\u00a0\n\n\n\n\n\u00a0\n\n\n\nThe only difference between diagram A and diagram B above is how the repository\ngets invoked (steps 0 through 1). However, this is actually a pretty major change\nin the logic flow! When normally fetching from a repository, there's no interaction\nwith a model, a controller asks a repository for one or more objects and the\nrepository returns them. When a controller already has a Cora model and needs\nto grab a related object, that's when the logic built into the Cora model class\nkicks in to facilitate. The model looks at its own definition and any data passed\nin when it was created, and from those determines how to create a Repository to\ngrab the needed related object. This is how AmBlend implements ActiveRecord like\nsimplicity in fetching objects, while still maintaining separation of concerns.\nThe model doesn't directly interact with the persistence layer (knowing that's not\nits responsibility), but rather the Cora Model class gives it the necessary knowledge\non how to use the Repository system. And then, just to make sure testing doesn't get\ndifficult, options are included to disable Dynamic Fetching, or to pass in a\ndifferent database adaptor to override any defaults (I.E. force dynamic fetching to\nuse a test database). See \nHere\n\nfor more information on testing.\n\n\n\n\nOk, that's it! Hopefully you have a high level understanding of how AmBlend blends\ntogether the best of Data-Mapper and ActiveRecord into a new best-of-both worlds system.",
            "title": "Implementation"
        },
        {
            "location": "/documentation/v2/amblend/implementation/#implementation-details",
            "text": "Obviously a developer can dig through the code to see exactly how things work, but as that's a more extreme measure most people probably\ndon't bother with (and honestly AmBlend is kinda complicated),\nhere's the general understanding of how AmBlend is implemented. We'll start by talking about the ActiveRecord and Data-Mapper\npatterns as those are an important segway into understanding the implementation of AmBlend.",
            "title": "Implementation Details"
        },
        {
            "location": "/documentation/v2/amblend/implementation/#orm-basics",
            "text": "Alright, so first off, Object Relational Mapping only makes sense to use when you are doing object oriented programming. If you aren't familiar with OO programming,\nI'd recommend you look into it, as it makes keeping your app well organized way easier. Assuming however that you have a basic understanding of what objects are,\nlet's discuss what an ORM does.  Say you have a simple User object that looks like this:  class User\n{\n    public $name;\n    public $email;\n\n    public function __construct($name, $email)\n    {\n        $this->name = $name;\n        $this->email = $email;\n    }\n}  Because HTTP is a stateless protocol, each time someone makes a new request to your webapp, the application has to be reinitialized from scratch. This means any\ndata that's needed for your app to run must be fetched from various sources when setting up, and must be saved back to a permanent storage space after use (or\nelse the data will simply be thrown out and lost). Aside from data you only need to keep temporarily (Google 'php sessions tutorial'), anything you want\nto store permanently you'll probably be saving to a database. If you've worked with objects in the past outside of a framework, your solution to saving an object\nmight have been to add a \"save\" method that executes some SQL (structured query language):  class User\n{\n    public $id;\n    public $name;\n    public $email;\n\n    public function __construct($container, $name = null, $email = null)\n    {\n        $this->db = $container['db'];\n        $this->name = $name;\n        $this->email = $email;\n    }\n\n    public function save()\n    {\n        // If this user already exists in the DB, then just update it.\n        if (isset($this->id)) {\n            $this->db->query(\"UPDATE users SET name = :name, email = :email WHERE id = :user_id\");\n            $this->db->bind(':name', $this->name);\n            $this->db->bind(':email', $this->email);\n            $this->db->bind(':id', $this->id);\n            $this->db->execute()\n        }\n        // Otherwise create a new user record.\n        else {\n            $db->query(\"INSERT INTO users VALUES (NULL, :name, :email)\");\n            $this->db->bind(':name', $this->name);\n            $this->db->bind(':email', $this->email);\n            if ($this->db->execute()) {\n                $this->id = $db->lastInsertId();\n            }   \n        }\n    }\n}  Here we've changed the code to allow us to pass in a container with a database adaptor, and we either insert or update\na user in the database when the save() method is called. Already you can see that this is quickly adding a lot of lines of code\nto our user model, and this is for a simple example which only contains a name and email. What's more, we haven't even added any code\nyet for fetching users from the database! We only added code to save a user.  The goal of an ORM like AmBlend is to free you from having to implement methods to save and grab the model data from the database.\nThis not only allows you to get rid of a lot of code clutter from your classes, it also saves you time by freeing you from having\nto implement error-prone, busy-work like writing all those SQL queries. Using AmBlend, your model and the controller code to create\na new user would look something like this:  class User extends \\Cora\\Model {\n\n    public $model_attributes = [\n        'id' => [],\n        'name' => [],\n        'email' => []\n    ];\n\n    public function __construct($name = null, $type = null)\n    {\n        $this->name = $name;\n        $this->type = $type;\n    }\n}\n\n\n///////////////////////////////////////////\n// Controller code to create a new user\n///////////////////////////////////////////\nclass Users extends \\MyApp {\n    public function register()\n    {\n        $repo = \\Cora\\RepositoryFactory::make('User');\n        $user = new User('testUser', 'testUser31@gmail.com');\n        $repo->save($user);\n    }\n}  Let's quickly discuss ActiveRecord vs. Data-Mapper implementations\nwhich will then segway into how AmBlend is implemented in the next section.",
            "title": "ORM Basics"
        },
        {
            "location": "/documentation/v2/amblend/implementation/#activerecord-pattern",
            "text": "In terms of functionality, ActiveRecord basically works just like the example from the above section where I showed what your code might look like if you implemented\nhandling database persistance on your own. The difference being that your model will extend from a base class that handles the database related logic for you.\nSo you won't have to write (typically) the SQL queries to save your objects, but the logic will still be a part of your model. ActiveRecord generally looks like this:  class User extends ActiveRecordModel\n{\n    public $name;\n    public $email;\n\n    public function __construct($name, $email)\n    {\n        $this->name = $name;\n        $this->email = $email;\n    }\n}\n\nclass ActiveRecordModel\n{\n    // Save record to database.\n    public function save()\n    {\n        // SAVING TO DB LOGIC\n    }\n\n    // Fetch record from database.\n    public function fetch($parameters)\n    {\n        // FETCHING FROM DB LOGIC\n    }\n}  There's a few different main complaints people have about the ActiveRecord pattern, and they're all kinda interrelated. Let's start\nby mentioning its lack of SRP adherance. SRP stands for Single Responsibility Principle, and basically means each class should only\nhandle a single part of a software's functionality. In doing so, you help your app stay logically sensible and readable, and make\ntesting easier. If software doesn't adhere to the SRP, then it runs the risk of becoming a confusing mess of spaghetti code that's hard\nto test, hard to understand, hard to upgrade and maintain, etc.  This of course leads into and overlaps the other two main complaints about AR, those being that it can be hard to test (depends on just how much \"magic\"\nhappens under the surface) and that there's generally a lack of separation between the domain (aka 'the app logic') and the storage medium (database).\nThe testing issues usually are the result of \"magic\" in the form of data being passively fetched from a database, which if you're trying to test\nyour app independent of the storage medium, can obviously be frustrating. Similarly, the lack of domain/database separation also stems from how closely tied\nto the database the ActiveRecord pattern is coupled by nature of how it works.  Why is important to keep the domain (app) logic decoupled from the database? Several reasons, the most important probably being:    Storage mediums can and do change! You may be using the MySQL database today, but tomorrow you might need to use MongoDb, or save your data to\n XML files, or whatever. If you need to swap out the storage system your app uses, it shouldn't break all your code and force you to rewrite the app.    You want to be able to test and know that your code, your logic, works like you intend it to. Although most databases used nowadays aren't going\n to have a lot of obvious bugs, the fact of the matter remains that the storage layer is still powered by software, and as such, could have bugs\n in its implementation. That's why you need to be able to test YOUR code and know it's working, independent of any bugs related to the storage & retrieval of data.    On the flip side, ActiveRecord's strengths are that it's super easy to use and requires little to no setup (which are awesome positives!). For these reasons, it's an extremely popular ORM\npattern used by many frameworks.",
            "title": "ActiveRecord Pattern"
        },
        {
            "location": "/documentation/v2/amblend/implementation/#data-mapper-pattern",
            "text": "The  Data-Mapper pattern  utilizes a completely different approach from anything we've talked about so far.\nWhen using a data mapper, your models are COMPLETELY SEPARATED from the storage layer. They don't know how to save themselves, or fetch records, or anything else, because\nhandling persistence to a storage medium is outside their responsibility! Using this pattern, it's the Data Mapper's job to know how to save and fetch objects.\nIt 'maps' different kinds of data used in your app to some sort of storage point. This\nis obviously a complete 180 from the ActiveRecord pattern where objects have to know how to fetch and save from the storage layer themselves.  An ultra simplistic representation of the Data Mapper pattern might look like the below. Notice the User class doesn't extend anything, and a User object must\nbe passed in to the Data Mapper for it to save the user.  class User\n{\n    public $name;\n    public $email;\n\n    public function __construct($name, $email)\n    {\n        $this->name = $name;\n        $this->email = $email;\n    }\n}\n\nclass DataMapper\n{\n    // Save record to database.\n    public function save($objectToBeSaved)\n    {\n        // SAVING TO DB LOGIC\n    }\n\n    // Fetch record from database. Some options are passed in to determine what to fetch.\n    public function fetch($filterParameters)\n    {\n        // FETCHING FROM DB LOGIC\n    }\n}  As SRP purists will delight to tell you, the data mapper pattern adheres to the Single Responsibility Principle quite well. Furthermore, because an object\nis simply an object and has nothing magical or special about it, this makes testing way more straightforword. Need to save an object to a different storage medium?\nYou have the option of just passing the object to a different data mapper! Need to map parts of your object to one storage medium, and another part of the same\nobject to a different storage location? Using Data Mapper you can write the functionality to handle this without adding all sorts of unrelated logical clutter to your models!\nIn these and other ways, the Data Mapper pattern is much more flexible than ActiveRecord.  The downsides to this Data Mapper pattern are that it can be a little hard to understand and use, and it can require more setup time and thought because it doesn't necessarily have the 1-to-1 type of relationship with a database many AR implementations possess.",
            "title": "Data-Mapper Pattern"
        },
        {
            "location": "/documentation/v2/amblend/implementation/#understanding-amblends-implementation",
            "text": "WARNING: The following two paragraphs are chock-full of\n    fancy terminology you may not understand. Don't freak out! Just keep reading\n    and all will be explained by the end of this section.  Alright, with the understandings from the previous section in place, we're now\nready to talk about how AmBlend implements object relational mapping. In short,\nAmBlend uses a generalized Repository-Gateway-Factory design pattern where the\nGateway (which acts as the mapper between the domain and the persistence layer) asks\nthe model for various pieces of information about itself and the data it has ownership over.\nThe Gateway does this via the utility methods the Cora Model class provides. This\nseparation of concerns with the Gateway acting as the mapper between the persistence\nlayer and the domain, is in-line with using a Data Mapper and provides\nyou with all the benefits of that pattern.  However, AmBlend, as discussed previously, is not just a pure Data-Mapper implementation,\nbut instead a blend of both ActiveRecord and Data-Mapper. The goal of AmBlend is\nto provide the ease of use ActiveRecord is famous for, but\nalso the separation of concerns and flexibility that Data Mapper excels at.\nThe way AmBlend accomplishes this is by using the repository-gateway-factory pattern\nAND by having its models inherit methods from Cora's\nModel class. This inheritance is obviously similar to ActiveRecord, however,\nunlike AR, those methods do not directly interact with the persistence\nlayer. Instead, they help other classes (particularly the Gateway) understand and\nuse the attributes defined in the model. They also provide the model with\nknowledge of the repository's existence, so the model can ask the repository to\nfetch data dynamically ( Click Here \nto read about how that works).  PHEWWW! Was that a mouthful or what? Hold on a sec, I think I need to cram a few\nmore buzzwords in those two paragraphs... Seriously though, now that's I've given\nthe highly compact description of how AmBlend works, let's slow down a bit and kinda\nwalk through it bit-by-bit.  So there's really two different logic flows that are important for understanding exactly\nwhat's going on, the regular logic flow of fetching objects from a repository,\nand the logic flow of fetching related objects dynamically. First let's look at\nwhat happens when we want to fetch from a repository.",
            "title": "Understanding AmBlend's Implementation"
        },
        {
            "location": "/documentation/v2/amblend/implementation/#fetching-from-a-repository",
            "text": "(typical Data-Mapper type implementation):  \u00a0  The Code (an example of a User repository in use within a Controller):      // Repository Setup (if not using RepositoryFactory)\n$db = \\Cora\\Database::getDb('name_of_db_connection');\n$factory = new Factory('User');\n$gateway = new Gateway($db);\n$repo    = new Repository($gateway, $factory);\n\n// Grab a user from repository. This triggers the logic flow seen in the diagram below.\n$user = $repo->findBy('email', 'Bob@fakeEmail.com');  \u00a0  The Logic Flow Chart - Diagram A:    \u00a0   \u00a0  As can be seen, there's nothing too fancy here. This is a normal looking Repository\npattern, where the Gateway is acting as our Data Mapper.\nIf you aren't familiar with it, here's a description of what the objects\nresponsibilities are:   The Repository:  The Repository is the access point that parts of your application\ninteract with when they need to get objects out of, or save objects to, the persistence layer (usually a database).\nIf you create a \"User\" repository, it handles grabbing and saving Users, if you create an \"Orders\"\nrepository, it handles grabbing and saving Orders, and so forth.  The Gateway:  The Gateway is the class who's responsibility it is to interact directly\nwith the persistence layer and grab data from whatever database, or text file, or API,\nit needs to interact with in order to get you the raw data you need. It also interacts\nwith the storage mediums to save objects when an object needs to be persisted.  The Factory:  The Factory is a class that makes objects. If you have a \"User\" factory,\nthen it's going to create User objects for you. In AmBlend, the Factory is given\nthe raw data (an array) from the Gateway and returns back objects.    Next let's look at the logic flow of fetching related objects dynamically. On the\nsurface this might seem like a small change (judging from the diagram), but really\nit's much different as in this scenario a model itself is the one creating and\nusing a Repository (via the methods built into its Cora Model class parent).",
            "title": "Fetching from a Repository"
        },
        {
            "location": "/documentation/v2/amblend/implementation/#dynamically-fetching-a-related-object",
            "text": "(still Data-Mapping, but incorporates ActiveRecord type use of Cora Model class)  \u00a0  The Code (accessing a related object to a User):      // Repository Setup (this time we're using RepositoryFactory)\n$repo = \\Cora\\RepositoryFactory::make(User::class);\n\n// Grab a user from repository. This triggers the logic flow seen in the diagram A.\n$user = $repo->findBy('email', 'Bob@fakeEmail.com');\n\n// Access a related object (Job is a class). This triggers the logic in diagram B below.\necho $user->job->title;  \u00a0  The Logic Flow Chart - Diagram B:    \u00a0   \u00a0  The only difference between diagram A and diagram B above is how the repository\ngets invoked (steps 0 through 1). However, this is actually a pretty major change\nin the logic flow! When normally fetching from a repository, there's no interaction\nwith a model, a controller asks a repository for one or more objects and the\nrepository returns them. When a controller already has a Cora model and needs\nto grab a related object, that's when the logic built into the Cora model class\nkicks in to facilitate. The model looks at its own definition and any data passed\nin when it was created, and from those determines how to create a Repository to\ngrab the needed related object. This is how AmBlend implements ActiveRecord like\nsimplicity in fetching objects, while still maintaining separation of concerns.\nThe model doesn't directly interact with the persistence layer (knowing that's not\nits responsibility), but rather the Cora Model class gives it the necessary knowledge\non how to use the Repository system. And then, just to make sure testing doesn't get\ndifficult, options are included to disable Dynamic Fetching, or to pass in a\ndifferent database adaptor to override any defaults (I.E. force dynamic fetching to\nuse a test database). See  Here \nfor more information on testing.   Ok, that's it! Hopefully you have a high level understanding of how AmBlend blends\ntogether the best of Data-Mapper and ActiveRecord into a new best-of-both worlds system.",
            "title": "Dynamically Fetching a Related Object:"
        },
        {
            "location": "/documentation/v2/amblend/repository/",
            "text": "Repository Class\n\n\nThe purpose of the Repository is to separate the logic that retrieves data from\nthe persistence layer from the models themselves and the business logic that\nacts on those models. The Repository acts as a sort of controller that utilizes\na Gateway for direct access to data and a Factory for creating objects.\n\n\nCreating a Repository\n\n\nThere's a few different ways to get a Repository depending on the situation. The\nmost general purpose and easiest solution is usually to utilize the RepositoryFactory\nclass. However, for situations where you need to utilize a custom Gateway or Factory,\ncreating a Repository without using the factory may be desired. Finally, if you\nalready have an instance of a model, you can ask a model to give you a repository\nmatching its type.\n\n\nUsing RepositoryFactory\n\n\nFor simple class namespaces, it's easiest to just type the name in like so:\n\n\nclass MyController extends \\MyApp {\n    public function demo()\n    {\n        $repo = \\Cora\\RepositoryFactory::make('User');\n        $user = $repo->find($id);\n    }\n}\n\n\n\n\nFor more advanced namespaces, you can take advantage of Use statements by utilizing\nthe \"class\" keyword:\n\n\nuse \\System\\Blog\\Bug\\Task\\Note;\nclass MyController extends \\MyApp {\n    public function demo()\n    {\n        $repo = \\Cora\\RepositoryFactory::make(Note::class);\n        $user = $repo->find($id);\n\n        // OR you can still do\n\n        $repo = \\Cora\\RepositoryFactory::make('\\\\System\\\\Blog\\\\Bug\\\\Task\\\\Note');\n        $user = $repo->find($id);\n    }\n}\n\n\n\n\nRepositoryFactory Options\n\n\nWhile we're on the topic of using the RepositoryFactory, now is a good time to look\nat its make() method definition and the options it gives you.\n\n\nmake($class, $idField = false, $table = false, $freshAdaptor = false, $db = false)\n\n\n\n\n\n\nThe $class parameter is the object type you'll be using the repository for.\n\n\nThe optional $idField parameter is for setting the unique ID field which will be\nused to fetch objects from a database. You'll most likely want to set this if your\nID column is something other than 'id'.\n\n\nThe optional $table parameter is for overriding the defaults as defined in a model. If\nthis parameter is defined, it will be passed to the Gateway as the table/collection\nto fetch objects from.\n\n\nThe optional $freshAdaptor is a setting you'll most likely not ever need to use. See my explanation\nafter this list for more details.\n\n\nThe optional $db let's you pass in a custom Cora database connection for the Gateway to use.\nThis can be used to force the Repository and Dynamic Loading to use a connection to\na Test database for testing purposes.\n\n\n\n\nExplanation of $freshAdaptor:\n\n\n\n    WARNING: Please don't confuse yourself by reading this section unless you are\n    an advanced developer interested in writing your own Gateway implementations.\n\n\n\n\nAmBlend is\nbuilt using Cora's Database class, and since most apps probably only use a single\ndatabase, part of the database setup process is setting a \"default connection\".\nWhen fetching models, if no particular connection is specified in the model definition, AmBlend\nwill default to using the default connection. In order to make this typical use case more\nefficient, the Database class stores an instance of the default DB as a static data member.\nWhen a database operation involving the default database is performed, this statically stored\ndefault will be used rather than creating a new instance each time.\nIn most cases this is great! However, because Cora's Database\nclass can only handle building 1 query at a time, if you end up in a situation where\nin the middle of building a query, you need to pause and perform another query on\nthe default connection, this can cause problems. In this scenario, what you need is\na fresh version of the adaptor and not the statically stored one. Setting $freshAdaptor\nto true gives you a new database class.\n\n\nI realize that explanation is a little hard to follow, but the reason for the $freshAdaptor\nparameter's existence has to do with the inner optimization workings of Cora, and\nis inherently complicated for that reason. The good news is that unless you start building\nyour own custom gateway classes, I can't really think of a reason you'd need to use or\nunderstand it.\n\n\nThe backstory on this feature is that Cora's Gateway walks through a loop of a model's\nattributes and builds up the query to save the model to the database. However, when\na related object is encountered, it recursively calls the Save() method on that related\nobject at the time it encounters it. Because the default adaptor was already being used to build\nup a query, that recursive call to the Save() method on the related object was causing conflicts if the\nrelated object also used the default adaptor (due to the one query at a time restriction\non a Cora Database class and the default database being stored statically).\n\n\nUsing Custom Setup\n\n\nFor situations where you want to swap out components of the repository system\nwith your own custom classes, you'll need to bypass the RepositoryFactory and just\ndo the setup yourself. The general format is as follows:\n\n\n$db = \\Cora\\Database::getDb('name_of_db_connection_to_use');\n$class = 'User';\n$factory = new Factory($class, $db);\n$gateway = new Gateway($db);\n$repo    = new Repository($gateway, $factory);\n\n\n\n\nUsing Model Method\n\n\nIf you're in a situation where you created an instance of a Cora Model class,\nand now you need a repository for it to persist it or whatever, you can take advantage\nof Cora Model's knowledge on how to create repositories for themselves:\n\n\n$user = new \\User('Josiah', 'SuperAdmin');\n$user->location = new Location('JoesHouse', 'Portland');\n$user->job      = new Job('Librarian', 'Keeper of knowledge!');\n$repo = $user->getRepository();\n$repo->save($user);\n\n\n\n\nUsing a Repository\n\n\nfind() Method\n\n\nPurpose:\n \n\nThe find() method is for grabbing a single object from a database based on the\nobject's unique ID.\n\n\nFormat:\n\n\nfind(id)\n\n\n\n\nExamples:\n  \n\n\n// Create Repository\n$repo = \\Cora\\RepositoryFactory::make('User');\n\n// Grab a user Object\n$user = $repo->find($id);\n\n\n\n\nfindOne() Method\n\n\nPurpose:\n \n\nThe findOne() method is for grabbing a single object from a database based on\nthe passed in query parameters.\n\n\nFormat:\n\n\nfindOne(coraDbQuery)\n\n\n\n\nExamples:\n  \n\n\n// Create Repository\n$repo = \\Cora\\RepositoryFactory::make('User');\n\n// Grab an instance of database adaptor for this model.\n$db = $repo->getDb();\n\n// Define some db query parameters.\n$db->where('name', 'testUser');\n\n// Grab a user Object matching query.\n$user = $repo->findOne($db);\n\n\n\n\nfindAll() Method\n\n\nPurpose:\n \n\nThe findAll() method is for grabbing all objects from a database collection.\nThe results can be limited by optionally passing along query parameters.\n\n\nFormat:\n\n\nfindAll([coraDbQuery])\n\n\n\n\nExamples:\n  \n\n\n// Create Repository\n$repo = \\Cora\\RepositoryFactory::make('User');\n\n// Fetch ALL users.\n$allUsers = $repo->findAll();\n\n// Grab an instance of database adaptor for this model.\n$db = $repo->getDb();\n\n// Define some db query parameters.\n$db->where('type', 'Admin');\n\n// Grab a subset of users. In this case all users who are Admins.\n$admins = $repo->findAll($db);\n\n\n\n\nfindBy() Method\n\n\nPurpose:\n \n\nThe findBy() method is for grabbing a set of objects based on a simple restriction.\nThis has the same basic functionality as findAll(), but is simpler to use with\nthe tradeoff of being less flexible.\n\n\nFormat:\n\n\n// options = array(['order_by' => 'desc|asc'] [, 'limit' => number [, 'offset' => number]])\nfindBy(property, value [, options])\n\n\n\n\nBecause the \"options\" is kinda hard to read above let me just verbally describe it.\nYou can pass in an associative array with up to 3 keys, those being \"order_by\",\n\"limit\", and \"offset\". Order_by should be either \"desc\" or \"asc\", and limit and offset\nshould be numbers. Offset doesn't do anything unless you also pass in a Limit.\n\n\nExamples:\n  \n\n\n// Create Repository\n$repo = \\Cora\\RepositoryFactory::make('User');\n\n// Grab users who are Admins.\n$admins = $repo->findBy('type', 'Admin');\n\n// Grab users who are Moderators, but only return the first 10.\n$mods = $repo->findBy('type', 'Moderator', ['limit' => 10]);\n\n// Grab the next 10 Moderators\n$moreMods = $repo->findBy('type', 'Moderator', ['limit' => 10, 'offset' => 10]);\n\n\n\n\ndelete() Method\n\n\nPurpose:\n \n\nThe delete() method is for deleting a single object from a database based on the\nobject's unique ID. It will call the object's own \"delete\" method for cleanup\nbefore removing the record from the database.\n\n\nFormat:\n\n\ndelete(id)\n\n\n\n\nExamples:\n  \n\n\n// Create Repository\n$repo = \\Cora\\RepositoryFactory::make('User');\n\n// Delete a user.\n$repo->delete($id);\n\n\n\n\nsave() Method\n\n\nPurpose:\n \n\nThe save() method is for persisting one or more objects. Usually this means saving\nrecords in a database. If the object(s) already exists in the database, then\nany changes will be updated. If the object(s) does not exist, then it will be\ninserted.\n\n\nFormat:\n\n\nsave(Cora_Model | ResultSet_of_Cora_Models [, table] [, id_name])\n\n\n\n\nThe Table and Id_name optional parameters are for overriding default model behavior\nif necessary. The refer to the table/collection the object should be saved to,\nand the unique identifying column for the object. You probably don't need to use\nthese! Check out the RepositoryFactory options near the top of this page for a\nway you can set these options for all operations on a Repository.\n\n\nExamples:\n  \n\n\n// Create Repository\n$repo = \\Cora\\RepositoryFactory::make('User');\n\n/////////////////////////////////////////////\n// Modify a single existing user.\n/////////////////////////////////////////////\n\n// Grab a user Object\n$user = $repo->find($id);\n\n// Change something\n$user->email = 'BobsNewEmail@fakeEmail.com';\n\n// Save the changes.\n$repo->save($user);\n\n\n\n////////////////////////////////////////////\n// Save a completely new user.\n////////////////////////////////////////////\n\n// Create a user object.\n$user = new User('Bob', 'Bob@fakeEmail.com');\n\n// Save the user to the database.\n$repo->save($user);\n\n\n\n////////////////////////////////////////////\n// Modify a collection of users.\n// We'll pretend we're crediting our 'premium'\n// users some amount to their account.\n////////////////////////////////////////////\n\n// Grab a collection of users.\n$users = $repo->findBy('type', 'Premium');\n\n// Change something\nforeach ($users as $user) {\n    $user->accountCredit += 100;\n}\n\n// Save the changes.\n$repo->save($users);\n\n\n\n////////////////////////////////////////////\n// Assign a collection of objects to a user.\n////////////////////////////////////////////\n\n// Grab a user Object\n$user = $repo->find($id);\n\n// Assign a collection of articles to the user\n$user->articles =   new \\Cora\\ResultSet([\n                        new Article('How to Fly a Plane'),\n                        new Article('How to Make Money')\n                    ]);\n\n// Save the changes.\n$repo->save($user);\n\n\n\n////////////////////////////////////////////\n// Add to an existing collection of objects\n////////////////////////////////////////////\n\n// Grab a user Object\n$user = $repo->find($id);\n\n// Add a new article to the collection of articles this user has.\n$user->articles->add(new Article('How to Make Money Vol2'));\n\n// Save the changes.\n$repo->save($user);",
            "title": "Repository"
        },
        {
            "location": "/documentation/v2/amblend/repository/#repository-class",
            "text": "The purpose of the Repository is to separate the logic that retrieves data from\nthe persistence layer from the models themselves and the business logic that\nacts on those models. The Repository acts as a sort of controller that utilizes\na Gateway for direct access to data and a Factory for creating objects.",
            "title": "Repository Class"
        },
        {
            "location": "/documentation/v2/amblend/repository/#creating-a-repository",
            "text": "There's a few different ways to get a Repository depending on the situation. The\nmost general purpose and easiest solution is usually to utilize the RepositoryFactory\nclass. However, for situations where you need to utilize a custom Gateway or Factory,\ncreating a Repository without using the factory may be desired. Finally, if you\nalready have an instance of a model, you can ask a model to give you a repository\nmatching its type.",
            "title": "Creating a Repository"
        },
        {
            "location": "/documentation/v2/amblend/repository/#using-repositoryfactory",
            "text": "For simple class namespaces, it's easiest to just type the name in like so:  class MyController extends \\MyApp {\n    public function demo()\n    {\n        $repo = \\Cora\\RepositoryFactory::make('User');\n        $user = $repo->find($id);\n    }\n}  For more advanced namespaces, you can take advantage of Use statements by utilizing\nthe \"class\" keyword:  use \\System\\Blog\\Bug\\Task\\Note;\nclass MyController extends \\MyApp {\n    public function demo()\n    {\n        $repo = \\Cora\\RepositoryFactory::make(Note::class);\n        $user = $repo->find($id);\n\n        // OR you can still do\n\n        $repo = \\Cora\\RepositoryFactory::make('\\\\System\\\\Blog\\\\Bug\\\\Task\\\\Note');\n        $user = $repo->find($id);\n    }\n}",
            "title": "Using RepositoryFactory"
        },
        {
            "location": "/documentation/v2/amblend/repository/#repositoryfactory-options",
            "text": "While we're on the topic of using the RepositoryFactory, now is a good time to look\nat its make() method definition and the options it gives you.  make($class, $idField = false, $table = false, $freshAdaptor = false, $db = false)   The $class parameter is the object type you'll be using the repository for.  The optional $idField parameter is for setting the unique ID field which will be\nused to fetch objects from a database. You'll most likely want to set this if your\nID column is something other than 'id'.  The optional $table parameter is for overriding the defaults as defined in a model. If\nthis parameter is defined, it will be passed to the Gateway as the table/collection\nto fetch objects from.  The optional $freshAdaptor is a setting you'll most likely not ever need to use. See my explanation\nafter this list for more details.  The optional $db let's you pass in a custom Cora database connection for the Gateway to use.\nThis can be used to force the Repository and Dynamic Loading to use a connection to\na Test database for testing purposes.   Explanation of $freshAdaptor:  \n    WARNING: Please don't confuse yourself by reading this section unless you are\n    an advanced developer interested in writing your own Gateway implementations.  AmBlend is\nbuilt using Cora's Database class, and since most apps probably only use a single\ndatabase, part of the database setup process is setting a \"default connection\".\nWhen fetching models, if no particular connection is specified in the model definition, AmBlend\nwill default to using the default connection. In order to make this typical use case more\nefficient, the Database class stores an instance of the default DB as a static data member.\nWhen a database operation involving the default database is performed, this statically stored\ndefault will be used rather than creating a new instance each time.\nIn most cases this is great! However, because Cora's Database\nclass can only handle building 1 query at a time, if you end up in a situation where\nin the middle of building a query, you need to pause and perform another query on\nthe default connection, this can cause problems. In this scenario, what you need is\na fresh version of the adaptor and not the statically stored one. Setting $freshAdaptor\nto true gives you a new database class.  I realize that explanation is a little hard to follow, but the reason for the $freshAdaptor\nparameter's existence has to do with the inner optimization workings of Cora, and\nis inherently complicated for that reason. The good news is that unless you start building\nyour own custom gateway classes, I can't really think of a reason you'd need to use or\nunderstand it.  The backstory on this feature is that Cora's Gateway walks through a loop of a model's\nattributes and builds up the query to save the model to the database. However, when\na related object is encountered, it recursively calls the Save() method on that related\nobject at the time it encounters it. Because the default adaptor was already being used to build\nup a query, that recursive call to the Save() method on the related object was causing conflicts if the\nrelated object also used the default adaptor (due to the one query at a time restriction\non a Cora Database class and the default database being stored statically).",
            "title": "RepositoryFactory Options"
        },
        {
            "location": "/documentation/v2/amblend/repository/#using-custom-setup",
            "text": "For situations where you want to swap out components of the repository system\nwith your own custom classes, you'll need to bypass the RepositoryFactory and just\ndo the setup yourself. The general format is as follows:  $db = \\Cora\\Database::getDb('name_of_db_connection_to_use');\n$class = 'User';\n$factory = new Factory($class, $db);\n$gateway = new Gateway($db);\n$repo    = new Repository($gateway, $factory);",
            "title": "Using Custom Setup"
        },
        {
            "location": "/documentation/v2/amblend/repository/#using-model-method",
            "text": "If you're in a situation where you created an instance of a Cora Model class,\nand now you need a repository for it to persist it or whatever, you can take advantage\nof Cora Model's knowledge on how to create repositories for themselves:  $user = new \\User('Josiah', 'SuperAdmin');\n$user->location = new Location('JoesHouse', 'Portland');\n$user->job      = new Job('Librarian', 'Keeper of knowledge!');\n$repo = $user->getRepository();\n$repo->save($user);",
            "title": "Using Model Method"
        },
        {
            "location": "/documentation/v2/amblend/repository/#using-a-repository",
            "text": "",
            "title": "Using a Repository"
        },
        {
            "location": "/documentation/v2/amblend/repository/#find-method",
            "text": "Purpose:   \nThe find() method is for grabbing a single object from a database based on the\nobject's unique ID.  Format:  find(id)  Examples:     // Create Repository\n$repo = \\Cora\\RepositoryFactory::make('User');\n\n// Grab a user Object\n$user = $repo->find($id);",
            "title": "find() Method"
        },
        {
            "location": "/documentation/v2/amblend/repository/#findone-method",
            "text": "Purpose:   \nThe findOne() method is for grabbing a single object from a database based on\nthe passed in query parameters.  Format:  findOne(coraDbQuery)  Examples:     // Create Repository\n$repo = \\Cora\\RepositoryFactory::make('User');\n\n// Grab an instance of database adaptor for this model.\n$db = $repo->getDb();\n\n// Define some db query parameters.\n$db->where('name', 'testUser');\n\n// Grab a user Object matching query.\n$user = $repo->findOne($db);",
            "title": "findOne() Method"
        },
        {
            "location": "/documentation/v2/amblend/repository/#findall-method",
            "text": "Purpose:   \nThe findAll() method is for grabbing all objects from a database collection.\nThe results can be limited by optionally passing along query parameters.  Format:  findAll([coraDbQuery])  Examples:     // Create Repository\n$repo = \\Cora\\RepositoryFactory::make('User');\n\n// Fetch ALL users.\n$allUsers = $repo->findAll();\n\n// Grab an instance of database adaptor for this model.\n$db = $repo->getDb();\n\n// Define some db query parameters.\n$db->where('type', 'Admin');\n\n// Grab a subset of users. In this case all users who are Admins.\n$admins = $repo->findAll($db);",
            "title": "findAll() Method"
        },
        {
            "location": "/documentation/v2/amblend/repository/#findby-method",
            "text": "Purpose:   \nThe findBy() method is for grabbing a set of objects based on a simple restriction.\nThis has the same basic functionality as findAll(), but is simpler to use with\nthe tradeoff of being less flexible.  Format:  // options = array(['order_by' => 'desc|asc'] [, 'limit' => number [, 'offset' => number]])\nfindBy(property, value [, options])  Because the \"options\" is kinda hard to read above let me just verbally describe it.\nYou can pass in an associative array with up to 3 keys, those being \"order_by\",\n\"limit\", and \"offset\". Order_by should be either \"desc\" or \"asc\", and limit and offset\nshould be numbers. Offset doesn't do anything unless you also pass in a Limit.  Examples:     // Create Repository\n$repo = \\Cora\\RepositoryFactory::make('User');\n\n// Grab users who are Admins.\n$admins = $repo->findBy('type', 'Admin');\n\n// Grab users who are Moderators, but only return the first 10.\n$mods = $repo->findBy('type', 'Moderator', ['limit' => 10]);\n\n// Grab the next 10 Moderators\n$moreMods = $repo->findBy('type', 'Moderator', ['limit' => 10, 'offset' => 10]);",
            "title": "findBy() Method"
        },
        {
            "location": "/documentation/v2/amblend/repository/#delete-method",
            "text": "Purpose:   \nThe delete() method is for deleting a single object from a database based on the\nobject's unique ID. It will call the object's own \"delete\" method for cleanup\nbefore removing the record from the database.  Format:  delete(id)  Examples:     // Create Repository\n$repo = \\Cora\\RepositoryFactory::make('User');\n\n// Delete a user.\n$repo->delete($id);",
            "title": "delete() Method"
        },
        {
            "location": "/documentation/v2/amblend/repository/#save-method",
            "text": "Purpose:   \nThe save() method is for persisting one or more objects. Usually this means saving\nrecords in a database. If the object(s) already exists in the database, then\nany changes will be updated. If the object(s) does not exist, then it will be\ninserted.  Format:  save(Cora_Model | ResultSet_of_Cora_Models [, table] [, id_name])  The Table and Id_name optional parameters are for overriding default model behavior\nif necessary. The refer to the table/collection the object should be saved to,\nand the unique identifying column for the object. You probably don't need to use\nthese! Check out the RepositoryFactory options near the top of this page for a\nway you can set these options for all operations on a Repository.  Examples:     // Create Repository\n$repo = \\Cora\\RepositoryFactory::make('User');\n\n/////////////////////////////////////////////\n// Modify a single existing user.\n/////////////////////////////////////////////\n\n// Grab a user Object\n$user = $repo->find($id);\n\n// Change something\n$user->email = 'BobsNewEmail@fakeEmail.com';\n\n// Save the changes.\n$repo->save($user);\n\n\n\n////////////////////////////////////////////\n// Save a completely new user.\n////////////////////////////////////////////\n\n// Create a user object.\n$user = new User('Bob', 'Bob@fakeEmail.com');\n\n// Save the user to the database.\n$repo->save($user);\n\n\n\n////////////////////////////////////////////\n// Modify a collection of users.\n// We'll pretend we're crediting our 'premium'\n// users some amount to their account.\n////////////////////////////////////////////\n\n// Grab a collection of users.\n$users = $repo->findBy('type', 'Premium');\n\n// Change something\nforeach ($users as $user) {\n    $user->accountCredit += 100;\n}\n\n// Save the changes.\n$repo->save($users);\n\n\n\n////////////////////////////////////////////\n// Assign a collection of objects to a user.\n////////////////////////////////////////////\n\n// Grab a user Object\n$user = $repo->find($id);\n\n// Assign a collection of articles to the user\n$user->articles =   new \\Cora\\ResultSet([\n                        new Article('How to Fly a Plane'),\n                        new Article('How to Make Money')\n                    ]);\n\n// Save the changes.\n$repo->save($user);\n\n\n\n////////////////////////////////////////////\n// Add to an existing collection of objects\n////////////////////////////////////////////\n\n// Grab a user Object\n$user = $repo->find($id);\n\n// Add a new article to the collection of articles this user has.\n$user->articles->add(new Article('How to Make Money Vol2'));\n\n// Save the changes.\n$repo->save($user);",
            "title": "save() Method"
        },
        {
            "location": "/documentation/v2/amblend/model/",
            "text": "Model Class\n\n\nThe purpose of Cora's Model class is to provide methods that allow Gateways\nto examine the properties and relations of models, and to give models the knowledge\nof the Repository system's existence and the Repository's responsibility for grabbing and\npersisting models. This enables the ActiveRecord like features of AmBlend\nsuch as dynamic loading.\n\n\nCreating a Cora Model\n\n\nTo create a Cora Model, you just need to have your model extend \\Cora\\Model like\nsuch:\n\n\nclass SomeModel extends \\Cora\\Model {}\n\n\n\n\nHowever, to actually make your model do anything useful, you need to define your\nmodel using some data members so that AmBlend knows how to use it. The core of\nthis definition, is the \"model_attributes\" array.\n\n\nAttributes\n\n\ntl;dr - A Cora model's attributes define the data that composes the model.\n\n\nNormally when talking about data members for a class in PHP, the term \"properties\" is used.\nHowever, since it's possible to define properties on a Cora model just like you would any\nother class, \"attributes\" is the term I've coined to describe those model properties\nthat relate directly to AmBlend so that the two don't get confused.\n\n\nLet's jump right in to how it works, as it's easier to describe using examples.\n\n\nHow it Works\n\n\nLet's say you have a model definition that looks like the following:\n\n\nclass User extends \\Cora\\Model {\n\n    // Normal properties\n    // These WON'T be saved to the database.\n    protected $lastAction;\n\n    // Amblend properties\n    // aka the model's \"Attributes\"\n    // These WILL be saved in the database.\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar'\n        ],\n        'type'  => [\n            'type' => 'varchar'\n        ]\n    ];\n\n    public function __construct($name = null, $email = null, $type = null)\n    {\n        $this->name     = $name;\n        $this->email    = $email;\n        $this->type     = $type;\n    }\n\n    public function changeName($newName) {\n        $this->name = $newName;\n        $this->lastAction = 'Changed Name';\n    }\n\n    public function getName() {\n        return $this->name;\n    }\n\n    public function getLastAction() {\n        return $this->lastAction;\n    }\n}\n\n\n\n\nIn the example, we've defined a normal property called \"lastAction\" which we're\nusing to keep track of the last action that was performed by/on that user. However,\nsince we defined it as a normal property and not a model attribute, that means\nthe lastAction WILL NOT get saved to the database if we save the model. That's\nsuper important to understand! You can use normal class properties, but only those\nattributes defined in the $model_attributes property will be persisted (saved).\nThis makes the \"$model_attributes\" property the backbone that supports all of\nAmBlend's functionality.\n\n\nIn terms of implementation, as can be seen in the example above, $model_attributes\nis just an associative array where the key is the name of the attribute, and the\nvalue is another associative array for defining that attribute's details. The\nmost basic detail which I always recommend including is that attribute's \"type\".\nBy defining this, you can use AmBlend's automated database creation tool.\n\n\nDefinition\n\n\nBelow are the basic properties you can use to describe an attribute definition.\n\n\n\n    \n\n        \nAttribute Name\n\n        \nValid Values\n\n        \nDescription\n\n    \n\n    \n\n        \ntype\n\n        \n\n            \n\n            \ntinyint, smallint, mediumint, int, bigint\n\n            \nvarchar, char,\n\n            \nfloat,\n\n            \ndate, datetime,\n\n            \nboolean,\n\n            \nbinary,\n\n            \ntinytext, text, mediumtext, longtext\n\n            \ntinyblob, mediumblob, blob, longblob\n\n            \n\n        \n\n        \nFor setting the \"type\" field in a DB.\n\n    \n\n    \n\n        \nsize\n\n        \n{integer}\n\n        \nThe size of the field in the DB. If size is not set and the type is 'varchar', size will default to 255 when using MySQL adaptor.\n\n    \n\n    \n\n        \nprecision\n\n        \n{integer}\n\n        \nIf the type is a float, this sets the places after the decimal point.\n\n    \n\n    \n\n        \nprimaryKey\n\n        \ntrue\n\n        \nThis should only be set for ONE attribute per model.\n\n    \n\n    \n\n        \nautoIncrement\n\n        \ntrue\n\n        \nIs the field auto-incrementing in value?\n\n    \n\n    \n\n        \ndefaultValue\n\n        \n'Some String'\n\n        \n\n            Sets a default value for this attribute. If this value needs to be\n            an object, or dynamically generated, then use the beforeCreate() lifecycle\n            callback to assign a default value. See the lifecycle callbacks section\n            for more info.\n        \n\n    \n\n    \n\n        \nenum\n\n        \n'value1', 'value2', 'value3'\n\n        \nThe valid values if the field type is set to 'enum'.\n        I don't actually recommend you use ENUM if you're starting a new project\n        (it may be hard to support across various database types).\n        This feature is mostly present for integration with existing projects.\n\n    \n\n    \n\n        \nunique\n\n        \ntrue\n\n        \nTells the database that the values of this attribute should be unique.\n\n    \n\n    \n\n        \nindex\n\n        \ntrue\n\n        \nMake an index for this attribute.\n\n    \n\n\n\n\n\nFor a slightly more detailed example, let's modify our User definition from above\nfor the user 'type' attribute. Let's say we know we don't need 255 characters (the default)\nfor the type, and also we want the default user type to be just 'User'. Furthermore,\nlet's say we know we'll be searching a lot by email, so we want to index the email attribute:\n\n\npublic $model_attributes = [\n    'id' => [\n        'type'          => 'int',\n        'primaryKey'    => true\n    ],\n    'name' => [\n        'type' => 'varchar'\n    ],\n    'email' => [\n        'type' => 'varchar',\n        'index' => true\n    ],\n    'type'  => [\n        'type' => 'varchar',\n        'size' => 55,\n        'defaultValue' => 'User'\n    ]\n];\n\n\n\n\nNow if you generate a database using AmBlend's database generation tool, it will\nreflect these changes.\n\n\nObject Relations\n\n\nAlright, hopefully the general gist of how to define a model's attributes is becoming\nclearer. An important thing we haven't addressed yet is how to setup relationships\nwith other objects. This is where things get exciting and Cora's AmBlend really shines.\nGoing back to our User object example, let's say a user has a Location associated\nwith them as well as a number of articles they've written (maybe we're running a\nblogging site or something). We would setup this relationship like so:\n\n\npublic $model_attributes = [\n    'id' => [\n        'type'          => 'int',\n        'primaryKey'    => true\n    ],\n    'name' => [\n        'type' => 'varchar'\n    ],\n    'email' => [\n        'type' => 'varchar',\n        'index' => true\n    ],\n    'type'  => [\n        'type' => 'varchar',\n        'size' => 55,\n        'defaultValue' => 'User'\n    ],\n    'location' => [\n        'model' => 'location'\n    ],\n    'articles' => [\n        'models' => 'article'\n    ]\n];\n\n\n\n\nThat's it! Notice the plural 's' on 'models' for referring to articles the user\nhas written, and the singular 'model' for representing the user's location.\n\n\nOf course, now you may be wondering how to actually USE this, but that's equally\nas intuitive and easy. Going back to the non-relational attributes like 'Type',\nif you had an existing user and you wanted to change their user type from 'User'\nto 'Moderator', you would do that like this:\n\n\n// Grab user. 'repo' is a User repository.\n$user = $this->repo->find($id);\n\n// Change their type\n$user->type = 'Moderator';\n\n// Save the change\n$repo->save($user);\n\n\n\n\nWorking with related objects is the same concept! Let's associate a new Location\nand set of Articles with a user:\n\n\n// Grab user:\n$user = $this->repo->find($id);\n\n// Associate a location to this user:\n$user->location = new Location('Fuel Medical LLC', 'Camas', 'WA');\n\n// Associate a set of Articles to this user:\n$user->articles =   new \\Cora\\ResultSet([\n                        new Article('How to Write Good Code'),\n                        new Article('How to Unit Test')\n                    ]);\n\n// Save the changes\n$repo->save($user);\n\n\n\n\nFor basic usage with a single database, that's pretty much all you need to know.\nHowever, if you're an advanced user and will have your data spread across multiple\ndatabases and/or you want more control over the setup of the database\n(like maybe you're integrating Cora into an existing database), then read on.\n\n\nUsing Multiple Databases\n\n\nThe database config file for Cora holds an array that let's you define multiple\ndatabase connections. If you've gone through the setup process, you've undoubtably\nseen it, but here's a reminder of how this looks:\n\n\n$dbConfig['defaultConnection'] = 'mainDb';\n$dbConfig['connections'] = [\n    'mainDb' => [\n        'adaptor'   => 'MySQL',\n        'host'      => 'localhost:3306',\n        'dbName'    => 'cora',\n        'dbUser'    => 'root',\n        'dbPass'    => 'root'\n    ],\n    'secondaryDb' => [\n        'adaptor'   => 'MySQL',\n        'host'      => 'localhost:3306',\n        'dbName'    => 'cora2',\n        'dbUser'    => 'root',\n        'dbPass'    => 'root'\n    ],\n    'mongoDb' => [\n        'adaptor'   => 'MongoDb',\n        'host'      => 'localhost:3306',\n        'dbName'    => 'cora3',\n        'dbUser'    => 'root',\n        'dbPass'    => 'root'\n    ]\n];\n\n\n\n\nIn this config file you define the connection details for each database, tell\nit what Cora database adaptor to use with that connection, and give each connection\na name.\n\n\nIn order to make use of multiple connections, you have to specify that some of your\nmodels use a connection which is different from the default. Like so:\n\n\nclass Guide extends MyModel {\n\n    public $model_connection = 'secondaryDb';\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'title' => [\n            'type' => 'varchar'\n        ],\n        'authors' => [\n            'models' => 'user'\n        ]\n    ];\n\n    public function __construct($title = null)\n    {\n        $this->title = $title;\n    }\n\n}\n\n\n\n\nNow when you generate your database, the Guides table/collection will get created\nusing the 'secondaryDb' connection instead of the main one. Similarly, grabbing\nGuide object from the DB using a repository will use this secondaryDb connection\ntoo:\n\n\n$repo = \\Cora\\RepositoryFactory::make('Guide');\n$guide = $repo->find($id);\n\n\n\n\nThe spot where you could run into trouble is when you want a two-way reference between\nobjects in different databases. For example, looking at our Guide definition above\nyou can see we have a reference to one or more User models representing the authors\nof said guide. But what if our Users model also keeps a reference to Guides a user\nhas been an author of? Let's add a reference to Guides in our User model:\n\n\nNote: Because our User model was defined as using the default connection\n(we didn't tell it to use anything different) AmBlend will know to fetch the authors\nfrom the main database.\n\n\npublic $model_attributes = [\n    'id' => [\n        'type'          => 'int',\n        'primaryKey'    => true\n    ],\n    'name' => [\n        'type' => 'varchar'\n    ],\n    'email' => [\n        'type' => 'varchar',\n        'index' => true\n    ],\n    'type'  => [\n        'type' => 'varchar',\n        'size' => 55,\n        'defaultValue' => 'User'\n    ],\n    'location' => [\n        'model' => 'location'\n    ],\n    'articles' => [\n        'models' => 'article'\n    ],\n    'guides' => [\n        'models' => 'guide'\n    ]\n];\n\n\n\n\nSo now we have a reference to Users from a Guide, and a reference to Guides from\na User. The way these are related is by using a relation table. If you aren't\nfamiliar with relation tables, see the image below for the general idea. Basically\nit's a really simple table that holds relationships (shocking right!?). In this\nscreenshot, guides 9 and 10 are associated with a user who's ID is '1', and\nguide 11 is associated with whoever user '2' is:\n\n\n\n\nThe problem lies in the question of \"Which database is going to hold the relation\ntable?\" Having to maintain redundant tables on each database and then remembering\nto alter both anytime a relationship changes is just plain dumb, and assuming\nthat the relationship will be kept in the default database didn't feel like an\nassumption I could make for sure either. Thus, in order to solve this problem\nI've introduced the concept of 'passive' sides in a multi-database relationship.\n\n\nTo fix our User & Guide model definitions as we've defined them above, we need to\nmark one side of that relationship as the 'passive' side like so:\n\n\nclass User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'type'  => [\n            'type' => 'varchar',\n            'size' => 55,\n            'defaultValue' => 'User'\n        ],\n        'location' => [\n            'model' => 'location'\n        ],\n        'articles' => [\n            'models' => 'article'\n        ],\n        'guides' => [\n            'models' => 'guide',\n            'passive' => true\n        ]\n    ];\n}\n\n\n\n\nBy marking the User side of the relationship as the passive side, AmBlend will\nnow know to make the relationship table on the database represented by Guide's\nconnection.\n\n\nAdvanced Configuration\n\n\nAlright, using AmBlend's automated database creation feature and simply setting\nrelationships as singular \"model\" or plural \"models\" and letting AmBlend handle the\nrest is nice and all for new projects. But let's talk about configuration options\nfor incorporating AmBlend into a pre-existing database where you have to work within\nthe constraints of the existing setup.\n\n\nFirst off, let's talk table names.\n\n\nChange the table to which a model is mapped\n\n\nBy default, a table/collection name will be the plural version of the model. For\ninstance: our User model will be stored in a table called \"users\". Our Guide model\nwill be stored in a table called \"guides\" and so on and so forth. If this behavior\nwon't work with your existing database for a particular model, you have the option\nto specify a different name.\n\n\nLet's say you are building an internal app to be used\nby your company and you want the User model to map to a table named \"employees\".\nYou would specify that like so:\n\n\nclass User extends \\Cora\\Model {\n\n    public $model_table = 'employees';\n    public $model_attributes = [\n        ... stuff here ...\n    ];\n}\n\n\n\n\nChange the name of a relation table\n\n\nWhenever you specify a simple plural relationship from one model to another like\nso:\n\n\nclass User extends \\Cora\\Model {\n\n    public $model_attributes = [\n        'articles' => [\n            'models' => 'article'\n        ]\n    ];\n}\n\n\n\n\nA relation table is used that is named by making the models involved plural and\nappending them together with an underscore in reverse alphabetical order.\nIn the example above of a User associated with an Article the resulting relation\ntable name would be \"users_articles\".\n\n\nIf you're fine with the use of a relation table, but you need to change the name\nof it. You can do so by utilizing the 'relTable' setting like this:\n\n\nclass User extends \\Cora\\Model {\n\n    public $model_attributes = [\n        'articles' => [\n            'models' => 'article',\n            'relTable' => 'some_custom_relation_table_name'\n        ]\n    ];\n}\n\n\n\n\nThe one caveat here is that at the time of this writing, I do not support custom\ncolumn names within the relation table. The relation table column names must be\nthe name of the model who's ID they hold. For the above example with User and\nArticle, the relation table will need a 'user' column and an 'article' column. If\nyou have existing relation tables that don't follow this format, you'll have to change\nthem or else not use AmBlend.\n\n\nOne-to-Many via an \"owner\" column\n\n\nThe default setup for plural relationships in AmBlend is the use of relation tables\njust because they are the most flexible. However, if you want to force the use of\nan \"owner\" type column in a one-to-many relationship either because it's your\npersonal preference or it's necessary to integrate with an existing database, AmBlend\nmakes this possible.\n\n\nWhat you'll need to do is just throw a 'via' setting in with a plural model definition.\nFor instance, let's say we don't care about supporting multiple authors for an article\non our site, but rather just want an article to have a single owner and we want to\nstore a reference to this owner in the articles table via an \"owner\" column. We\ndo that like this:\n\n\nclass User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'type'  => [\n            'type' => 'varchar',\n            'size' => 55,\n            'defaultValue' => 'User'\n        ],\n        'location' => [\n            'model' => 'location'\n        ],\n        'articles' => [\n            'models' => 'article',\n            'via'    => 'owner'\n        ]\n    ];\n}\n\n\n\n\nOne-to-One using a relation table\n\n\nBy default, one-to-one relationships are stored as a column on the model's table.\nFor instance, the following definition for a related Job object would be stored\nas seen in the picture below:\n\n\nclass User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'type'  => [\n            'type' => 'varchar',\n            'size' => 55,\n            'defaultValue' => 'User'\n        ],\n        'job' => [\n            'model' => 'job'\n        ]\n    ];\n}\n\n\n\n\n\"users\" table:\n \n\n\n\n\nHowever, if for some reason you wanted to force a single reference to use a relation\ntable (maybe you felt it could change to a plural relationship in the future or something),\nyou could do so by specifying \"usesRefTable\" as true:\n\n\nclass User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'type'  => [\n            'type' => 'varchar',\n            'size' => 55,\n            'defaultValue' => 'User'\n        ],\n        'job' => [\n            'model' => 'job',\n            'usesRefTable' => true\n        ]\n    ];\n}\n\n\n\n\nOptionally you can of course combine this with the previously talked about\n\"relTable\" option to specify the name of the relation table if the default naming\ndoesn't work for you.\n\n\nNamespaces\n\n\nJust a quick explanation of namespaces in the model definition...\n\n\nWhen defining related models in your $model_attributes array, namespaces are\nalways absolute, never relative. See the namespaced Notes model below and the\nrelationship definition added to User for an example:\n\n\n<?php\nnamespace Task;\n\nclass Note extends \\Note {\n\n    public $model_table = 'notes_tasks';\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'title' => [\n            'type' => 'varchar'\n        ],\n        'note' => [\n            'type' => 'text'\n        ],\n        'owner' => [\n            'model' => 'user'\n        ]\n    ];\n}\n\n\n\n\nclass User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'type'  => [\n            'type' => 'varchar',\n            'size' => 55,\n            'defaultValue' => 'User'\n        ],\n        'notes' => [\n            'models' => 'task\\\\note',\n            'via'    => 'owner'\n        ]\n    ];\n}",
            "title": "Model"
        },
        {
            "location": "/documentation/v2/amblend/model/#model-class",
            "text": "The purpose of Cora's Model class is to provide methods that allow Gateways\nto examine the properties and relations of models, and to give models the knowledge\nof the Repository system's existence and the Repository's responsibility for grabbing and\npersisting models. This enables the ActiveRecord like features of AmBlend\nsuch as dynamic loading.",
            "title": "Model Class"
        },
        {
            "location": "/documentation/v2/amblend/model/#creating-a-cora-model",
            "text": "To create a Cora Model, you just need to have your model extend \\Cora\\Model like\nsuch:  class SomeModel extends \\Cora\\Model {}  However, to actually make your model do anything useful, you need to define your\nmodel using some data members so that AmBlend knows how to use it. The core of\nthis definition, is the \"model_attributes\" array.",
            "title": "Creating a Cora Model"
        },
        {
            "location": "/documentation/v2/amblend/model/#attributes",
            "text": "tl;dr - A Cora model's attributes define the data that composes the model.  Normally when talking about data members for a class in PHP, the term \"properties\" is used.\nHowever, since it's possible to define properties on a Cora model just like you would any\nother class, \"attributes\" is the term I've coined to describe those model properties\nthat relate directly to AmBlend so that the two don't get confused.  Let's jump right in to how it works, as it's easier to describe using examples.",
            "title": "Attributes"
        },
        {
            "location": "/documentation/v2/amblend/model/#how-it-works",
            "text": "Let's say you have a model definition that looks like the following:  class User extends \\Cora\\Model {\n\n    // Normal properties\n    // These WON'T be saved to the database.\n    protected $lastAction;\n\n    // Amblend properties\n    // aka the model's \"Attributes\"\n    // These WILL be saved in the database.\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar'\n        ],\n        'type'  => [\n            'type' => 'varchar'\n        ]\n    ];\n\n    public function __construct($name = null, $email = null, $type = null)\n    {\n        $this->name     = $name;\n        $this->email    = $email;\n        $this->type     = $type;\n    }\n\n    public function changeName($newName) {\n        $this->name = $newName;\n        $this->lastAction = 'Changed Name';\n    }\n\n    public function getName() {\n        return $this->name;\n    }\n\n    public function getLastAction() {\n        return $this->lastAction;\n    }\n}  In the example, we've defined a normal property called \"lastAction\" which we're\nusing to keep track of the last action that was performed by/on that user. However,\nsince we defined it as a normal property and not a model attribute, that means\nthe lastAction WILL NOT get saved to the database if we save the model. That's\nsuper important to understand! You can use normal class properties, but only those\nattributes defined in the $model_attributes property will be persisted (saved).\nThis makes the \"$model_attributes\" property the backbone that supports all of\nAmBlend's functionality.  In terms of implementation, as can be seen in the example above, $model_attributes\nis just an associative array where the key is the name of the attribute, and the\nvalue is another associative array for defining that attribute's details. The\nmost basic detail which I always recommend including is that attribute's \"type\".\nBy defining this, you can use AmBlend's automated database creation tool.",
            "title": "How it Works"
        },
        {
            "location": "/documentation/v2/amblend/model/#definition",
            "text": "Below are the basic properties you can use to describe an attribute definition.  \n     \n         Attribute Name \n         Valid Values \n         Description \n     \n     \n         type \n         \n             \n             tinyint, smallint, mediumint, int, bigint \n             varchar, char, \n             float, \n             date, datetime, \n             boolean, \n             binary, \n             tinytext, text, mediumtext, longtext \n             tinyblob, mediumblob, blob, longblob \n             \n         \n         For setting the \"type\" field in a DB. \n     \n     \n         size \n         {integer} \n         The size of the field in the DB. If size is not set and the type is 'varchar', size will default to 255 when using MySQL adaptor. \n     \n     \n         precision \n         {integer} \n         If the type is a float, this sets the places after the decimal point. \n     \n     \n         primaryKey \n         true \n         This should only be set for ONE attribute per model. \n     \n     \n         autoIncrement \n         true \n         Is the field auto-incrementing in value? \n     \n     \n         defaultValue \n         'Some String' \n         \n            Sets a default value for this attribute. If this value needs to be\n            an object, or dynamically generated, then use the beforeCreate() lifecycle\n            callback to assign a default value. See the lifecycle callbacks section\n            for more info.\n         \n     \n     \n         enum \n         'value1', 'value2', 'value3' \n         The valid values if the field type is set to 'enum'.\n        I don't actually recommend you use ENUM if you're starting a new project\n        (it may be hard to support across various database types).\n        This feature is mostly present for integration with existing projects. \n     \n     \n         unique \n         true \n         Tells the database that the values of this attribute should be unique. \n     \n     \n         index \n         true \n         Make an index for this attribute. \n       For a slightly more detailed example, let's modify our User definition from above\nfor the user 'type' attribute. Let's say we know we don't need 255 characters (the default)\nfor the type, and also we want the default user type to be just 'User'. Furthermore,\nlet's say we know we'll be searching a lot by email, so we want to index the email attribute:  public $model_attributes = [\n    'id' => [\n        'type'          => 'int',\n        'primaryKey'    => true\n    ],\n    'name' => [\n        'type' => 'varchar'\n    ],\n    'email' => [\n        'type' => 'varchar',\n        'index' => true\n    ],\n    'type'  => [\n        'type' => 'varchar',\n        'size' => 55,\n        'defaultValue' => 'User'\n    ]\n];  Now if you generate a database using AmBlend's database generation tool, it will\nreflect these changes.",
            "title": "Definition"
        },
        {
            "location": "/documentation/v2/amblend/model/#object-relations",
            "text": "Alright, hopefully the general gist of how to define a model's attributes is becoming\nclearer. An important thing we haven't addressed yet is how to setup relationships\nwith other objects. This is where things get exciting and Cora's AmBlend really shines.\nGoing back to our User object example, let's say a user has a Location associated\nwith them as well as a number of articles they've written (maybe we're running a\nblogging site or something). We would setup this relationship like so:  public $model_attributes = [\n    'id' => [\n        'type'          => 'int',\n        'primaryKey'    => true\n    ],\n    'name' => [\n        'type' => 'varchar'\n    ],\n    'email' => [\n        'type' => 'varchar',\n        'index' => true\n    ],\n    'type'  => [\n        'type' => 'varchar',\n        'size' => 55,\n        'defaultValue' => 'User'\n    ],\n    'location' => [\n        'model' => 'location'\n    ],\n    'articles' => [\n        'models' => 'article'\n    ]\n];  That's it! Notice the plural 's' on 'models' for referring to articles the user\nhas written, and the singular 'model' for representing the user's location.  Of course, now you may be wondering how to actually USE this, but that's equally\nas intuitive and easy. Going back to the non-relational attributes like 'Type',\nif you had an existing user and you wanted to change their user type from 'User'\nto 'Moderator', you would do that like this:  // Grab user. 'repo' is a User repository.\n$user = $this->repo->find($id);\n\n// Change their type\n$user->type = 'Moderator';\n\n// Save the change\n$repo->save($user);  Working with related objects is the same concept! Let's associate a new Location\nand set of Articles with a user:  // Grab user:\n$user = $this->repo->find($id);\n\n// Associate a location to this user:\n$user->location = new Location('Fuel Medical LLC', 'Camas', 'WA');\n\n// Associate a set of Articles to this user:\n$user->articles =   new \\Cora\\ResultSet([\n                        new Article('How to Write Good Code'),\n                        new Article('How to Unit Test')\n                    ]);\n\n// Save the changes\n$repo->save($user);  For basic usage with a single database, that's pretty much all you need to know.\nHowever, if you're an advanced user and will have your data spread across multiple\ndatabases and/or you want more control over the setup of the database\n(like maybe you're integrating Cora into an existing database), then read on.",
            "title": "Object Relations"
        },
        {
            "location": "/documentation/v2/amblend/model/#using-multiple-databases",
            "text": "The database config file for Cora holds an array that let's you define multiple\ndatabase connections. If you've gone through the setup process, you've undoubtably\nseen it, but here's a reminder of how this looks:  $dbConfig['defaultConnection'] = 'mainDb';\n$dbConfig['connections'] = [\n    'mainDb' => [\n        'adaptor'   => 'MySQL',\n        'host'      => 'localhost:3306',\n        'dbName'    => 'cora',\n        'dbUser'    => 'root',\n        'dbPass'    => 'root'\n    ],\n    'secondaryDb' => [\n        'adaptor'   => 'MySQL',\n        'host'      => 'localhost:3306',\n        'dbName'    => 'cora2',\n        'dbUser'    => 'root',\n        'dbPass'    => 'root'\n    ],\n    'mongoDb' => [\n        'adaptor'   => 'MongoDb',\n        'host'      => 'localhost:3306',\n        'dbName'    => 'cora3',\n        'dbUser'    => 'root',\n        'dbPass'    => 'root'\n    ]\n];  In this config file you define the connection details for each database, tell\nit what Cora database adaptor to use with that connection, and give each connection\na name.  In order to make use of multiple connections, you have to specify that some of your\nmodels use a connection which is different from the default. Like so:  class Guide extends MyModel {\n\n    public $model_connection = 'secondaryDb';\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'title' => [\n            'type' => 'varchar'\n        ],\n        'authors' => [\n            'models' => 'user'\n        ]\n    ];\n\n    public function __construct($title = null)\n    {\n        $this->title = $title;\n    }\n\n}  Now when you generate your database, the Guides table/collection will get created\nusing the 'secondaryDb' connection instead of the main one. Similarly, grabbing\nGuide object from the DB using a repository will use this secondaryDb connection\ntoo:  $repo = \\Cora\\RepositoryFactory::make('Guide');\n$guide = $repo->find($id);  The spot where you could run into trouble is when you want a two-way reference between\nobjects in different databases. For example, looking at our Guide definition above\nyou can see we have a reference to one or more User models representing the authors\nof said guide. But what if our Users model also keeps a reference to Guides a user\nhas been an author of? Let's add a reference to Guides in our User model:  Note: Because our User model was defined as using the default connection\n(we didn't tell it to use anything different) AmBlend will know to fetch the authors\nfrom the main database.  public $model_attributes = [\n    'id' => [\n        'type'          => 'int',\n        'primaryKey'    => true\n    ],\n    'name' => [\n        'type' => 'varchar'\n    ],\n    'email' => [\n        'type' => 'varchar',\n        'index' => true\n    ],\n    'type'  => [\n        'type' => 'varchar',\n        'size' => 55,\n        'defaultValue' => 'User'\n    ],\n    'location' => [\n        'model' => 'location'\n    ],\n    'articles' => [\n        'models' => 'article'\n    ],\n    'guides' => [\n        'models' => 'guide'\n    ]\n];  So now we have a reference to Users from a Guide, and a reference to Guides from\na User. The way these are related is by using a relation table. If you aren't\nfamiliar with relation tables, see the image below for the general idea. Basically\nit's a really simple table that holds relationships (shocking right!?). In this\nscreenshot, guides 9 and 10 are associated with a user who's ID is '1', and\nguide 11 is associated with whoever user '2' is:   The problem lies in the question of \"Which database is going to hold the relation\ntable?\" Having to maintain redundant tables on each database and then remembering\nto alter both anytime a relationship changes is just plain dumb, and assuming\nthat the relationship will be kept in the default database didn't feel like an\nassumption I could make for sure either. Thus, in order to solve this problem\nI've introduced the concept of 'passive' sides in a multi-database relationship.  To fix our User & Guide model definitions as we've defined them above, we need to\nmark one side of that relationship as the 'passive' side like so:  class User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'type'  => [\n            'type' => 'varchar',\n            'size' => 55,\n            'defaultValue' => 'User'\n        ],\n        'location' => [\n            'model' => 'location'\n        ],\n        'articles' => [\n            'models' => 'article'\n        ],\n        'guides' => [\n            'models' => 'guide',\n            'passive' => true\n        ]\n    ];\n}  By marking the User side of the relationship as the passive side, AmBlend will\nnow know to make the relationship table on the database represented by Guide's\nconnection.",
            "title": "Using Multiple Databases"
        },
        {
            "location": "/documentation/v2/amblend/model/#advanced-configuration",
            "text": "Alright, using AmBlend's automated database creation feature and simply setting\nrelationships as singular \"model\" or plural \"models\" and letting AmBlend handle the\nrest is nice and all for new projects. But let's talk about configuration options\nfor incorporating AmBlend into a pre-existing database where you have to work within\nthe constraints of the existing setup.  First off, let's talk table names.",
            "title": "Advanced Configuration"
        },
        {
            "location": "/documentation/v2/amblend/model/#change-the-table-to-which-a-model-is-mapped",
            "text": "By default, a table/collection name will be the plural version of the model. For\ninstance: our User model will be stored in a table called \"users\". Our Guide model\nwill be stored in a table called \"guides\" and so on and so forth. If this behavior\nwon't work with your existing database for a particular model, you have the option\nto specify a different name.  Let's say you are building an internal app to be used\nby your company and you want the User model to map to a table named \"employees\".\nYou would specify that like so:  class User extends \\Cora\\Model {\n\n    public $model_table = 'employees';\n    public $model_attributes = [\n        ... stuff here ...\n    ];\n}",
            "title": "Change the table to which a model is mapped"
        },
        {
            "location": "/documentation/v2/amblend/model/#change-the-name-of-a-relation-table",
            "text": "Whenever you specify a simple plural relationship from one model to another like\nso:  class User extends \\Cora\\Model {\n\n    public $model_attributes = [\n        'articles' => [\n            'models' => 'article'\n        ]\n    ];\n}  A relation table is used that is named by making the models involved plural and\nappending them together with an underscore in reverse alphabetical order.\nIn the example above of a User associated with an Article the resulting relation\ntable name would be \"users_articles\".  If you're fine with the use of a relation table, but you need to change the name\nof it. You can do so by utilizing the 'relTable' setting like this:  class User extends \\Cora\\Model {\n\n    public $model_attributes = [\n        'articles' => [\n            'models' => 'article',\n            'relTable' => 'some_custom_relation_table_name'\n        ]\n    ];\n}  The one caveat here is that at the time of this writing, I do not support custom\ncolumn names within the relation table. The relation table column names must be\nthe name of the model who's ID they hold. For the above example with User and\nArticle, the relation table will need a 'user' column and an 'article' column. If\nyou have existing relation tables that don't follow this format, you'll have to change\nthem or else not use AmBlend.",
            "title": "Change the name of a relation table"
        },
        {
            "location": "/documentation/v2/amblend/model/#one-to-many-via-an-owner-column",
            "text": "The default setup for plural relationships in AmBlend is the use of relation tables\njust because they are the most flexible. However, if you want to force the use of\nan \"owner\" type column in a one-to-many relationship either because it's your\npersonal preference or it's necessary to integrate with an existing database, AmBlend\nmakes this possible.  What you'll need to do is just throw a 'via' setting in with a plural model definition.\nFor instance, let's say we don't care about supporting multiple authors for an article\non our site, but rather just want an article to have a single owner and we want to\nstore a reference to this owner in the articles table via an \"owner\" column. We\ndo that like this:  class User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'type'  => [\n            'type' => 'varchar',\n            'size' => 55,\n            'defaultValue' => 'User'\n        ],\n        'location' => [\n            'model' => 'location'\n        ],\n        'articles' => [\n            'models' => 'article',\n            'via'    => 'owner'\n        ]\n    ];\n}",
            "title": "One-to-Many via an \"owner\" column"
        },
        {
            "location": "/documentation/v2/amblend/model/#one-to-one-using-a-relation-table",
            "text": "By default, one-to-one relationships are stored as a column on the model's table.\nFor instance, the following definition for a related Job object would be stored\nas seen in the picture below:  class User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'type'  => [\n            'type' => 'varchar',\n            'size' => 55,\n            'defaultValue' => 'User'\n        ],\n        'job' => [\n            'model' => 'job'\n        ]\n    ];\n}  \"users\" table:     However, if for some reason you wanted to force a single reference to use a relation\ntable (maybe you felt it could change to a plural relationship in the future or something),\nyou could do so by specifying \"usesRefTable\" as true:  class User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'type'  => [\n            'type' => 'varchar',\n            'size' => 55,\n            'defaultValue' => 'User'\n        ],\n        'job' => [\n            'model' => 'job',\n            'usesRefTable' => true\n        ]\n    ];\n}  Optionally you can of course combine this with the previously talked about\n\"relTable\" option to specify the name of the relation table if the default naming\ndoesn't work for you.",
            "title": "One-to-One using a relation table"
        },
        {
            "location": "/documentation/v2/amblend/model/#namespaces",
            "text": "Just a quick explanation of namespaces in the model definition...  When defining related models in your $model_attributes array, namespaces are\nalways absolute, never relative. See the namespaced Notes model below and the\nrelationship definition added to User for an example:  <?php\nnamespace Task;\n\nclass Note extends \\Note {\n\n    public $model_table = 'notes_tasks';\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'title' => [\n            'type' => 'varchar'\n        ],\n        'note' => [\n            'type' => 'text'\n        ],\n        'owner' => [\n            'model' => 'user'\n        ]\n    ];\n}  class User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'type'  => [\n            'type' => 'varchar',\n            'size' => 55,\n            'defaultValue' => 'User'\n        ],\n        'notes' => [\n            'models' => 'task\\\\note',\n            'via'    => 'owner'\n        ]\n    ];\n}",
            "title": "Namespaces"
        },
        {
            "location": "/documentation/v2/amblend/gateway/",
            "text": "Gateway Class\n\n\nThe Gateway directly interacts with the persistence layer (databases, files) to\ngrab and return data. It takes a request form a Repository, figures out how to\ngrab the needed info, and then returns that info to the Repository.\n\n\nCreating a Gateway\n\n\nNormally you shouldn't be creating Gateways yourself. If you refer to the\nRepository documentation and use the recommended Repository creation method of\nutilizing the RepositoryFactory class, then it will create a Gateway for you\nand handle passing it off to the Repository.\n\n\nIf for some reason you do need to create your own Gateway object and you're\nusing Cora's default Gateway, then do so like this:\n\n\n$db = \\Cora\\Database::getDb('name_of_db_connection_to_use');\n$gateway = new Gateway($db);\n\n\n\n\nOptionally you can include a couple extra arguments in the form of setting the\ntable to use and the unique identifying field of records in that table if it's\nsomething other than 'id':\n\n\n$db = \\Cora\\Database::getDb('name_of_db_connection_to_use');\n$gateway = new Gateway($db, 'users', 'email');",
            "title": "Gateway"
        },
        {
            "location": "/documentation/v2/amblend/gateway/#gateway-class",
            "text": "The Gateway directly interacts with the persistence layer (databases, files) to\ngrab and return data. It takes a request form a Repository, figures out how to\ngrab the needed info, and then returns that info to the Repository.",
            "title": "Gateway Class"
        },
        {
            "location": "/documentation/v2/amblend/gateway/#creating-a-gateway",
            "text": "Normally you shouldn't be creating Gateways yourself. If you refer to the\nRepository documentation and use the recommended Repository creation method of\nutilizing the RepositoryFactory class, then it will create a Gateway for you\nand handle passing it off to the Repository.  If for some reason you do need to create your own Gateway object and you're\nusing Cora's default Gateway, then do so like this:  $db = \\Cora\\Database::getDb('name_of_db_connection_to_use');\n$gateway = new Gateway($db);  Optionally you can include a couple extra arguments in the form of setting the\ntable to use and the unique identifying field of records in that table if it's\nsomething other than 'id':  $db = \\Cora\\Database::getDb('name_of_db_connection_to_use');\n$gateway = new Gateway($db, 'users', 'email');",
            "title": "Creating a Gateway"
        },
        {
            "location": "/documentation/v2/amblend/factory/",
            "text": "Factory Class\n\n\nThe Factory takes an array of info and turns it into objects. It's use within\nAmBlend is to receive from the Repository some data grabbed from the persistence\nlayer via the Gateway. It then turns this data into one or more objects and\ngives these objects back to the Repository.\n\n\nCreating a Factory\n\n\nNormally you shouldn't be creating Factories yourself. If you refer to the\nRepository documentation and use the recommended Repository creation method of\nutilizing the RepositoryFactory class, then it will create a Factory for you\nand handle passing it off to the Repository.\n\n\nIf for some reason you do need to create your own Factory object and you're\nusing Cora's default Factory, then do so like this:\n\n\n// Create a User factory\n$factory = new Factory('User');\n\n\n\n\nOptionally you can include a 2nd argument in the form of a Cora database adaptor.\nIf you do this, the adaptor will get passed on to any objects created by the Factory.\nThe reason for this is when you want to override the default database for a model.\nIf for instance you have a model that normally is found in your main database, but\nfor unit testing you want to use a separate test database, you can pass in a connection\nto the test database this way so it gets used.\n\n\n$db = \\Cora\\Database::getDb('name_of_db_connection_to_use');\n$factory = new Factory('User', $db);",
            "title": "Factory"
        },
        {
            "location": "/documentation/v2/amblend/factory/#factory-class",
            "text": "The Factory takes an array of info and turns it into objects. It's use within\nAmBlend is to receive from the Repository some data grabbed from the persistence\nlayer via the Gateway. It then turns this data into one or more objects and\ngives these objects back to the Repository.",
            "title": "Factory Class"
        },
        {
            "location": "/documentation/v2/amblend/factory/#creating-a-factory",
            "text": "Normally you shouldn't be creating Factories yourself. If you refer to the\nRepository documentation and use the recommended Repository creation method of\nutilizing the RepositoryFactory class, then it will create a Factory for you\nand handle passing it off to the Repository.  If for some reason you do need to create your own Factory object and you're\nusing Cora's default Factory, then do so like this:  // Create a User factory\n$factory = new Factory('User');  Optionally you can include a 2nd argument in the form of a Cora database adaptor.\nIf you do this, the adaptor will get passed on to any objects created by the Factory.\nThe reason for this is when you want to override the default database for a model.\nIf for instance you have a model that normally is found in your main database, but\nfor unit testing you want to use a separate test database, you can pass in a connection\nto the test database this way so it gets used.  $db = \\Cora\\Database::getDb('name_of_db_connection_to_use');\n$factory = new Factory('User', $db);",
            "title": "Creating a Factory"
        },
        {
            "location": "/documentation/v2/amblend/lifecycle/",
            "text": "Lifecycle Callbacks\n\n\nLifecycle callbacks are methods on a model that get called automatically when\ncertain actions are performed on that model. For instance, if you create a new\nUser and ask a Repository to save it, the model's \"beforeCreate()\" method will get called\nbefore the User gets saved to the database, and the \"afterCreate()\" method will\nget called after a record for that User gets inserted.\n\n\nThere are various uses where these Lifecycle Callbacks could come in handy, and\nI'll try to give an example or two.\n\n\nList of Callbacks\n\n\n\n    \n\n        \nCallback\n\n        \nDescription\n\n    \n\n    \n\n        \nafterCreate()\n\n        \n\n            Called after insertion happens when a Repository is asked to save\n            a NEW object.\n        \n\n    \n\n    \n\n        \nafterGet($property, $value)\n\n        \n\n            Called after a model property gets grabbed.\n        \n\n    \n\n    \n\n        \nafterSave()\n\n        \n\n            Called after an update happens when a Repository is asked to save\n            an EXISTING object. Also called after an insertion happens when a repo\n            is asked to save a NEW object (called right AFTER beforeCreate).\n        \n\n    \n\n    \n\n        \nafterSet($property, $value)\n\n        \n\n            Called after a model property gets set.\n        \n\n    \n\n    \n\n        \nbeforeCreate()\n\n        \n\n            Called before insertion happens when a Repository is asked to save\n            a NEW object.\n        \n\n    \n\n    \n\n        \nbeforeGet($property)\n\n        \n\n            Called before a model property gets grabbed.\n        \n\n    \n\n    \n\n        \nbeforeSave()\n\n        \n\n            Called before an update happens when a Repository is asked to save\n            an EXISTING object. Also called before an insertion happens when a repo\n            is asked to save a NEW object (called right AFTER afterCreate).\n        \n\n    \n\n    \n\n        \nbeforeSet($property, $value)\n\n        \n\n            Called before a model property gets set. I.E. If you set a name on\n            a User object like so: $user->name = 'Bob', the beforeSet method\n            will get called with \"name\" as the property and 'Bob' as the value\n            before the setting takes place.\n        \n\n    \n\n    \n\n        \ndelete()\n\n        \n\n            Called before deletion happens when a Repository is asked to delete\n            an object.\n        \n\n    \n\n    \n\n        \nonLoad()\n\n        \n\n            Models are populated/hydrated AFTER getting created. So in the constructor you can't create computed properties.\n            This method is called after the model has been populated so you can compute new properties as necessary.\n            I.E. Concatenate a first name and last into a \"name\" property.\n        \n\n    \n\n\n\n\n\nUsage Examples\n\n\nIf you haven't used callbacks before, it may not be immediately clear how or\nwhy you might want to use them. The following are a few examples of common use\ncases where callbacks can make your life easier.\n\n\nSetting a Computed Default Value\n\n\nAlright, say you have a User model and you want to have a \"joinedDate\" property\nthat represents when that user first joined your site/app. The easiest way to\ndo this would be to use the beforeCreate() callback. This means adding a\nbeforeCreate() method to your User model that maybe looks something like this:\n\n\nclass User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'joinedDate' => [\n            'type' => 'date'\n        ]\n    ];\n\n    public function beforeCreate()\n    {\n        $this->joinedDate = date('Y-m-d');\n    }\n}\n\n\n\n\nSince beforeCreate() gets called BEFORE the saving of the object to the database\ntakes place, that means the 'joinedDate' property will have the current date and\nget saved to the database as such.\n\n\nDoing Cleanup Before Deleting\n\n\nAnother common use case might be doing some sort of database cleanup before deleting\nan object. Say you have some sort of \"Comment\" object representing comments users\ncan leave on content on your site. Let's also say for this example that Users can\nupload files as an attachment to a comment and those files are stored in a separate\ntable/collection with a reference back to the parent. When you tell AmBlend to delete\nthe parent comment like so:\n\n\n$repo = \\Cora\\RepositoryFactory::make('Comment');\n$comment = $repo->find($id);\n$comment->delete();\n\n\n\n\nAny related children WILL NOT get automatically deleted along with it (because\nAmBlend can't safely assume that deleting all related objects is desired behavior)!\nIn order to avoid leaving unwanted orphans in the database, you can\nutilize the delete() callback to manually delete or reassign any related data.\n\n\nclass Comment extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'user' => [\n            'model' => 'User'\n        ],\n        'text' => [\n            'type' => 'text'\n        ],\n        'files' => [\n            'models' => 'FileAttachment'\n        ]\n    ];\n\n    public function delete()\n    {\n        // Code to handle files related to this comment...\n    }\n}\n\n\n\n\nConvert a Date String from mm-dd-yyyy to yyyy-mm-dd when Saving\n\n\nAnother area where callbacks could be useful is if you have a date in your model\nthat is stored as a string in the \"mm-dd-yyyy\" format and you need to convert it\nto a \"yyyy-mm-dd\" string for insertion into a database.\n\n\nAnd before I give this example, let me just point out that AmBlend is meant to work\nwell with php DateTime objects. If you grab a model using a Repository that\nhas a \"date\" or \"datetime\" database field, that field will automatically get\nconverted into a DateTime object for you when it's populated into your model.\nSimilarly, when you go to save your model, the DateTime will be grabbed as a\n\"yyyy-mm-dd\" string for use with the database\nautomatically - no work needs to be done on your part as a developer.\n\n\nHowever, if for whatever reason your model has a date that is being stored as a plain\nstring, and you don't want to convert it into a DateTime object (see next example),\nthen the following example could be useful to you:\n\n\nclass User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'joinedDate' => [\n            'type' => 'varchar'\n        ]\n    ];\n\n    public function beforeSave()\n    {\n        // Save the real value of joinedDate to a temp variable\n        $this->joinedDateTemp = $this->joinedDate;\n\n        // Swap joinedDate from mm-dd-yyyy to yyyy-mm-dd\n        $timestamp = strtotime($this->joinedDate);\n        $this->joinedDate = date('Y-m-d', $timestamp);\n    }\n\n    public function afterSave()\n    {\n        // Swap joinedDate back to its mm-dd-yyyy value.\n        $this->joinedDate = $this->joinedDateTemp;\n\n        // You can optionally clear the temp variable we used.\n        $this->joinedDateTemp = null;\n    }\n}\n\n\n\n\nThe above code makes \"joinedDate\" a string of yyyy-mm-dd format right before the\nUser object is saved, and then swaps it back to its original mm-dd-yyyy format\nafter the save is finished.\n\n\nGrab Date in Particular Format\n\n\nWhen AmBlend fetches date fields from a database, it converts them into php\nDateTime objects. If you've used DateTime object before, then you probably know\nyou can get their value formatting in a certain way by doing:\n\n\necho $someDate->format('m-d-Y');\n\n\n\n\nHowever, if for some reason you didn't want to have to specify the format\nanytime you display a date, you could utilize the beforeGet() method to always\nhave it return in a particular way:\n\n\nclass User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'joinedDate' => [\n            'type' => 'date'\n        ]\n    ];\n\n    public function beforeGet($prop)\n    {\n        if ($prop == 'joinedDate') {\n            // Save the real value of joinedDate to a temp variable\n            $this->joinedDateTemp = $this->joinedDate;\n\n            // Change the value of joinedDate to a formatted string\n            $this->joinedDate = $this->joinedDate->format('m-d-Y');\n        }\n    }\n\n    public function afterGet($prop, $value)\n    {\n        if ($prop == 'joinedDate') {\n            // Restore joined date.\n            $this->joinedDate = $this->joinedDateTemp;\n        }\n    }\n}\n\n\n\n\nEnforcing Restrictions on a Data Member\n\n\nAnother possible use for callbacks could be enforcing some set of restrictions\non a particular data member within a model. For instance, let's say you have an\n\"age\" property on your User model and you want to ensure that only numbers get\nassigned to it. You can do this by utilizing the beforeSet() callback:\n\n\nclass User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'age' => [\n            'type' => 'int'\n        ]\n    ];\n\n    public function beforeSet($prop, $value)\n    {\n        if ($prop == 'age') {\n            if (is_numeric($value) == false) {\n                // Throw some exception or something...\n            }\n        }\n    }\n}",
            "title": "Lifecycle Callbacks"
        },
        {
            "location": "/documentation/v2/amblend/lifecycle/#lifecycle-callbacks",
            "text": "Lifecycle callbacks are methods on a model that get called automatically when\ncertain actions are performed on that model. For instance, if you create a new\nUser and ask a Repository to save it, the model's \"beforeCreate()\" method will get called\nbefore the User gets saved to the database, and the \"afterCreate()\" method will\nget called after a record for that User gets inserted.  There are various uses where these Lifecycle Callbacks could come in handy, and\nI'll try to give an example or two.",
            "title": "Lifecycle Callbacks"
        },
        {
            "location": "/documentation/v2/amblend/lifecycle/#list-of-callbacks",
            "text": "Callback \n         Description \n     \n     \n         afterCreate() \n         \n            Called after insertion happens when a Repository is asked to save\n            a NEW object.\n         \n     \n     \n         afterGet($property, $value) \n         \n            Called after a model property gets grabbed.\n         \n     \n     \n         afterSave() \n         \n            Called after an update happens when a Repository is asked to save\n            an EXISTING object. Also called after an insertion happens when a repo\n            is asked to save a NEW object (called right AFTER beforeCreate).\n         \n     \n     \n         afterSet($property, $value) \n         \n            Called after a model property gets set.\n         \n     \n     \n         beforeCreate() \n         \n            Called before insertion happens when a Repository is asked to save\n            a NEW object.\n         \n     \n     \n         beforeGet($property) \n         \n            Called before a model property gets grabbed.\n         \n     \n     \n         beforeSave() \n         \n            Called before an update happens when a Repository is asked to save\n            an EXISTING object. Also called before an insertion happens when a repo\n            is asked to save a NEW object (called right AFTER afterCreate).\n         \n     \n     \n         beforeSet($property, $value) \n         \n            Called before a model property gets set. I.E. If you set a name on\n            a User object like so: $user->name = 'Bob', the beforeSet method\n            will get called with \"name\" as the property and 'Bob' as the value\n            before the setting takes place.\n         \n     \n     \n         delete() \n         \n            Called before deletion happens when a Repository is asked to delete\n            an object.\n         \n     \n     \n         onLoad() \n         \n            Models are populated/hydrated AFTER getting created. So in the constructor you can't create computed properties.\n            This method is called after the model has been populated so you can compute new properties as necessary.\n            I.E. Concatenate a first name and last into a \"name\" property.",
            "title": "List of Callbacks"
        },
        {
            "location": "/documentation/v2/amblend/lifecycle/#usage-examples",
            "text": "If you haven't used callbacks before, it may not be immediately clear how or\nwhy you might want to use them. The following are a few examples of common use\ncases where callbacks can make your life easier.",
            "title": "Usage Examples"
        },
        {
            "location": "/documentation/v2/amblend/lifecycle/#setting-a-computed-default-value",
            "text": "Alright, say you have a User model and you want to have a \"joinedDate\" property\nthat represents when that user first joined your site/app. The easiest way to\ndo this would be to use the beforeCreate() callback. This means adding a\nbeforeCreate() method to your User model that maybe looks something like this:  class User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'joinedDate' => [\n            'type' => 'date'\n        ]\n    ];\n\n    public function beforeCreate()\n    {\n        $this->joinedDate = date('Y-m-d');\n    }\n}  Since beforeCreate() gets called BEFORE the saving of the object to the database\ntakes place, that means the 'joinedDate' property will have the current date and\nget saved to the database as such.",
            "title": "Setting a Computed Default Value"
        },
        {
            "location": "/documentation/v2/amblend/lifecycle/#doing-cleanup-before-deleting",
            "text": "Another common use case might be doing some sort of database cleanup before deleting\nan object. Say you have some sort of \"Comment\" object representing comments users\ncan leave on content on your site. Let's also say for this example that Users can\nupload files as an attachment to a comment and those files are stored in a separate\ntable/collection with a reference back to the parent. When you tell AmBlend to delete\nthe parent comment like so:  $repo = \\Cora\\RepositoryFactory::make('Comment');\n$comment = $repo->find($id);\n$comment->delete();  Any related children WILL NOT get automatically deleted along with it (because\nAmBlend can't safely assume that deleting all related objects is desired behavior)!\nIn order to avoid leaving unwanted orphans in the database, you can\nutilize the delete() callback to manually delete or reassign any related data.  class Comment extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'user' => [\n            'model' => 'User'\n        ],\n        'text' => [\n            'type' => 'text'\n        ],\n        'files' => [\n            'models' => 'FileAttachment'\n        ]\n    ];\n\n    public function delete()\n    {\n        // Code to handle files related to this comment...\n    }\n}",
            "title": "Doing Cleanup Before Deleting"
        },
        {
            "location": "/documentation/v2/amblend/lifecycle/#convert-a-date-string-from-mm-dd-yyyy-to-yyyy-mm-dd-when-saving",
            "text": "Another area where callbacks could be useful is if you have a date in your model\nthat is stored as a string in the \"mm-dd-yyyy\" format and you need to convert it\nto a \"yyyy-mm-dd\" string for insertion into a database.  And before I give this example, let me just point out that AmBlend is meant to work\nwell with php DateTime objects. If you grab a model using a Repository that\nhas a \"date\" or \"datetime\" database field, that field will automatically get\nconverted into a DateTime object for you when it's populated into your model.\nSimilarly, when you go to save your model, the DateTime will be grabbed as a\n\"yyyy-mm-dd\" string for use with the database\nautomatically - no work needs to be done on your part as a developer.  However, if for whatever reason your model has a date that is being stored as a plain\nstring, and you don't want to convert it into a DateTime object (see next example),\nthen the following example could be useful to you:  class User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'joinedDate' => [\n            'type' => 'varchar'\n        ]\n    ];\n\n    public function beforeSave()\n    {\n        // Save the real value of joinedDate to a temp variable\n        $this->joinedDateTemp = $this->joinedDate;\n\n        // Swap joinedDate from mm-dd-yyyy to yyyy-mm-dd\n        $timestamp = strtotime($this->joinedDate);\n        $this->joinedDate = date('Y-m-d', $timestamp);\n    }\n\n    public function afterSave()\n    {\n        // Swap joinedDate back to its mm-dd-yyyy value.\n        $this->joinedDate = $this->joinedDateTemp;\n\n        // You can optionally clear the temp variable we used.\n        $this->joinedDateTemp = null;\n    }\n}  The above code makes \"joinedDate\" a string of yyyy-mm-dd format right before the\nUser object is saved, and then swaps it back to its original mm-dd-yyyy format\nafter the save is finished.",
            "title": "Convert a Date String from mm-dd-yyyy to yyyy-mm-dd when Saving"
        },
        {
            "location": "/documentation/v2/amblend/lifecycle/#grab-date-in-particular-format",
            "text": "When AmBlend fetches date fields from a database, it converts them into php\nDateTime objects. If you've used DateTime object before, then you probably know\nyou can get their value formatting in a certain way by doing:  echo $someDate->format('m-d-Y');  However, if for some reason you didn't want to have to specify the format\nanytime you display a date, you could utilize the beforeGet() method to always\nhave it return in a particular way:  class User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'joinedDate' => [\n            'type' => 'date'\n        ]\n    ];\n\n    public function beforeGet($prop)\n    {\n        if ($prop == 'joinedDate') {\n            // Save the real value of joinedDate to a temp variable\n            $this->joinedDateTemp = $this->joinedDate;\n\n            // Change the value of joinedDate to a formatted string\n            $this->joinedDate = $this->joinedDate->format('m-d-Y');\n        }\n    }\n\n    public function afterGet($prop, $value)\n    {\n        if ($prop == 'joinedDate') {\n            // Restore joined date.\n            $this->joinedDate = $this->joinedDateTemp;\n        }\n    }\n}",
            "title": "Grab Date in Particular Format"
        },
        {
            "location": "/documentation/v2/amblend/lifecycle/#enforcing-restrictions-on-a-data-member",
            "text": "Another possible use for callbacks could be enforcing some set of restrictions\non a particular data member within a model. For instance, let's say you have an\n\"age\" property on your User model and you want to ensure that only numbers get\nassigned to it. You can do this by utilizing the beforeSet() callback:  class User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'age' => [\n            'type' => 'int'\n        ]\n    ];\n\n    public function beforeSet($prop, $value)\n    {\n        if ($prop == 'age') {\n            if (is_numeric($value) == false) {\n                // Throw some exception or something...\n            }\n        }\n    }\n}",
            "title": "Enforcing Restrictions on a Data Member"
        },
        {
            "location": "/documentation/v2/amblend/database_gen/",
            "text": "Database Generation\n\n\nOnce you have valid AmBlend models defined, you can automatically generate a database\nfor your project using AmBlend's database generation tool.\n\n\n\nPlease note that this tool is a part of the Cora demo project and not in the\nFramework core, so if you went the non-typical route and bypassed using the demo\nproject as a base to build on, you'll need to grab the Amblend.php file out of the\ndemo project's root.\n\n\n\n\nCreate Your Database:\n\n\nIn order to take advantage of automated database creation, you need to make sure\nyou've setup your database configuration. If you haven't done that yet,\n\nClick Here\n to view\ninstructions on doing so. The other thing you'll need (as of me writing this),\nis command line access. In the future, an in-browser\nvisual interface to the database creation tool may be added, but for now it's just\na command line tool.\n\n\n\n\n\nIf on a shared hosting environment:\n  \n\nBecause the database creation feature is a command line tool...\nwhat this means for people who will be hosting their app in\na shared hosting environment without command line access is that you'll need to\ngenerate your database on your local machine and then use a tool (such as PhpMyAdmin)\nto export your generated database into an SQL file you can upload.\n\n\n\n\nTo automatically generate a database based on your model definitions you need\nto do the following:\n\n\n\n\nOpen a Terminal.\n\n\nIf on a Mac, open your Applications, click the Utilities folder, and then\nselect the \"Terminal\" application.\n\n\nIf on a PC, hit your Windows Key + R to open the \"Run\" window, then type\nin \"cmd\" and hit enter.\n\n\nIf on Linux you don't need me to tell you how to do this, but since I can't\nhelp myself I'll mention that Ubuntu and Mint both map the terminal to\nCtrl+Alt+T.\n\n\n\n\n\n\nNavigate to your project's directory.\n\n\nIf you are XAMPP, MAMP, etc, that will likely be wherever you installed\nthat and then in the \"htdocs\" folder within.\n\n\n\n\n\n\nOnce at the root of your project, type \"php Amblend.php dbBuild\" to have\nAmBlend build your database for you.\n\n\n\n\nphp Amblend.php dbBuild\n\n\n\n\n\n    If you get an error about PHP not being a recognized command, that means\n    PHP is not a part of your operating system's PATH. Google \"add php to path\"\n    or something similar if you aren't sure how to do this.\n\n\n\n\nIf all went well, you should see a flurry of output to the console and your database\nshould be ready to go!\n\n\nOf course, if you want to read through the documentation\nin the Models page to fully understand how the mappings work for the purpose of\nsetting your database(s) up manually, you can, although that takes more expertise\nand effort.\n\n\nEmpty a Database\n\n\nSo chances are you'll be making changes to your models throughout development and\nwill need to rebuild your database each time. In order to make use of the automated\ncreation tool again, you'll need to empty out any database(s) you're using by deleting\nall the existing tables. To speed up this process, the database generation tool also\nincludes a command to delete all the existing tables.\n\n\n\n\nThis DELETES any data you have in the database. NEVER EVER use\nthis on a live app. Use this only during development and know you will have to\nre-insert your test data afterwards.\n  \n\n\n\n\nTo make this happen, you need to use the \"dbEmpty\" command and then specify a\ndatabase connection from your project's database config file:\n\n\nphp Amblend.php dbEmpty NameOfConnection\n\n\n\n\nAutomatic Data Loading\n\n\nBy default, when you run the \"dbBuild\" command, AmBlend will look for a file named \n\"data.php\" in the following directory:\n\n\n/includes/data.php\n\n\n\n\nIf it finds a matching file, it will include it after it does the build. The expected\nuse case is \"data.php\" uses Cora's database class to run some Insert commands to load\ndata into the database for you. However, the file can do whatever you want, and you can\nuse whatever tools you want within it (obviously). It's just a way for you to execute \nsome code to populate your database with test data during development.\n\n\nIf you want to include a file other than \"data.php\", you can specify a different file\nafter the build command like so:\n\n\nphp Amblend.php dbBuild myfile.php",
            "title": "Automated DB Creation"
        },
        {
            "location": "/documentation/v2/amblend/database_gen/#database-generation",
            "text": "Once you have valid AmBlend models defined, you can automatically generate a database\nfor your project using AmBlend's database generation tool.  \nPlease note that this tool is a part of the Cora demo project and not in the\nFramework core, so if you went the non-typical route and bypassed using the demo\nproject as a base to build on, you'll need to grab the Amblend.php file out of the\ndemo project's root.",
            "title": "Database Generation"
        },
        {
            "location": "/documentation/v2/amblend/database_gen/#create-your-database",
            "text": "In order to take advantage of automated database creation, you need to make sure\nyou've setup your database configuration. If you haven't done that yet, Click Here  to view\ninstructions on doing so. The other thing you'll need (as of me writing this),\nis command line access. In the future, an in-browser\nvisual interface to the database creation tool may be added, but for now it's just\na command line tool.   If on a shared hosting environment:   \n\nBecause the database creation feature is a command line tool...\nwhat this means for people who will be hosting their app in\na shared hosting environment without command line access is that you'll need to\ngenerate your database on your local machine and then use a tool (such as PhpMyAdmin)\nto export your generated database into an SQL file you can upload.  To automatically generate a database based on your model definitions you need\nto do the following:   Open a Terminal.  If on a Mac, open your Applications, click the Utilities folder, and then\nselect the \"Terminal\" application.  If on a PC, hit your Windows Key + R to open the \"Run\" window, then type\nin \"cmd\" and hit enter.  If on Linux you don't need me to tell you how to do this, but since I can't\nhelp myself I'll mention that Ubuntu and Mint both map the terminal to\nCtrl+Alt+T.    Navigate to your project's directory.  If you are XAMPP, MAMP, etc, that will likely be wherever you installed\nthat and then in the \"htdocs\" folder within.    Once at the root of your project, type \"php Amblend.php dbBuild\" to have\nAmBlend build your database for you.   php Amblend.php dbBuild  \n    If you get an error about PHP not being a recognized command, that means\n    PHP is not a part of your operating system's PATH. Google \"add php to path\"\n    or something similar if you aren't sure how to do this.  If all went well, you should see a flurry of output to the console and your database\nshould be ready to go!  Of course, if you want to read through the documentation\nin the Models page to fully understand how the mappings work for the purpose of\nsetting your database(s) up manually, you can, although that takes more expertise\nand effort.",
            "title": "Create Your Database:"
        },
        {
            "location": "/documentation/v2/amblend/database_gen/#empty-a-database",
            "text": "So chances are you'll be making changes to your models throughout development and\nwill need to rebuild your database each time. In order to make use of the automated\ncreation tool again, you'll need to empty out any database(s) you're using by deleting\nall the existing tables. To speed up this process, the database generation tool also\nincludes a command to delete all the existing tables.   This DELETES any data you have in the database. NEVER EVER use\nthis on a live app. Use this only during development and know you will have to\nre-insert your test data afterwards.     To make this happen, you need to use the \"dbEmpty\" command and then specify a\ndatabase connection from your project's database config file:  php Amblend.php dbEmpty NameOfConnection",
            "title": "Empty a Database"
        },
        {
            "location": "/documentation/v2/amblend/database_gen/#automatic-data-loading",
            "text": "By default, when you run the \"dbBuild\" command, AmBlend will look for a file named \n\"data.php\" in the following directory:  /includes/data.php  If it finds a matching file, it will include it after it does the build. The expected\nuse case is \"data.php\" uses Cora's database class to run some Insert commands to load\ndata into the database for you. However, the file can do whatever you want, and you can\nuse whatever tools you want within it (obviously). It's just a way for you to execute \nsome code to populate your database with test data during development.  If you want to include a file other than \"data.php\", you can specify a different file\nafter the build command like so:  php Amblend.php dbBuild myfile.php",
            "title": "Automatic Data Loading"
        },
        {
            "location": "/documentation/v2/amblend/opt_locking/",
            "text": "Optimistic Locking",
            "title": "Optimistic Locking"
        },
        {
            "location": "/documentation/v2/collections/",
            "text": "Collections\n\n\nCora's Collection class is meant to be a substitute for arrays and gives you much more control over \nyour data. You can either store items of the same type (recommended) or items of mixed type (have to \nbe careful). Under the hood it makes efforts to optimize the fetching and counting of data.\n\n\nIntroduction\n\n\n\n\nFast\n\n\nFlexible\n\n\nEasy\n\n\n\n\ncool examples\n\n\ndirect offset assignment\n\n\nreference speed tests\n\n\nused for closures too\n\n\nCreate From Simple Array\n\n\nHow to turn a basic array of items into a Collection object\n\n\n$c = new \\Cora\\Collection([1,2,3,4,5]);\necho $c[4];             // Returns \"5\". Standard array access format.\necho $c->off4;          // Returns \"5\". Object access syntax.\necho $c->get(4);        // Returns \"5\". Required by PSR-11.\necho $c->offsetGet(4);  // Returns \"5\". Required by ArrayAccess interface.\necho $c[5];             // Returns null. No such offset.\n\n\n\n\nObservation #1:\n\n\n\nNotice that trying to access an offset that doesn't exist returns \"null\" rather than throw an Exception.\nThis was a design choice with the Collection class that has tradeoffs and could potentially trip developers up. \nMake sure to check for a potentially null return as necessary when using this class.\n\n\nObservation #2:\n\n\n\nYou probably noticed that there's a bunch of different ways to access the same data via offsets. This is because \ndifferent interfaces this class tries to be compatible with use different terminology. This first example was just \nfor completeness; in the rest of this document we'll only use the array style and object property access styles.\n\n\nCreate From Associative Array\n\n\nHow to turn a basic array of items into a Collection object\n\n\n$c = new \\Cora\\Collection([\"one\" => 1, \"two\" => 2, \"three\" => 3, \"four\" => 4, \"five\" => 5]);\necho $c[4];             // Returns \"5\". Standard array access format.\necho $c[\"five\"];        // Returns \"5\". Associative array access format.\necho $c->off4;          // Returns \"5\". Object access format.\necho $c->five;          // Returns \"5\". Direct Object access format.\n\n\n\n\nObservation #1:\n\n\n\nNotice you can use either the numerical offset or the associative array key to get the value.\n\n\nObservation #2:\n\n\n\nThe two different Object style access options both work well, but a discussion into the difference \n(internally) will be covered in the section on performance optimizations.\n\n\nPerformance Optimizations\n\n\nThe tricks used to make Cora Collections fast\n\n\nEarlier we had an example (shown again below) in which there was two different ways to access \nsome data in a Collection using an object style syntax.\n\n\n$collection = new \\Cora\\Collection([\"one\" => 1, \"two\" => 2, \"three\" => 3, \"four\" => 4, \"five\" => 5]);\necho $collection->off4;          // Returns \"5\". Object access format.\necho $collection->five;          // Returns \"5\". Direct Object access format.\n\n\n\n\nThis provides a great opportunity to discuss the internal performance optimizations used in the \nCollection class, why both these options work, and the internal difference between them. In the examples \nbelow we'll use this collection as our starting point.\n\n\nOptimization #1: Fast Item Retrieval\n\n\nFirst off, let's do a var_dump on this collection. Don't let this overwhelm you, we'll walk through it below.\n\n\nobject(Cora\\Collection)[121]\n  protected 'parent' => boolean false\n  protected 'signature' => \n    object(stdClass)[122]\n  protected 'signaturesToSingletons' => \n    object(stdClass)[124]\n  protected 'singleton' => \n    object(stdClass)[123]\n      public 'one' => int 1\n      public 'two' => int 2\n      public 'three' => int 3\n      public 'four' => int 4\n      public 'five' => int 5\n  protected 'content' => \n    array (size=5)\n      'one' => int 1\n      'two' => int 2\n      'three' => int 3\n      'four' => int 4\n      'five' => int 5\n  protected 'contentKeys' => \n    array (size=5)\n      0 => string 'one' (length=3)\n      1 => string 'two' (length=3)\n      2 => string 'three' (length=5)\n      3 => string 'four' (length=4)\n      4 => string 'five' (length=4)\n  protected 'size' => int 5\n  protected 'contentModified' => boolean false\n  protected 'returnClosure' => boolean false\n  protected 'sortDirection' => boolean false\n  protected 'sortKey' => boolean false\n\n\n\n\nAlright, so this Collection's class stores resources in one of two data members... those being \n\nSingleton\n or \nSignature\n. \nBoth those variables are instantiated to be PHP stdClass objects (generic objects you can \nstore stuff within). The Singleton object stores any resources which are not \nClosures, so that includes numbers, strings, arrays, objects (excluding Closures), etc. In other words, most \nstuff you would throw in a Collection would end up there. The Signature object \nis exclusively for storing Closures (the name coming from the idea that it holds the \"signatures\" for \nhow to create objects if you're using this class as a dependency injection container).\n\n\nWe can see from our example collection that we didn't define any Closures, so the Signature object is \nempty, but we did add some numbers to our collection, which are being stored in the Singleton object.\n\n\n  protected 'signature' => \n    object(stdClass)[122]\n  protected 'singleton' => \n    object(stdClass)[123]\n      public 'one' => int 1\n      public 'two' => int 2\n      public 'three' => int 3\n      public 'four' => int 4\n      public 'five' => int 5\n\n\n\n\nWhen we access item 5 via its offset name:\n\n\necho $collection->five;\n\n\n\n\nthe Collection class just ends up passing the \nrequest directly to the stdClass object. Access to object properties in PHP is done using a hash table and access \ntimes are in O(1) for efficiency. If you aren't familiar with Big-O notation, this just means the access time is \nconstant no matter how many items you throw in your collection. It doesn't matter if you have a million items in \nthe collection or five, the access time is the same.\n\n\nHowever, the following work slightly differently:\n\n\necho $collection->off4;\necho $collection[4];\necho $collection->get(4);\n\n\n\n\nWhen dealing with a numerical offset, it's our desire to have the same level of efficiency as using the offset name.\nIf we had a very large collection, what we don't want to happen is having to traverse through a million records to \naccess offset 1,000,000. To accomplish this, the class will (only when necessary) calculate the offset keys. You \nmight have noticed this in the original var_dump:\n\n\nprotected 'contentKeys' => \n    array (size=5)\n      0 => string 'one' (length=3)\n      1 => string 'two' (length=3)\n      2 => string 'three' (length=5)\n      3 => string 'four' (length=4)\n      4 => string 'five' (length=4)\n\n\n\n\nSo what happens when we make a request for an item out of the collection using a numerical offset is it grabs the \noffset name using a hash lookup on this contentKeys array. The code looks like this:\n\n\nreturn isset($this->contentKeys[$num]) ? $this->contentKeys[$num] : null;\n\n\n\n\nSo in the case of grabbing item five out of the collection using numerical offset 4, it grabs the key from contentKeys,\nthen uses that to do the direct access for the actual item. This means it has to do two hash lookups to grab the result,\nbut the efficiency stays in O(1). This is how access times are kept low and comparable to standard arrays.\n\n\nOf course, this means we have to compute some data any time the content of our Collection changes. Which brings us to the next optimization...\n\n\nOptimization #2: Data Computed Only When Needed\n\n\nSo without going into all the details, it's been established so far that there's computed data stored within a \nCollection instance. One of the pieces of computed data is the contentKeys lookup that enables efficient lookup \nof collection items no matter if you use a key or an offset number. What's important is that this table gets computed\nonly when necessary. Let's execute the following code:\n\n\n// Add a new item to our collection\n$collection->six = 6;\nvar_dump($collection);\n\n// Retrieve the new item\necho $collection->six;\nvar_dump($collection);\n\n\n\n\nIf you look at the var_dump output of both of the above, you'll see that neither action changed the contentKeys array! This\nis despite the fact that we added a new item to our collection:\n\n\nprotected 'singleton' => \n    object(stdClass)[119]\n      public 'one' => int 1\n      public 'two' => int 2\n      public 'three' => int 3\n      public 'four' => int 4\n      public 'five' => int 5\n      public 'six' => int 6\n  protected 'contentKeys' => \n    array (size=5)\n      0 => string 'one' (length=3)\n      1 => string 'two' (length=3)\n      2 => string 'three' (length=5)\n      3 => string 'four' (length=4)\n      4 => string 'five' (length=4)\n\n\n\n\nThe reason for this is that the keys are NOT recomputed automatically when you add a new item to the collection. Same goes for \ngrabbing the item by its name. Neither of those actions required use of the key lookup array, and so the work to recompute it \nwasn't bothered with. When a collection is modified, is simply sets a flag internally, and when an action is taken that requires \ndata be recomputed, THEN it will do it.\n\n\nLet's try grabbing the new item 6 by numerical offset. That should cause the keys to get recomputed.\n\n\necho $collection[5];\n\n\n\n\nNow looking at a fresh var_dump of our collection it looks like this:\n\n\nprotected 'singleton' => \n    object(stdClass)[119]\n      public 'one' => int 1\n      public 'two' => int 2\n      public 'three' => int 3\n      public 'four' => int 4\n      public 'five' => int 5\n      public 'six' => int 6\n  protected 'contentKeys' => \n    array (size=6)\n      0 => string 'one' (length=3)\n      1 => string 'two' (length=3)\n      2 => string 'three' (length=5)\n      3 => string 'four' (length=4)\n      4 => string 'five' (length=4)\n      5 => string 'six' (length=3)\n\n\n\n\nAnd sure enough, there's our new item in the keys array.\n\n\nSo to summarize, computed data should only get re-computed when necessary and will get avoided for efficiency's sake \nwhenever possible.\n\n\nUsing Data Keys\n\n\n$c = new \\Cora\\Collection([\n    [\"name\" => \"Jake\", \"age\" => 33],\n    [\"name\" => \"Bob\", \"age\" => 42]\n], 'name');\necho $c['Bob']['age'];  // Returns \"5\". Standard array access format.\necho $c->Bob['age'];    // Returns \"5\". Object access syntax.\n\n\n\n\nWhy Object Syntax?\n\n\n$c = new \\Cora\\Collection([\n    [\"name\" => \"Jake\", \"age\" => 33],\n    [\"name\" => \"Bob\", \"age\" => 42]\n], 'name');\necho $c->Bob->age;          // Returns \"5\". Object access format.\n\n\n\n\nWarning About Mixing Closures With Other Types\n\n\nClosures won't be mixed with Singletons in the order they were added when mixed together to form\nthe \"content\" array. So $object->off5 might not give you the expected result. When mixing Closures \nwith solid values, you need to use named offsets such as $object->repository.",
            "title": "Collection Class"
        },
        {
            "location": "/documentation/v2/collections/#collections",
            "text": "Cora's Collection class is meant to be a substitute for arrays and gives you much more control over \nyour data. You can either store items of the same type (recommended) or items of mixed type (have to \nbe careful). Under the hood it makes efforts to optimize the fetching and counting of data.",
            "title": "Collections"
        },
        {
            "location": "/documentation/v2/collections/#introduction",
            "text": "Fast  Flexible  Easy   cool examples  direct offset assignment  reference speed tests  used for closures too",
            "title": "Introduction"
        },
        {
            "location": "/documentation/v2/collections/#create-from-simple-array",
            "text": "How to turn a basic array of items into a Collection object  $c = new \\Cora\\Collection([1,2,3,4,5]);\necho $c[4];             // Returns \"5\". Standard array access format.\necho $c->off4;          // Returns \"5\". Object access syntax.\necho $c->get(4);        // Returns \"5\". Required by PSR-11.\necho $c->offsetGet(4);  // Returns \"5\". Required by ArrayAccess interface.\necho $c[5];             // Returns null. No such offset.  Observation #1:  Notice that trying to access an offset that doesn't exist returns \"null\" rather than throw an Exception.\nThis was a design choice with the Collection class that has tradeoffs and could potentially trip developers up. \nMake sure to check for a potentially null return as necessary when using this class.  Observation #2:  You probably noticed that there's a bunch of different ways to access the same data via offsets. This is because \ndifferent interfaces this class tries to be compatible with use different terminology. This first example was just \nfor completeness; in the rest of this document we'll only use the array style and object property access styles.",
            "title": "Create From Simple Array"
        },
        {
            "location": "/documentation/v2/collections/#create-from-associative-array",
            "text": "How to turn a basic array of items into a Collection object  $c = new \\Cora\\Collection([\"one\" => 1, \"two\" => 2, \"three\" => 3, \"four\" => 4, \"five\" => 5]);\necho $c[4];             // Returns \"5\". Standard array access format.\necho $c[\"five\"];        // Returns \"5\". Associative array access format.\necho $c->off4;          // Returns \"5\". Object access format.\necho $c->five;          // Returns \"5\". Direct Object access format.  Observation #1:  Notice you can use either the numerical offset or the associative array key to get the value.  Observation #2:  The two different Object style access options both work well, but a discussion into the difference \n(internally) will be covered in the section on performance optimizations.",
            "title": "Create From Associative Array"
        },
        {
            "location": "/documentation/v2/collections/#performance-optimizations",
            "text": "The tricks used to make Cora Collections fast  Earlier we had an example (shown again below) in which there was two different ways to access \nsome data in a Collection using an object style syntax.  $collection = new \\Cora\\Collection([\"one\" => 1, \"two\" => 2, \"three\" => 3, \"four\" => 4, \"five\" => 5]);\necho $collection->off4;          // Returns \"5\". Object access format.\necho $collection->five;          // Returns \"5\". Direct Object access format.  This provides a great opportunity to discuss the internal performance optimizations used in the \nCollection class, why both these options work, and the internal difference between them. In the examples \nbelow we'll use this collection as our starting point.",
            "title": "Performance Optimizations"
        },
        {
            "location": "/documentation/v2/collections/#optimization-1-fast-item-retrieval",
            "text": "First off, let's do a var_dump on this collection. Don't let this overwhelm you, we'll walk through it below.  object(Cora\\Collection)[121]\n  protected 'parent' => boolean false\n  protected 'signature' => \n    object(stdClass)[122]\n  protected 'signaturesToSingletons' => \n    object(stdClass)[124]\n  protected 'singleton' => \n    object(stdClass)[123]\n      public 'one' => int 1\n      public 'two' => int 2\n      public 'three' => int 3\n      public 'four' => int 4\n      public 'five' => int 5\n  protected 'content' => \n    array (size=5)\n      'one' => int 1\n      'two' => int 2\n      'three' => int 3\n      'four' => int 4\n      'five' => int 5\n  protected 'contentKeys' => \n    array (size=5)\n      0 => string 'one' (length=3)\n      1 => string 'two' (length=3)\n      2 => string 'three' (length=5)\n      3 => string 'four' (length=4)\n      4 => string 'five' (length=4)\n  protected 'size' => int 5\n  protected 'contentModified' => boolean false\n  protected 'returnClosure' => boolean false\n  protected 'sortDirection' => boolean false\n  protected 'sortKey' => boolean false  Alright, so this Collection's class stores resources in one of two data members... those being  Singleton  or  Signature . \nBoth those variables are instantiated to be PHP stdClass objects (generic objects you can \nstore stuff within). The Singleton object stores any resources which are not \nClosures, so that includes numbers, strings, arrays, objects (excluding Closures), etc. In other words, most \nstuff you would throw in a Collection would end up there. The Signature object \nis exclusively for storing Closures (the name coming from the idea that it holds the \"signatures\" for \nhow to create objects if you're using this class as a dependency injection container).  We can see from our example collection that we didn't define any Closures, so the Signature object is \nempty, but we did add some numbers to our collection, which are being stored in the Singleton object.    protected 'signature' => \n    object(stdClass)[122]\n  protected 'singleton' => \n    object(stdClass)[123]\n      public 'one' => int 1\n      public 'two' => int 2\n      public 'three' => int 3\n      public 'four' => int 4\n      public 'five' => int 5  When we access item 5 via its offset name:  echo $collection->five;  the Collection class just ends up passing the \nrequest directly to the stdClass object. Access to object properties in PHP is done using a hash table and access \ntimes are in O(1) for efficiency. If you aren't familiar with Big-O notation, this just means the access time is \nconstant no matter how many items you throw in your collection. It doesn't matter if you have a million items in \nthe collection or five, the access time is the same.  However, the following work slightly differently:  echo $collection->off4;\necho $collection[4];\necho $collection->get(4);  When dealing with a numerical offset, it's our desire to have the same level of efficiency as using the offset name.\nIf we had a very large collection, what we don't want to happen is having to traverse through a million records to \naccess offset 1,000,000. To accomplish this, the class will (only when necessary) calculate the offset keys. You \nmight have noticed this in the original var_dump:  protected 'contentKeys' => \n    array (size=5)\n      0 => string 'one' (length=3)\n      1 => string 'two' (length=3)\n      2 => string 'three' (length=5)\n      3 => string 'four' (length=4)\n      4 => string 'five' (length=4)  So what happens when we make a request for an item out of the collection using a numerical offset is it grabs the \noffset name using a hash lookup on this contentKeys array. The code looks like this:  return isset($this->contentKeys[$num]) ? $this->contentKeys[$num] : null;  So in the case of grabbing item five out of the collection using numerical offset 4, it grabs the key from contentKeys,\nthen uses that to do the direct access for the actual item. This means it has to do two hash lookups to grab the result,\nbut the efficiency stays in O(1). This is how access times are kept low and comparable to standard arrays.  Of course, this means we have to compute some data any time the content of our Collection changes. Which brings us to the next optimization...",
            "title": "Optimization #1: Fast Item Retrieval"
        },
        {
            "location": "/documentation/v2/collections/#optimization-2-data-computed-only-when-needed",
            "text": "So without going into all the details, it's been established so far that there's computed data stored within a \nCollection instance. One of the pieces of computed data is the contentKeys lookup that enables efficient lookup \nof collection items no matter if you use a key or an offset number. What's important is that this table gets computed\nonly when necessary. Let's execute the following code:  // Add a new item to our collection\n$collection->six = 6;\nvar_dump($collection);\n\n// Retrieve the new item\necho $collection->six;\nvar_dump($collection);  If you look at the var_dump output of both of the above, you'll see that neither action changed the contentKeys array! This\nis despite the fact that we added a new item to our collection:  protected 'singleton' => \n    object(stdClass)[119]\n      public 'one' => int 1\n      public 'two' => int 2\n      public 'three' => int 3\n      public 'four' => int 4\n      public 'five' => int 5\n      public 'six' => int 6\n  protected 'contentKeys' => \n    array (size=5)\n      0 => string 'one' (length=3)\n      1 => string 'two' (length=3)\n      2 => string 'three' (length=5)\n      3 => string 'four' (length=4)\n      4 => string 'five' (length=4)  The reason for this is that the keys are NOT recomputed automatically when you add a new item to the collection. Same goes for \ngrabbing the item by its name. Neither of those actions required use of the key lookup array, and so the work to recompute it \nwasn't bothered with. When a collection is modified, is simply sets a flag internally, and when an action is taken that requires \ndata be recomputed, THEN it will do it.  Let's try grabbing the new item 6 by numerical offset. That should cause the keys to get recomputed.  echo $collection[5];  Now looking at a fresh var_dump of our collection it looks like this:  protected 'singleton' => \n    object(stdClass)[119]\n      public 'one' => int 1\n      public 'two' => int 2\n      public 'three' => int 3\n      public 'four' => int 4\n      public 'five' => int 5\n      public 'six' => int 6\n  protected 'contentKeys' => \n    array (size=6)\n      0 => string 'one' (length=3)\n      1 => string 'two' (length=3)\n      2 => string 'three' (length=5)\n      3 => string 'four' (length=4)\n      4 => string 'five' (length=4)\n      5 => string 'six' (length=3)  And sure enough, there's our new item in the keys array.  So to summarize, computed data should only get re-computed when necessary and will get avoided for efficiency's sake \nwhenever possible.",
            "title": "Optimization #2: Data Computed Only When Needed"
        },
        {
            "location": "/documentation/v2/collections/#using-data-keys",
            "text": "$c = new \\Cora\\Collection([\n    [\"name\" => \"Jake\", \"age\" => 33],\n    [\"name\" => \"Bob\", \"age\" => 42]\n], 'name');\necho $c['Bob']['age'];  // Returns \"5\". Standard array access format.\necho $c->Bob['age'];    // Returns \"5\". Object access syntax.",
            "title": "Using Data Keys"
        },
        {
            "location": "/documentation/v2/collections/#why-object-syntax",
            "text": "$c = new \\Cora\\Collection([\n    [\"name\" => \"Jake\", \"age\" => 33],\n    [\"name\" => \"Bob\", \"age\" => 42]\n], 'name');\necho $c->Bob->age;          // Returns \"5\". Object access format.",
            "title": "Why Object Syntax?"
        },
        {
            "location": "/documentation/v2/collections/#warning-about-mixing-closures-with-other-types",
            "text": "Closures won't be mixed with Singletons in the order they were added when mixed together to form\nthe \"content\" array. So $object->off5 might not give you the expected result. When mixing Closures \nwith solid values, you need to use named offsets such as $object->repository.",
            "title": "Warning About Mixing Closures With Other Types"
        },
        {
            "location": "/documentation/v2/databaseclass/overview/",
            "text": "Cora's Database class\n\n\nNOTE: IF YOU ARE GOING TO BE GRABBING CLASS RECORDS FROM A DATABASE, YOU SHOULD CONSIDER USING THE\nAMBLEND ORM, NOT THIS LOWER LEVEL DATABASE CLASS.\n\n\nIn a nutshell, Cora's Database class acts as a \nData Access Object\n. It\noffers you a simple way to interact with a database, without having to worry about implementation specific details for different database types.\nThe ELI5 explanation goes like this: \n\nSay you build an application that uses Database-A, and Database-A uses commands that look like the following:\n\n\nSELECT first_name FROM users WHERE id=12;\n\n\n\n\nHowever, one day your boss says to you that he wants you to switch over to using Database-B. Database-B however uses a different\ncommand syntax though that looks something like this:\n\n\ndb.users.find( { id: 12 }, { first_name: 1 } );\n\n\n\n\nWHOA NELLY! If you haven't been using a Data Access Object, then the fact that this new database uses a different syntax could be devastating.\nYou might literally have to rewrite HUGE portions of your application to make everything work with this new format. NOT GOOD! This is where\na DAO comes in handy. Let's say you've written all your database queries in your application using a DAO and it has its own format that looks something like so:\n\n\n$db ->select('first_name')\n    ->from('users')\n    ->where('id', 12)\n    ->exec();\n\n\n\n\nIf your app is using this DAO, now when your boss tells you to start using database-B, all that you need to do is write translation instructions (aka an 'adaptor') for your DAO\nso it knows how to turn the above into the instuction format database-B uses (or more likely, someone else has already written an adaptor, can you just have to download it).\nIn this way, Cora's Database class acts as an abstraction layer that helps separate your application from any one specific database implementation.\n\n\nHow it's Implemented\n\n\nWhen you construct an SQL statement using the Database class' query building methods, the resulting query parameters are stored as\nraw data within the Database class (mostly stored in arrays). In order to take that raw data and then execute a query, you have to\nutilize an adaptor that extends the Database class and implements the exec() method. The adaptor is responsible for taking that raw\ndata and translating it into the format required by its associated Database in order to execute the query.\n\n\nCurrently Supported Databases\n\n\nCora currently has adaptor classes for:\n\n\n\n\nMySQL (Db_MySQL.php)\n\n\n\n\nIntroduction\n\n\nBelow is a basic example that grabs and echoes the name of all the users in a users table who's type is 'admin'.\n\n\n// Create Database object with adaptor\n$db = new \\Cora\\Db_MySQL();\n\n// Create query\n$db ->select('name')\n    ->from('users')\n    ->where('type', 'admin');\n\n// Execute query and get returned result.\n$query = $db->exec();\n\n// Print all the names\nforeach($query->fetchAll() as $user) {\n    echo $user['name'];\n}\n\n\n\n\nAs you probably see, the basic formula is you create an instance of a database adaptor (Db_MySQL extends Database), construct\nsome query using the Database class' methods, then call the exec() function to execute the query and return any expected result.\nQuery methods can be chained together as you see above too.\n\n\nSecurity\n\n\nThe Database class and its query building methods are extremely powerful, and as such, there are dangerous scenarios of which you need\nto be aware! Column VALUES are sanitized to protect your app from SQL Injection attacks. However, COLUMN name parameters and OPERATOR parameters (=, >, <, IN, etc)\nare NOT sanitized!!! For this reason you should never under any circumstance pass in a value you receive from a user into one of those fields!\nDoing so will leave a huge security hole in your app that an attacker could take advantage of to destroy or compromise everything.\n\n\nBelow is a \nSAFE\n query:\n\n\n// Create and execute query\n$db ->select('name')\n    ->from('users')\n    ->where('name', $_POST['userName']);\n$query = $db->exec();\n\n\n\n\nBelow is an \nEXTREMELY UNSAFE\n query:\n\n\n// Create and execute query\n$db ->select('name')\n    ->from('users')\n    ->where($_POST['column'], $_POST['value']);\n$query = $db->exec();\n\n\n\n\nMethods\n\n\nUtility Methods\n\n\nThe following methods are available when creating any type of query:\n\n\n\n\ngetQuery()\n (returns the compiled query)\n\n\nexec()\n (executes the query that's been constructed and calls Reset)\n\n\nreset()\n (resets the Database class so it's ready for a new query)\n\n\n\n\nSELECT Statements\n\n\nThe methods available when creating a select statement are:\n\n\n\n\nselect()\n\n\ndistinct()\n\n\nfrom()\n\n\njoin()\n\n\nwhere()\n\n\norWhere()\n\n\nin()\n\n\ngroupBy()\n\n\nhaving()\n\n\norHaving()\n\n\norderBy()\n\n\nlimit()\n\n\noffset()\n\n\n\n\nUPDATE Statements\n\n\nThe methods available when creating an update statement are:\n\n\n\n\nupdate()\n\n\nset()\n\n\nwhere()\n\n\n\n\nINSERT Statements\n\n\nThe methods available when creating an insert statement are:\n\n\n\n\ninsert()\n\n\ninto()\n\n\nvalues()\n\n\n\n\nDELETE Statements\n\n\nThe methods available when creating an delete statement are:\n\n\n\n\ndelete()\n\n\nfrom()\n\n\nwhere()\n\n\n\n\nCREATE Statements\n\n\nThe methods available when creating an create statement are:\n\n\n\n\ncreate()\n\n\nfield()\n\n\nprimaryKey()\n\n\nforeignKey()\n\n\n\n\nAdvanced Examples\n\n\nCreating a table:\n\n\n$db ->create('locations')\n            ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n            ->field('name', 'varchar(255)')\n            ->field('address', 'varchar(255)')\n            ->field('user_id', 'int')\n            ->primaryKey('id')\n            ->foreignKey('user_id', 'users', 'id');\n$db->exec();\n\n\n\n\nInserting data:\n\n\n$db ->insert('name, email, type')\n    ->into('users')\n    ->values([\n        ['bob', \"bob's@gmail.com\", 'admin'],\n        ['john', 'john@gmail.com', 'admin'],\n        ['john', 'john@gmail.com', 'scrub'],\n        ['sally', 'sally@yahoo.com', 'user'],\n        ['susan', 'susan@aol.com', 'user']\n    ])\n    ->exec();\n\n\n\n\nMore advanced Where statement:\n\n\n$db ->select('id')\n    ->distinct()\n    ->from('users')\n    ->from('profile')\n    ->where([\n        ['created_time', '>=', '2016-01-01', 'OR'],\n        ['name', 'LIKE', 's%']\n    ])\n    ->where([\n        ['type', '=', 'admin', 'OR'],\n        ['type', '=', 'moderator']\n    ])\n    ->exec();\n\n\n\n\nMega Query:\n\n\n$tables = array('table1', 'table2', 'table3');\n$fields = array('id', 'name', 'email');\n$conditions = array(\n    ['id', '>', '100', 'OR'],\n    ['name', 'LIKE', '%s']\n);\n\n$groupBys = ['field1', 'field2', 'field3'];\n\n$havings = array(\n    ['amount', '>', '1000'],\n    ['savings', '>', '100']\n);\n\n$orHavings = array(\n    ['amount2', '>', '1000'],\n    ['savings2', '>', '100']\n);\n\n$joinConditions = array(\n    ['Orders.customerID', '=', 'Customers.customerID'],\n    ['User.type', '=', 'Customer.type']\n);\n\n\n$db = new Cora\\Db_MySQL();\n\necho $db->select($fields)\n        ->from($tables)\n        ->join('customers', $joinConditions, 'OUTER')\n        ->where($conditions)\n        ->orWhere($conditions)\n        ->in('name', 'value1, value2, value3')\n        ->in('name', 'SELECT * FROM users')\n        ->in('type', $groupBys)\n        ->groupBy($groupBys)\n        ->having($havings)\n        ->orHaving($orHavings)\n        ->having($orHavings)\n        ->orderBy('name', 'DESC')\n        ->orderBy('type', 'ASC')\n        ->limit(10)\n        ->offset(20)\n        ->getQuery();",
            "title": "Overview"
        },
        {
            "location": "/documentation/v2/databaseclass/overview/#coras-database-class",
            "text": "NOTE: IF YOU ARE GOING TO BE GRABBING CLASS RECORDS FROM A DATABASE, YOU SHOULD CONSIDER USING THE\nAMBLEND ORM, NOT THIS LOWER LEVEL DATABASE CLASS.  In a nutshell, Cora's Database class acts as a  Data Access Object . It\noffers you a simple way to interact with a database, without having to worry about implementation specific details for different database types.\nThe ELI5 explanation goes like this:  \nSay you build an application that uses Database-A, and Database-A uses commands that look like the following:  SELECT first_name FROM users WHERE id=12;  However, one day your boss says to you that he wants you to switch over to using Database-B. Database-B however uses a different\ncommand syntax though that looks something like this:  db.users.find( { id: 12 }, { first_name: 1 } );  WHOA NELLY! If you haven't been using a Data Access Object, then the fact that this new database uses a different syntax could be devastating.\nYou might literally have to rewrite HUGE portions of your application to make everything work with this new format. NOT GOOD! This is where\na DAO comes in handy. Let's say you've written all your database queries in your application using a DAO and it has its own format that looks something like so:  $db ->select('first_name')\n    ->from('users')\n    ->where('id', 12)\n    ->exec();  If your app is using this DAO, now when your boss tells you to start using database-B, all that you need to do is write translation instructions (aka an 'adaptor') for your DAO\nso it knows how to turn the above into the instuction format database-B uses (or more likely, someone else has already written an adaptor, can you just have to download it).\nIn this way, Cora's Database class acts as an abstraction layer that helps separate your application from any one specific database implementation.",
            "title": "Cora's Database class"
        },
        {
            "location": "/documentation/v2/databaseclass/overview/#how-its-implemented",
            "text": "When you construct an SQL statement using the Database class' query building methods, the resulting query parameters are stored as\nraw data within the Database class (mostly stored in arrays). In order to take that raw data and then execute a query, you have to\nutilize an adaptor that extends the Database class and implements the exec() method. The adaptor is responsible for taking that raw\ndata and translating it into the format required by its associated Database in order to execute the query.",
            "title": "How it's Implemented"
        },
        {
            "location": "/documentation/v2/databaseclass/overview/#currently-supported-databases",
            "text": "Cora currently has adaptor classes for:   MySQL (Db_MySQL.php)",
            "title": "Currently Supported Databases"
        },
        {
            "location": "/documentation/v2/databaseclass/overview/#introduction",
            "text": "Below is a basic example that grabs and echoes the name of all the users in a users table who's type is 'admin'.  // Create Database object with adaptor\n$db = new \\Cora\\Db_MySQL();\n\n// Create query\n$db ->select('name')\n    ->from('users')\n    ->where('type', 'admin');\n\n// Execute query and get returned result.\n$query = $db->exec();\n\n// Print all the names\nforeach($query->fetchAll() as $user) {\n    echo $user['name'];\n}  As you probably see, the basic formula is you create an instance of a database adaptor (Db_MySQL extends Database), construct\nsome query using the Database class' methods, then call the exec() function to execute the query and return any expected result.\nQuery methods can be chained together as you see above too.",
            "title": "Introduction"
        },
        {
            "location": "/documentation/v2/databaseclass/overview/#security",
            "text": "The Database class and its query building methods are extremely powerful, and as such, there are dangerous scenarios of which you need\nto be aware! Column VALUES are sanitized to protect your app from SQL Injection attacks. However, COLUMN name parameters and OPERATOR parameters (=, >, <, IN, etc)\nare NOT sanitized!!! For this reason you should never under any circumstance pass in a value you receive from a user into one of those fields!\nDoing so will leave a huge security hole in your app that an attacker could take advantage of to destroy or compromise everything.  Below is a  SAFE  query:  // Create and execute query\n$db ->select('name')\n    ->from('users')\n    ->where('name', $_POST['userName']);\n$query = $db->exec();  Below is an  EXTREMELY UNSAFE  query:  // Create and execute query\n$db ->select('name')\n    ->from('users')\n    ->where($_POST['column'], $_POST['value']);\n$query = $db->exec();",
            "title": "Security"
        },
        {
            "location": "/documentation/v2/databaseclass/overview/#methods",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/documentation/v2/databaseclass/overview/#utility-methods",
            "text": "The following methods are available when creating any type of query:   getQuery()  (returns the compiled query)  exec()  (executes the query that's been constructed and calls Reset)  reset()  (resets the Database class so it's ready for a new query)",
            "title": "Utility Methods"
        },
        {
            "location": "/documentation/v2/databaseclass/overview/#select-statements",
            "text": "The methods available when creating a select statement are:   select()  distinct()  from()  join()  where()  orWhere()  in()  groupBy()  having()  orHaving()  orderBy()  limit()  offset()",
            "title": "SELECT Statements"
        },
        {
            "location": "/documentation/v2/databaseclass/overview/#update-statements",
            "text": "The methods available when creating an update statement are:   update()  set()  where()",
            "title": "UPDATE Statements"
        },
        {
            "location": "/documentation/v2/databaseclass/overview/#insert-statements",
            "text": "The methods available when creating an insert statement are:   insert()  into()  values()",
            "title": "INSERT Statements"
        },
        {
            "location": "/documentation/v2/databaseclass/overview/#delete-statements",
            "text": "The methods available when creating an delete statement are:   delete()  from()  where()",
            "title": "DELETE Statements"
        },
        {
            "location": "/documentation/v2/databaseclass/overview/#create-statements",
            "text": "The methods available when creating an create statement are:   create()  field()  primaryKey()  foreignKey()",
            "title": "CREATE Statements"
        },
        {
            "location": "/documentation/v2/databaseclass/overview/#advanced-examples",
            "text": "Creating a table:  $db ->create('locations')\n            ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n            ->field('name', 'varchar(255)')\n            ->field('address', 'varchar(255)')\n            ->field('user_id', 'int')\n            ->primaryKey('id')\n            ->foreignKey('user_id', 'users', 'id');\n$db->exec();  Inserting data:  $db ->insert('name, email, type')\n    ->into('users')\n    ->values([\n        ['bob', \"bob's@gmail.com\", 'admin'],\n        ['john', 'john@gmail.com', 'admin'],\n        ['john', 'john@gmail.com', 'scrub'],\n        ['sally', 'sally@yahoo.com', 'user'],\n        ['susan', 'susan@aol.com', 'user']\n    ])\n    ->exec();  More advanced Where statement:  $db ->select('id')\n    ->distinct()\n    ->from('users')\n    ->from('profile')\n    ->where([\n        ['created_time', '>=', '2016-01-01', 'OR'],\n        ['name', 'LIKE', 's%']\n    ])\n    ->where([\n        ['type', '=', 'admin', 'OR'],\n        ['type', '=', 'moderator']\n    ])\n    ->exec();  Mega Query:  $tables = array('table1', 'table2', 'table3');\n$fields = array('id', 'name', 'email');\n$conditions = array(\n    ['id', '>', '100', 'OR'],\n    ['name', 'LIKE', '%s']\n);\n\n$groupBys = ['field1', 'field2', 'field3'];\n\n$havings = array(\n    ['amount', '>', '1000'],\n    ['savings', '>', '100']\n);\n\n$orHavings = array(\n    ['amount2', '>', '1000'],\n    ['savings2', '>', '100']\n);\n\n$joinConditions = array(\n    ['Orders.customerID', '=', 'Customers.customerID'],\n    ['User.type', '=', 'Customer.type']\n);\n\n\n$db = new Cora\\Db_MySQL();\n\necho $db->select($fields)\n        ->from($tables)\n        ->join('customers', $joinConditions, 'OUTER')\n        ->where($conditions)\n        ->orWhere($conditions)\n        ->in('name', 'value1, value2, value3')\n        ->in('name', 'SELECT * FROM users')\n        ->in('type', $groupBys)\n        ->groupBy($groupBys)\n        ->having($havings)\n        ->orHaving($orHavings)\n        ->having($orHavings)\n        ->orderBy('name', 'DESC')\n        ->orderBy('type', 'ASC')\n        ->limit(10)\n        ->offset(20)\n        ->getQuery();",
            "title": "Advanced Examples"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_utility/",
            "text": "Utility Database Class Methods\n\n\ntable() method\n\n\nThe method for selecting a table you want to perform an operation on (whether selecting, updating, inserting, or deleting)\nis to use table(). However, in order to let developers construct queries in the same format they are used to when writing\nraw SQL, there are several aliases to this method.\n\n\nPurpose:\n \n\nThe table() method is for selecting the table(s) you want to perform an action on.\n\n\nFormat:\n  \n\n\ntable(table_name | array(table_name1, table_name2, ...))\n\n\n\n\nUsage and Aliases:\n \n\nAnywhere you would use a from(), into(), or update() method you can use this method instead.\n\n\nExamples:\n   \n\n\n// A SELECT query\n$db ->table('users')\n    ->select('*')\n    ->join('members', [['users.user_id', '=', 'members.user_id']])\n    ->orderBy('users.user_id', 'ASC')\n    ->exec();\n\n// An UPDATE query\n$db ->table('users')\n    ->set('name', 'John')\n    ->where('name', 'Randy', '>')\n    ->getQuery();        \n\n// An INSERT query\n$db ->table('users')\n    ->insert('name, email, type')\n    ->values([['bob', 'bob@gmail.com', 'admin'], ['john', 'john@gmail.com', 'admin']])\n    ->values(['bob', 'bob@gmail.com', 'admin'])\n    ->exec();\n\n\n\n\ngetQuery() method\n\n\nPurpose:\n \n\nThe getQuery() method returns the query that will be executed on the database. This is useful when trying\nto troubleshoot if you want to see what Cora's Database class is actually executing.\n\nFormat:\n  \n\n\ngetQuery()\n\n\n\n\nExamples:\n  \n\n\n// Constuct a CREATE table query, then echo it out (does not execute it)\necho $db->create('locations')\n        ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n        ->field('name', 'varchar(255)')\n        ->field('address', 'varchar(255)')\n        ->field('user_id', 'int')\n        ->primaryKey('id')\n        ->foreignKey('user_id', 'users', 'id')\n        ->getQuery();\n\n\n\n\nexec() method\n\n\nPurpose:\n \n\nThe exec() method executes a query, resets the database class by calling reset(), and returns any data if there's\ndata to return.\n\n\nFormat:\n  \n\n\nexec()\n\n\n\n\nExamples:\n  \n\n\n// Constuct a CREATE table query, then execute it.\n$db ->create('locations')\n    ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n    ->field('name', 'varchar(255)')\n    ->field('address', 'varchar(255)')\n    ->field('user_id', 'int')\n    ->primaryKey('id')\n    ->foreignKey('user_id', 'users', 'id')\n    ->exec();\n\n\n\n\nreset() method\n\n\nPurpose:\n \n\nThe reset() method clears out the stored data in the database class so that a new query can then be constructed.\n\nFormat:\n  \n\n\nreset()\n\n\n\n\nExamples:\n  \n\n\n// Constuct a CREATE table query, then echo it out (does not execute it)\necho $db->create('locations')\n        ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n        ->field('name', 'varchar(255)')\n        ->field('address', 'varchar(255)')\n        ->field('user_id', 'int')\n        ->primaryKey('id')\n        ->foreignKey('user_id', 'users', 'id')\n        ->getQuery();\n\n/* \n    Before we can start working on a 2nd query, we either need to execute the one we just constructed\n    (which clears out the stored data), OR we need to manually clear out the data if we don't plan\n    on executing the query.\n*/\n// Clear out the stored data from the first query we constructed.\n$db->reset()\n\n// Start constructing a 2nd query...\necho $db->select('*')\n        ->from('users')\n        ->join('members', [['users.user_id', '=', 'members.user_id']])\n        ->orderBy('users.user_id', 'ASC')\n        ->getQuery();",
            "title": "Utility Methods"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_utility/#utility-database-class-methods",
            "text": "",
            "title": "Utility Database Class Methods"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_utility/#table-method",
            "text": "The method for selecting a table you want to perform an operation on (whether selecting, updating, inserting, or deleting)\nis to use table(). However, in order to let developers construct queries in the same format they are used to when writing\nraw SQL, there are several aliases to this method.  Purpose:   \nThe table() method is for selecting the table(s) you want to perform an action on.  Format:     table(table_name | array(table_name1, table_name2, ...))  Usage and Aliases:   \nAnywhere you would use a from(), into(), or update() method you can use this method instead.  Examples:      // A SELECT query\n$db ->table('users')\n    ->select('*')\n    ->join('members', [['users.user_id', '=', 'members.user_id']])\n    ->orderBy('users.user_id', 'ASC')\n    ->exec();\n\n// An UPDATE query\n$db ->table('users')\n    ->set('name', 'John')\n    ->where('name', 'Randy', '>')\n    ->getQuery();        \n\n// An INSERT query\n$db ->table('users')\n    ->insert('name, email, type')\n    ->values([['bob', 'bob@gmail.com', 'admin'], ['john', 'john@gmail.com', 'admin']])\n    ->values(['bob', 'bob@gmail.com', 'admin'])\n    ->exec();",
            "title": "table() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_utility/#getquery-method",
            "text": "Purpose:   \nThe getQuery() method returns the query that will be executed on the database. This is useful when trying\nto troubleshoot if you want to see what Cora's Database class is actually executing. Format:     getQuery()  Examples:     // Constuct a CREATE table query, then echo it out (does not execute it)\necho $db->create('locations')\n        ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n        ->field('name', 'varchar(255)')\n        ->field('address', 'varchar(255)')\n        ->field('user_id', 'int')\n        ->primaryKey('id')\n        ->foreignKey('user_id', 'users', 'id')\n        ->getQuery();",
            "title": "getQuery() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_utility/#exec-method",
            "text": "Purpose:   \nThe exec() method executes a query, resets the database class by calling reset(), and returns any data if there's\ndata to return.  Format:     exec()  Examples:     // Constuct a CREATE table query, then execute it.\n$db ->create('locations')\n    ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n    ->field('name', 'varchar(255)')\n    ->field('address', 'varchar(255)')\n    ->field('user_id', 'int')\n    ->primaryKey('id')\n    ->foreignKey('user_id', 'users', 'id')\n    ->exec();",
            "title": "exec() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_utility/#reset-method",
            "text": "Purpose:   \nThe reset() method clears out the stored data in the database class so that a new query can then be constructed. Format:     reset()  Examples:     // Constuct a CREATE table query, then echo it out (does not execute it)\necho $db->create('locations')\n        ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n        ->field('name', 'varchar(255)')\n        ->field('address', 'varchar(255)')\n        ->field('user_id', 'int')\n        ->primaryKey('id')\n        ->foreignKey('user_id', 'users', 'id')\n        ->getQuery();\n\n/* \n    Before we can start working on a 2nd query, we either need to execute the one we just constructed\n    (which clears out the stored data), OR we need to manually clear out the data if we don't plan\n    on executing the query.\n*/\n// Clear out the stored data from the first query we constructed.\n$db->reset()\n\n// Start constructing a 2nd query...\necho $db->select('*')\n        ->from('users')\n        ->join('members', [['users.user_id', '=', 'members.user_id']])\n        ->orderBy('users.user_id', 'ASC')\n        ->getQuery();",
            "title": "reset() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_select/",
            "text": "Database Class Methods\n\n\nselect() method\n\n\nPurpose:\n \n\nThe select() method is for choosing the columns you want to return in your query.\n\n\nFormat:\n \n\n\nselect(column_name | array(column_name1, column_name2, ...))\n\n\n\n\nExamples:\n  \n\n\n// Grab a single column\n$db->select('id')\n\n// OR grab multiple columns\n$db->select('id')\n   ->select('first_name')\n\n// OR grab multiple columns by passing in an array\n$db->select(['id', 'first_name', 'last_name'])\n\n\n\n\ndistinct() method\n\n\nPurpose:\n \n\nThe distinct() method is for limiting the results returned so that there's no duplicates.\n\n\nFormat:\n  \n\n\ndistinct()\n\n\n\n\nExamples:\n  \n\n\n// The distinct method takes no parameters, you just call it when constructing your query.\n$db ->select('first_name')\n    ->distinct()\n    ->from('users');\n\n\n\n\nfrom() method\n\n\nAlias:\n \n\nThis method is an alias of table().\n\n\nPurpose:\n \n\nThe from() method is for selecting the table(s) you want to return or delete data from.\n\n\nFormat:\n  \n\n\nfrom(table_name | array(table_name1, table_name2, ...))\n\n\n\n\nExamples:\n   \n\n\n// Grab a single table\n$db->from('users')\n\n// OR join multiple tables\n$db->from('users')\n   ->from('user_profiles')\n\n// OR grab multiple tables by passing in an array\n$db->from(['users', 'user_profiles'])\n\n\n\n\njoin() method\n\n\nPurpose:\n \n\nThe join() method is for joining multiple tables together.\n\n\nFormat:\n  \n\n\n// f_table = Foreign Table Name\n// f_column = Foreign Column Name\njoin(f_table, array(array(table.column, operator, f_table.f_column)[, ...]) [, join_type ])\n\n\n\n\nExamples:\n  \n\n\n// Join a table when a certain single condition is met, using the default INNER join\n$db->join('members', [['users.user_id', '=', 'members.user_id']])\n\n// Join a table using a specifc type of join\n$db->join('members', [['users.user_id', '=', 'members.user_id']], 'OUTER')\n\n// Join a table when multiple conditions are met\n$db->join('members', [\n            ['Orders.customerID', '=', 'Customers.customerID'],\n            ['User.type', '=', 'Customer.type']\n        ], 'OUTER')\n\n// Apply multiple joins together\n$db ->join('members', [['users.user_id', '=', 'members.user_id']])\n    ->join('locations', [['users.location_id', '=', 'locations.id']])\n\n\n\n\nwhere() method\n\n\nPurpose:\n \n\nThe where() method is for limiting the records that get returned to only those that pass certain conditions.\n\n\nFormat:\n \n\n\nwhere(column_name, value [, operator] | array(array(column_name, operator, value [, conjunction])))\n\n\n\n\nExamples:\n  \n\n\n// Only return results where name = 'bob'\n$db->where('name', 'bob')\n\n// Only return results where the date is greater than or equal to january first 2014\n$db->where('date', '2014-01-01', '>=')\n\n// If the above format of passing in the operator as an optional 3rd parameter bothers you,\n// you can use the array format which uses the [column, operator, value] ordering.\n// Note that you need the double brackets though because it supports multiple statements.\n$db->where([['date', '>=', '2014-01-01']])\n\n// Only return results where the date is greater than or equal to january first 2014\n// and less than january 2016\n$db ->where('date', '2014-01-01', '>=')\n    ->where('date', '2016-01-01', '<')\n\n// Only return results where name = 'bob' OR name = 'jeff'\n$db ->where('name', 'bob')\n    ->orWhere('name', 'jeff')\n\n// Pass in an array...\n// Only return results where a user's name starts with 's' or was created after Jan 2016,\n// and the user is of type 'admin' or 'moderator'\n$db ->where([\n        ['created_time', '>=', '2016-01-01', 'OR'],\n        ['name', 'LIKE', 's%']\n    ])\n    ->where([\n        ['type', '=', 'admin', 'OR'],\n        ['type', '=', 'moderator']\n    ])  \n// Using the MySQL adaptor, the above produces:\n// WHERE (created_time >= '2016-01-01' OR name LIKE 's%') AND (type = 'admin' OR type = 'moderator')\n\n\n\n\norWhere() method\n\n\nPurpose:\n \n\nThe orWhere() method is for limiting the records that get returned to only those that pass certain conditions. \n\n\nSimilar To:\n \n\nIt works identically to the where() method except any conditions passed to it will be conjoined with 'OR' to any other Where declarations. See the where() section for more examples.\n\n\nExamples:\n  \n\n\n// Only return users who are named bob and also admins, or users named jeff\n$db ->where([\n        ['name', 'bob'],\n        ['type', 'admin']\n    ])\n    ->orWhere('name', 'jeff')\n// Using the MySQL adaptor, the above produces:\n// WHERE (name = 'bob' AND type = 'admin') OR (name = 'jeff')\n\n\n\n\nin() method\n\n\nPurpose:\n \n\nThe in() method is for checking if a column's value exists in another set of data.\n\n\nFormat:\n   \n\n\nin(column, value | string(value1, value2, value3, ...) | array(value1, value2, value3, ...))\n\n\n\n\nExamples:\n \n\n\n// Check if column value matches a single value (same as using where statement)\n$db ->in('name', 'bob')\n\n// Check if column value is present in a comma separated list\n// Note: The list gets translated into an array by the Database class.\n$db ->in('name', 'bob, jeff, susan')\n\n// Check if column value is present in an array of values\n$db ->in('name', ['bob', 'jeff', 'susan'])\n\n// NOT RECOMMENDED as it breaks cross-database functionality, but possible\n$db ->in('name', 'SELECT name FROM users WHERE name LIKE s%')\n// The better way of doing the above is to do a query to grab all the names that start with 's',\n// then pass the result set as an array to the in() method. This would preserve cross-database\n// functionality and not lock you into databases that support your SQL statement.\n\n\n\n\ngroupBy() method\n\n\nPurpose:\n \n\nThe groupBy() method is for combining data together.\n\n\nFormat:\n  \n\n\ngroupBy(column | array(column1, column2, ...))\n\n\n\n\nExamples:\n   \n\n\n// Group by a single column\n$db->groupBy('last_name')\n\n// OR group by multiple columns\n$db->groupBy('last_name')\n   ->groupBy('location')\n\n// OR group by multiple columns by passing in an array\n$db->groupBy(['last_name', 'location'])\n\n\n\n\nhaving() method\n\n\nPurpose:\n \n\nThe having() method is for further filtering the results returned. where() performs row level checks,\nhaving() performs checks on the result set that gets returned after row level conditions are satisfied.\nIt's for filtering based on aggregates which where() can't do.\n\n\nFormat:\n \n\n\nhaving(column_name, value [, operator] | array(array(column_name, operator, value [, conjunction])))\n\n\n\n\nExamples:\n \n\nhaving() follows the same format as where(), so feel free to look at the examples there if you need to.\nIn order to understand more about the SQL Having keyword, \nsee this example from w3schools.com\n\n\norHaving() method\n\n\nPurpose:\n \n\nJoins the given condition(s) with any previous condition statements joined by 'OR'.\n\n\nFollows the same format as having(). For examples see the syntactially identical orWhere() method.\n\n\norderBy() method\n\n\nPurpose:\n \n\nThe orderBy() method is for ordering the returned results from your query.\n\n\nFormat:\n \n\n\n// sort_direction = DESC (descending) | ASC (ascending)\norderBy(column_name, sort_direction)\n\n\n\n\nExamples:\n \n\n\n// Specifying a single column to order by...\n$db ->orderBy('name', 'ASC')\n\n// Specifying multiple columns to order by...\n$db ->orderBy('users.name', 'DESC')\n    ->orderBy('locations.name', 'DESC')\n\n\n\n\nlimit() method\n\n\nPurpose:\n \n\nThe limit() method is for limiting the number of returned results from a query.\n\n\nFormat:\n   \n\n\nlimit(number)\n\n\n\n\nExamples:\n   \n\n\n// Limit the number of result rows to 10\n$db ->limit(10)\n\n\n\n\noffset() method\n\n\nPurpose:\n \n\nThe offset() method is for specifying how many result rows should be skipped when returning a query.\nIt's most commonly used in conjunction with limit() to perform pagination.\n\n\nFormat:\n   \n\n\noffset(number)\n\n\n\n\nExamples:\n   \n\n\n// Skip returning the first 10 results from a query's result set.\n$db ->offset(10)\n\n// Return results 11-20 from a large result set\n$db ->limit(10)\n    ->offset(10)\n\n// Return results 21-30 from a large result set\n$db ->limit(10)\n    ->offset(20)",
            "title": "SELECT Methods"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_select/#database-class-methods",
            "text": "",
            "title": "Database Class Methods"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_select/#select-method",
            "text": "Purpose:   \nThe select() method is for choosing the columns you want to return in your query.  Format:    select(column_name | array(column_name1, column_name2, ...))  Examples:     // Grab a single column\n$db->select('id')\n\n// OR grab multiple columns\n$db->select('id')\n   ->select('first_name')\n\n// OR grab multiple columns by passing in an array\n$db->select(['id', 'first_name', 'last_name'])",
            "title": "select() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_select/#distinct-method",
            "text": "Purpose:   \nThe distinct() method is for limiting the results returned so that there's no duplicates.  Format:     distinct()  Examples:     // The distinct method takes no parameters, you just call it when constructing your query.\n$db ->select('first_name')\n    ->distinct()\n    ->from('users');",
            "title": "distinct() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_select/#from-method",
            "text": "Alias:   \nThis method is an alias of table().  Purpose:   \nThe from() method is for selecting the table(s) you want to return or delete data from.  Format:     from(table_name | array(table_name1, table_name2, ...))  Examples:      // Grab a single table\n$db->from('users')\n\n// OR join multiple tables\n$db->from('users')\n   ->from('user_profiles')\n\n// OR grab multiple tables by passing in an array\n$db->from(['users', 'user_profiles'])",
            "title": "from() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_select/#join-method",
            "text": "Purpose:   \nThe join() method is for joining multiple tables together.  Format:     // f_table = Foreign Table Name\n// f_column = Foreign Column Name\njoin(f_table, array(array(table.column, operator, f_table.f_column)[, ...]) [, join_type ])  Examples:     // Join a table when a certain single condition is met, using the default INNER join\n$db->join('members', [['users.user_id', '=', 'members.user_id']])\n\n// Join a table using a specifc type of join\n$db->join('members', [['users.user_id', '=', 'members.user_id']], 'OUTER')\n\n// Join a table when multiple conditions are met\n$db->join('members', [\n            ['Orders.customerID', '=', 'Customers.customerID'],\n            ['User.type', '=', 'Customer.type']\n        ], 'OUTER')\n\n// Apply multiple joins together\n$db ->join('members', [['users.user_id', '=', 'members.user_id']])\n    ->join('locations', [['users.location_id', '=', 'locations.id']])",
            "title": "join() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_select/#where-method",
            "text": "Purpose:   \nThe where() method is for limiting the records that get returned to only those that pass certain conditions.  Format:    where(column_name, value [, operator] | array(array(column_name, operator, value [, conjunction])))  Examples:     // Only return results where name = 'bob'\n$db->where('name', 'bob')\n\n// Only return results where the date is greater than or equal to january first 2014\n$db->where('date', '2014-01-01', '>=')\n\n// If the above format of passing in the operator as an optional 3rd parameter bothers you,\n// you can use the array format which uses the [column, operator, value] ordering.\n// Note that you need the double brackets though because it supports multiple statements.\n$db->where([['date', '>=', '2014-01-01']])\n\n// Only return results where the date is greater than or equal to january first 2014\n// and less than january 2016\n$db ->where('date', '2014-01-01', '>=')\n    ->where('date', '2016-01-01', '<')\n\n// Only return results where name = 'bob' OR name = 'jeff'\n$db ->where('name', 'bob')\n    ->orWhere('name', 'jeff')\n\n// Pass in an array...\n// Only return results where a user's name starts with 's' or was created after Jan 2016,\n// and the user is of type 'admin' or 'moderator'\n$db ->where([\n        ['created_time', '>=', '2016-01-01', 'OR'],\n        ['name', 'LIKE', 's%']\n    ])\n    ->where([\n        ['type', '=', 'admin', 'OR'],\n        ['type', '=', 'moderator']\n    ])  \n// Using the MySQL adaptor, the above produces:\n// WHERE (created_time >= '2016-01-01' OR name LIKE 's%') AND (type = 'admin' OR type = 'moderator')",
            "title": "where() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_select/#orwhere-method",
            "text": "Purpose:   \nThe orWhere() method is for limiting the records that get returned to only those that pass certain conditions.   Similar To:   \nIt works identically to the where() method except any conditions passed to it will be conjoined with 'OR' to any other Where declarations. See the where() section for more examples.  Examples:     // Only return users who are named bob and also admins, or users named jeff\n$db ->where([\n        ['name', 'bob'],\n        ['type', 'admin']\n    ])\n    ->orWhere('name', 'jeff')\n// Using the MySQL adaptor, the above produces:\n// WHERE (name = 'bob' AND type = 'admin') OR (name = 'jeff')",
            "title": "orWhere() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_select/#in-method",
            "text": "Purpose:   \nThe in() method is for checking if a column's value exists in another set of data.  Format:      in(column, value | string(value1, value2, value3, ...) | array(value1, value2, value3, ...))  Examples:    // Check if column value matches a single value (same as using where statement)\n$db ->in('name', 'bob')\n\n// Check if column value is present in a comma separated list\n// Note: The list gets translated into an array by the Database class.\n$db ->in('name', 'bob, jeff, susan')\n\n// Check if column value is present in an array of values\n$db ->in('name', ['bob', 'jeff', 'susan'])\n\n// NOT RECOMMENDED as it breaks cross-database functionality, but possible\n$db ->in('name', 'SELECT name FROM users WHERE name LIKE s%')\n// The better way of doing the above is to do a query to grab all the names that start with 's',\n// then pass the result set as an array to the in() method. This would preserve cross-database\n// functionality and not lock you into databases that support your SQL statement.",
            "title": "in() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_select/#groupby-method",
            "text": "Purpose:   \nThe groupBy() method is for combining data together.  Format:     groupBy(column | array(column1, column2, ...))  Examples:      // Group by a single column\n$db->groupBy('last_name')\n\n// OR group by multiple columns\n$db->groupBy('last_name')\n   ->groupBy('location')\n\n// OR group by multiple columns by passing in an array\n$db->groupBy(['last_name', 'location'])",
            "title": "groupBy() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_select/#having-method",
            "text": "Purpose:   \nThe having() method is for further filtering the results returned. where() performs row level checks,\nhaving() performs checks on the result set that gets returned after row level conditions are satisfied.\nIt's for filtering based on aggregates which where() can't do.  Format:    having(column_name, value [, operator] | array(array(column_name, operator, value [, conjunction])))  Examples:   \nhaving() follows the same format as where(), so feel free to look at the examples there if you need to.\nIn order to understand more about the SQL Having keyword,  see this example from w3schools.com",
            "title": "having() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_select/#orhaving-method",
            "text": "Purpose:   \nJoins the given condition(s) with any previous condition statements joined by 'OR'.  Follows the same format as having(). For examples see the syntactially identical orWhere() method.",
            "title": "orHaving() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_select/#orderby-method",
            "text": "Purpose:   \nThe orderBy() method is for ordering the returned results from your query.  Format:    // sort_direction = DESC (descending) | ASC (ascending)\norderBy(column_name, sort_direction)  Examples:    // Specifying a single column to order by...\n$db ->orderBy('name', 'ASC')\n\n// Specifying multiple columns to order by...\n$db ->orderBy('users.name', 'DESC')\n    ->orderBy('locations.name', 'DESC')",
            "title": "orderBy() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_select/#limit-method",
            "text": "Purpose:   \nThe limit() method is for limiting the number of returned results from a query.  Format:      limit(number)  Examples:      // Limit the number of result rows to 10\n$db ->limit(10)",
            "title": "limit() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_select/#offset-method",
            "text": "Purpose:   \nThe offset() method is for specifying how many result rows should be skipped when returning a query.\nIt's most commonly used in conjunction with limit() to perform pagination.  Format:      offset(number)  Examples:      // Skip returning the first 10 results from a query's result set.\n$db ->offset(10)\n\n// Return results 11-20 from a large result set\n$db ->limit(10)\n    ->offset(10)\n\n// Return results 21-30 from a large result set\n$db ->limit(10)\n    ->offset(20)",
            "title": "offset() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_update/",
            "text": "Database Class Methods\n\n\nupdate() method\n\n\nAlias:\n \n\nThis method is an alias of table().\n\n\nPurpose:\n \n\nThe update() method is for selecting the table(s) you want to perform an update on.\n\n\nFormat:\n  \n\n\nupdate(table_name | array(table_name1, table_name2, ...))\n\n\n\n\nset() method\n\n\nPurpose:\n \n\nThe set() method is for assigning a field a new value.\n\n\nFormat:\n   \n\n\nset(column_name, newValue)\n\n\n\n\nExamples:\n  \n\n\n// Rename any users with the name Randy to John.\n$db ->update('users')\n    ->set('name', 'John')\n    ->where('name', 'Randy')\n    ->exec();\n\n\n\n\nwhere() method\n\n\nPurpose:\n \n\nThe where() method is for limiting the records that get returned to only those that pass certain conditions.\n\n\nFormat:\n \n\n\nwhere(column_name, value [, operator] | array(array(column_name, operator, value [, conjunction])))\n\n\n\n\nExamples:\n  \n\n\n// Only return results where name = 'bob'\n$db->where('name', 'bob')\n\n// Only return results where the date is greater than or equal to january first 2014\n$db->where('date', '2014-01-01', '>=')\n\n// Only return results where the date is greater than or equal to january first 2014\n// and less than january 2016\n$db ->where('date', '2014-01-01', '>=')\n    ->where('date', '2016-01-01', '<')\n\n// Only return results where name = 'bob' OR name = 'jeff'\n$db ->where('name', 'bob')\n    ->orWhere('name', 'jeff')\n\n// Pass in an array...\n// Only return results where a user's name starts with 's' or was created after Jan 2016,\n// and the user is of type 'admin' or 'moderator'\n$db ->where([\n        ['created_time', '>=', '2016-01-01', 'OR'],\n        ['name', 'LIKE', 's%']\n    ])\n    ->where([\n        ['type', '=', 'admin', 'OR'],\n        ['type', '=', 'moderator']\n    ])  \n// Using the MySQL adaptor, the above produces:\n// WHERE (created_time >= '2016-01-01' OR name LIKE 's%') AND (type = 'admin' OR type = 'moderator')\n\n\n\n\norWhere() method\n\n\nPurpose:\n \n\nThe orWhere() method is for limiting the records that get returned to only those that pass certain conditions. \n\n\nSimilar To:\n \n\nIt works identically to the where() method except any conditions passed to it will be conjoined with 'OR' to any other Where declarations. See the where() section for more examples.\n\n\nExamples:\n  \n\n\n// Only return users who are named bob and also admins, or users named jeff\n$db ->where([\n        ['name', 'bob'],\n        ['type', 'admin']\n    ])\n    ->orWhere('name', 'jeff')\n// Using the MySQL adaptor, the above produces:\n// WHERE (name = 'bob' AND type = 'admin') OR (name = 'jeff')\n\n\n\n\nin() method\n\n\nPurpose:\n \n\nThe in() method is for checking if a column's value exists in another set of data.\n\n\nFormat:\n   \n\n\nin(column, value | string(value1, value2, value3, ...) | array(value1, value2, value3, ...))\n\n\n\n\nExamples:\n \n\n\n// Check if column value matches a single value (same as using where statement)\n$db ->in('name', 'bob')\n\n// Check if column value is present in a comma separated list\n// Note: The list gets translated into an array by the Database class.\n$db ->in('name', 'bob, jeff, susan')\n\n// Check if column value is present in an array of values\n$db ->in('name', ['bob', 'jeff', 'susan'])\n\n// NOT RECOMMENDED as it breaks cross-database functionality, but possible\n$db ->in('name', 'SELECT name FROM users WHERE name LIKE s%')\n// The better way of doing the above is to do a query to grab all the names that start with 's',\n// then pass the result set as an array to the in() method. This would preserve cross-database\n// functionality and not lock you into databases that support your SQL statement.\n\n\n\n\nformat as having(). For examples see the syntactially identical orWhere() method.\n\n\norderBy() method\n\n\nPurpose:\n \n\nThe orderBy() method is for ordering the returned results from your query.\n\n\nFormat:\n \n\n\n// sort_direction = DESC (descending) | ASC (ascending)\norderBy(column_name, sort_direction)\n\n\n\n\nExamples:\n \n\n\n// Specifying a single column to order by...\n$db ->orderBy('name', 'ASC')\n\n// Specifying multiple columns to order by...\n$db ->orderBy('users.name', 'DESC')\n    ->orderBy('locations.name', 'DESC')\n\n\n\n\nlimit() method\n\n\nPurpose:\n \n\nThe limit() method is for limiting the number of returned results from a query.\n\n\nFormat:\n   \n\n\nlimit(number)\n\n\n\n\nExamples:\n   \n\n\n// Limit the number of result rows to 10\n$db ->limit(10)",
            "title": "UPDATE Methods"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_update/#database-class-methods",
            "text": "",
            "title": "Database Class Methods"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_update/#update-method",
            "text": "Alias:   \nThis method is an alias of table().  Purpose:   \nThe update() method is for selecting the table(s) you want to perform an update on.  Format:     update(table_name | array(table_name1, table_name2, ...))",
            "title": "update() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_update/#set-method",
            "text": "Purpose:   \nThe set() method is for assigning a field a new value.  Format:      set(column_name, newValue)  Examples:     // Rename any users with the name Randy to John.\n$db ->update('users')\n    ->set('name', 'John')\n    ->where('name', 'Randy')\n    ->exec();",
            "title": "set() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_update/#where-method",
            "text": "Purpose:   \nThe where() method is for limiting the records that get returned to only those that pass certain conditions.  Format:    where(column_name, value [, operator] | array(array(column_name, operator, value [, conjunction])))  Examples:     // Only return results where name = 'bob'\n$db->where('name', 'bob')\n\n// Only return results where the date is greater than or equal to january first 2014\n$db->where('date', '2014-01-01', '>=')\n\n// Only return results where the date is greater than or equal to january first 2014\n// and less than january 2016\n$db ->where('date', '2014-01-01', '>=')\n    ->where('date', '2016-01-01', '<')\n\n// Only return results where name = 'bob' OR name = 'jeff'\n$db ->where('name', 'bob')\n    ->orWhere('name', 'jeff')\n\n// Pass in an array...\n// Only return results where a user's name starts with 's' or was created after Jan 2016,\n// and the user is of type 'admin' or 'moderator'\n$db ->where([\n        ['created_time', '>=', '2016-01-01', 'OR'],\n        ['name', 'LIKE', 's%']\n    ])\n    ->where([\n        ['type', '=', 'admin', 'OR'],\n        ['type', '=', 'moderator']\n    ])  \n// Using the MySQL adaptor, the above produces:\n// WHERE (created_time >= '2016-01-01' OR name LIKE 's%') AND (type = 'admin' OR type = 'moderator')",
            "title": "where() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_update/#orwhere-method",
            "text": "Purpose:   \nThe orWhere() method is for limiting the records that get returned to only those that pass certain conditions.   Similar To:   \nIt works identically to the where() method except any conditions passed to it will be conjoined with 'OR' to any other Where declarations. See the where() section for more examples.  Examples:     // Only return users who are named bob and also admins, or users named jeff\n$db ->where([\n        ['name', 'bob'],\n        ['type', 'admin']\n    ])\n    ->orWhere('name', 'jeff')\n// Using the MySQL adaptor, the above produces:\n// WHERE (name = 'bob' AND type = 'admin') OR (name = 'jeff')",
            "title": "orWhere() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_update/#in-method",
            "text": "Purpose:   \nThe in() method is for checking if a column's value exists in another set of data.  Format:      in(column, value | string(value1, value2, value3, ...) | array(value1, value2, value3, ...))  Examples:    // Check if column value matches a single value (same as using where statement)\n$db ->in('name', 'bob')\n\n// Check if column value is present in a comma separated list\n// Note: The list gets translated into an array by the Database class.\n$db ->in('name', 'bob, jeff, susan')\n\n// Check if column value is present in an array of values\n$db ->in('name', ['bob', 'jeff', 'susan'])\n\n// NOT RECOMMENDED as it breaks cross-database functionality, but possible\n$db ->in('name', 'SELECT name FROM users WHERE name LIKE s%')\n// The better way of doing the above is to do a query to grab all the names that start with 's',\n// then pass the result set as an array to the in() method. This would preserve cross-database\n// functionality and not lock you into databases that support your SQL statement.  format as having(). For examples see the syntactially identical orWhere() method.",
            "title": "in() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_update/#orderby-method",
            "text": "Purpose:   \nThe orderBy() method is for ordering the returned results from your query.  Format:    // sort_direction = DESC (descending) | ASC (ascending)\norderBy(column_name, sort_direction)  Examples:    // Specifying a single column to order by...\n$db ->orderBy('name', 'ASC')\n\n// Specifying multiple columns to order by...\n$db ->orderBy('users.name', 'DESC')\n    ->orderBy('locations.name', 'DESC')",
            "title": "orderBy() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_update/#limit-method",
            "text": "Purpose:   \nThe limit() method is for limiting the number of returned results from a query.  Format:      limit(number)  Examples:      // Limit the number of result rows to 10\n$db ->limit(10)",
            "title": "limit() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_insert/",
            "text": "Database Class Methods\n\n\ninsert() method\n\n\nPurpose:\n \n\nThe insert() method is for specifying the column names you want to insert into.\n\n\nFormat:\n   \n\n\nin(column | string(column1, column2, column3, ...) | array(column1, column2, column3, ...))\n\n\n\n\nExamples:\n \n\n\n// Insert two users 'Bob' and 'John' into the users table.\n$db ->insert('name, email, type')\n    ->into('users')\n    ->values([['bob', 'bob@gmail.com', 'admin'], ['john', 'john@gmail.com', 'admin']])\n    ->exec();\n\n\n\n\ninto() method\n\n\nAlias:\n \n\nThis method is an alias of table().\n\n\nPurpose:\n \n\nThe into() method is for selecting the table(s) you want to insert data into.\n\n\nFormat:\n  \n\n\ninto(table_name | array(table_name1, table_name2, ...))\n\n\n\n\nvalues() method\n\n\nPurpose:\n \n\nThe values() method is for specifying the values you want to insert when executing an insert statement.\nIt expects either a single array when inserting a single row of data, or an array of arrays when inserting\nmultiple rows of data.\n\n\nFormat:\n   \n\n\nvalues(array(value1, value2, ...) | array(array(value1, value2, ...), array(value1, value2, ...)))\n\n\n\n\nExamples:\n \n\n\n// Insert a single row of data.\n$db ->insert('name, email, type')\n    ->into('users')\n    ->values(['bob', 'bob@gmail.com', 'admin'])\n    ->exec();\n\n// Insert multiple rows of data\n$db ->insert('name, email, type')\n    ->into('users')\n    ->values([['bob', 'bob@gmail.com', 'admin'], ['john', 'john@gmail.com', 'admin']])\n    ->exec();\n\n// OR insert multiple rows of data by calling values() more than once...\n$db ->insert('name, email, type')\n    ->into('users')\n    ->values(['bob', 'bob@gmail.com', 'admin'])\n    ->values(['john', 'john@gmail.com', 'admin'])\n    ->exec();",
            "title": "INSERT Methods"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_insert/#database-class-methods",
            "text": "",
            "title": "Database Class Methods"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_insert/#insert-method",
            "text": "Purpose:   \nThe insert() method is for specifying the column names you want to insert into.  Format:      in(column | string(column1, column2, column3, ...) | array(column1, column2, column3, ...))  Examples:    // Insert two users 'Bob' and 'John' into the users table.\n$db ->insert('name, email, type')\n    ->into('users')\n    ->values([['bob', 'bob@gmail.com', 'admin'], ['john', 'john@gmail.com', 'admin']])\n    ->exec();",
            "title": "insert() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_insert/#into-method",
            "text": "Alias:   \nThis method is an alias of table().  Purpose:   \nThe into() method is for selecting the table(s) you want to insert data into.  Format:     into(table_name | array(table_name1, table_name2, ...))",
            "title": "into() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_insert/#values-method",
            "text": "Purpose:   \nThe values() method is for specifying the values you want to insert when executing an insert statement.\nIt expects either a single array when inserting a single row of data, or an array of arrays when inserting\nmultiple rows of data.  Format:      values(array(value1, value2, ...) | array(array(value1, value2, ...), array(value1, value2, ...)))  Examples:    // Insert a single row of data.\n$db ->insert('name, email, type')\n    ->into('users')\n    ->values(['bob', 'bob@gmail.com', 'admin'])\n    ->exec();\n\n// Insert multiple rows of data\n$db ->insert('name, email, type')\n    ->into('users')\n    ->values([['bob', 'bob@gmail.com', 'admin'], ['john', 'john@gmail.com', 'admin']])\n    ->exec();\n\n// OR insert multiple rows of data by calling values() more than once...\n$db ->insert('name, email, type')\n    ->into('users')\n    ->values(['bob', 'bob@gmail.com', 'admin'])\n    ->values(['john', 'john@gmail.com', 'admin'])\n    ->exec();",
            "title": "values() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_delete/",
            "text": "Database Class Methods\n\n\ndelete() method\n\n\nPurpose:\n \n\nThe delete() method tells the database class that you want to delete some records from a database table/collection.\n\n\nFormat:\n  \n\n\ndelete()\n\n\n\n\nExamples:\n  \n\n\n// Delete all the records from a users table where their type is 'test'\n$db ->delete()\n    ->from('users')\n    ->where('type', 'test')\n    ->exec();\n\n\n\n\nfrom() method\n\n\nAlias:\n \n\nThis method is an alias of table().\n\n\nPurpose:\n \n\nThe from() method is for selecting the table(s) you want to return or delete data from.\n\n\nFormat:\n  \n\n\nfrom(table_name | array(table_name1, table_name2, ...))\n\n\n\n\nExamples:\n   \n\n\n// Grab a single table\n$db->from('users')\n\n// OR join multiple tables\n$db->from('users')\n   ->from('user_profiles')\n\n// OR grab multiple tables by passing in an array\n$db->from(['users', 'user_profiles'])\n\n\n\n\nwhere() method\n\n\nPurpose:\n \n\nThe where() method is for limiting the records that get returned to only those that pass certain conditions.\n\n\nFormat:\n \n\n\nwhere(column_name, value [, operator] | array(array(column_name, operator, value [, conjunction])))\n\n\n\n\nExamples:\n  \n\n\n// Only return results where name = 'bob'\n$db->where('name', 'bob')\n\n// Only return results where the date is greater than or equal to january first 2014\n$db->where('date', '2014-01-01', '>=')\n\n// Only return results where the date is greater than or equal to january first 2014\n// and less than january 2016\n$db ->where('date', '2014-01-01', '>=')\n    ->where('date', '2016-01-01', '<')\n\n// Only return results where name = 'bob' OR name = 'jeff'\n$db ->where('name', 'bob')\n    ->orWhere('name', 'jeff')\n\n// Pass in an array...\n// Only return results where a user's name starts with 's' or was created after Jan 2016,\n// and the user is of type 'admin' or 'moderator'\n$db ->where([\n        ['created_time', '>=', '2016-01-01', 'OR'],\n        ['name', 'LIKE', 's%']\n    ])\n    ->where([\n        ['type', '=', 'admin', 'OR'],\n        ['type', '=', 'moderator']\n    ])  \n// Using the MySQL adaptor, the above produces:\n// WHERE (created_time >= '2016-01-01' OR name LIKE 's%') AND (type = 'admin' OR type = 'moderator')\n\n\n\n\norWhere() method\n\n\nPurpose:\n \n\nThe orWhere() method is for limiting the records that get returned to only those that pass certain conditions. \n\n\nSimilar To:\n \n\nIt works identically to the where() method except any conditions passed to it will be conjoined with 'OR' to any other Where declarations. See the where() section for more examples.\n\n\nExamples:\n  \n\n\n// Only return users who are named bob and also admins, or users named jeff\n$db ->where([\n        ['name', 'bob'],\n        ['type', 'admin']\n    ])\n    ->orWhere('name', 'jeff')\n// Using the MySQL adaptor, the above produces:\n// WHERE (name = 'bob' AND type = 'admin') OR (name = 'jeff')\n\n\n\n\nin() method\n\n\nPurpose:\n \n\nThe in() method is for checking if a column's value exists in another set of data.\n\n\nFormat:\n   \n\n\nin(column, value | string(value1, value2, value3, ...) | array(value1, value2, value3, ...))\n\n\n\n\nExamples:\n \n\n\n// Check if column value matches a single value (same as using where statement)\n$db ->in('name', 'bob')\n\n// Check if column value is present in a comma separated list\n// Note: The list gets translated into an array by the Database class.\n$db ->in('name', 'bob, jeff, susan')\n\n// Check if column value is present in an array of values\n$db ->in('name', ['bob', 'jeff', 'susan'])\n\n// NOT RECOMMENDED as it breaks cross-database functionality, but possible\n$db ->in('name', 'SELECT name FROM users WHERE name LIKE s%')\n// The better way of doing the above is to do a query to grab all the names that start with 's',\n// then pass the result set as an array to the in() method. This would preserve cross-database\n// functionality and not lock you into databases that support your SQL statement.\n\n\n\n\norderBy() method\n\n\nPurpose:\n \n\nThe orderBy() method is for ordering the returned results from your query.\n\n\nFormat:\n \n\n\n// sort_direction = DESC (descending) | ASC (ascending)\norderBy(column_name, sort_direction)\n\n\n\n\nExamples:\n \n\n\n// Specifying a single column to order by...\n$db ->orderBy('name', 'ASC')\n\n// Specifying multiple columns to order by...\n$db ->orderBy('users.name', 'DESC')\n    ->orderBy('locations.name', 'DESC')\n\n\n\n\nlimit() method\n\n\nPurpose:\n \n\nThe limit() method is for limiting the number of returned results from a query.\n\n\nFormat:\n   \n\n\nlimit(number)\n\n\n\n\nExamples:\n   \n\n\n// Limit the number of result rows to 10\n$db ->limit(10)",
            "title": "DELETE Methods"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_delete/#database-class-methods",
            "text": "",
            "title": "Database Class Methods"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_delete/#delete-method",
            "text": "Purpose:   \nThe delete() method tells the database class that you want to delete some records from a database table/collection.  Format:     delete()  Examples:     // Delete all the records from a users table where their type is 'test'\n$db ->delete()\n    ->from('users')\n    ->where('type', 'test')\n    ->exec();",
            "title": "delete() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_delete/#from-method",
            "text": "Alias:   \nThis method is an alias of table().  Purpose:   \nThe from() method is for selecting the table(s) you want to return or delete data from.  Format:     from(table_name | array(table_name1, table_name2, ...))  Examples:      // Grab a single table\n$db->from('users')\n\n// OR join multiple tables\n$db->from('users')\n   ->from('user_profiles')\n\n// OR grab multiple tables by passing in an array\n$db->from(['users', 'user_profiles'])",
            "title": "from() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_delete/#where-method",
            "text": "Purpose:   \nThe where() method is for limiting the records that get returned to only those that pass certain conditions.  Format:    where(column_name, value [, operator] | array(array(column_name, operator, value [, conjunction])))  Examples:     // Only return results where name = 'bob'\n$db->where('name', 'bob')\n\n// Only return results where the date is greater than or equal to january first 2014\n$db->where('date', '2014-01-01', '>=')\n\n// Only return results where the date is greater than or equal to january first 2014\n// and less than january 2016\n$db ->where('date', '2014-01-01', '>=')\n    ->where('date', '2016-01-01', '<')\n\n// Only return results where name = 'bob' OR name = 'jeff'\n$db ->where('name', 'bob')\n    ->orWhere('name', 'jeff')\n\n// Pass in an array...\n// Only return results where a user's name starts with 's' or was created after Jan 2016,\n// and the user is of type 'admin' or 'moderator'\n$db ->where([\n        ['created_time', '>=', '2016-01-01', 'OR'],\n        ['name', 'LIKE', 's%']\n    ])\n    ->where([\n        ['type', '=', 'admin', 'OR'],\n        ['type', '=', 'moderator']\n    ])  \n// Using the MySQL adaptor, the above produces:\n// WHERE (created_time >= '2016-01-01' OR name LIKE 's%') AND (type = 'admin' OR type = 'moderator')",
            "title": "where() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_delete/#orwhere-method",
            "text": "Purpose:   \nThe orWhere() method is for limiting the records that get returned to only those that pass certain conditions.   Similar To:   \nIt works identically to the where() method except any conditions passed to it will be conjoined with 'OR' to any other Where declarations. See the where() section for more examples.  Examples:     // Only return users who are named bob and also admins, or users named jeff\n$db ->where([\n        ['name', 'bob'],\n        ['type', 'admin']\n    ])\n    ->orWhere('name', 'jeff')\n// Using the MySQL adaptor, the above produces:\n// WHERE (name = 'bob' AND type = 'admin') OR (name = 'jeff')",
            "title": "orWhere() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_delete/#in-method",
            "text": "Purpose:   \nThe in() method is for checking if a column's value exists in another set of data.  Format:      in(column, value | string(value1, value2, value3, ...) | array(value1, value2, value3, ...))  Examples:    // Check if column value matches a single value (same as using where statement)\n$db ->in('name', 'bob')\n\n// Check if column value is present in a comma separated list\n// Note: The list gets translated into an array by the Database class.\n$db ->in('name', 'bob, jeff, susan')\n\n// Check if column value is present in an array of values\n$db ->in('name', ['bob', 'jeff', 'susan'])\n\n// NOT RECOMMENDED as it breaks cross-database functionality, but possible\n$db ->in('name', 'SELECT name FROM users WHERE name LIKE s%')\n// The better way of doing the above is to do a query to grab all the names that start with 's',\n// then pass the result set as an array to the in() method. This would preserve cross-database\n// functionality and not lock you into databases that support your SQL statement.",
            "title": "in() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_delete/#orderby-method",
            "text": "Purpose:   \nThe orderBy() method is for ordering the returned results from your query.  Format:    // sort_direction = DESC (descending) | ASC (ascending)\norderBy(column_name, sort_direction)  Examples:    // Specifying a single column to order by...\n$db ->orderBy('name', 'ASC')\n\n// Specifying multiple columns to order by...\n$db ->orderBy('users.name', 'DESC')\n    ->orderBy('locations.name', 'DESC')",
            "title": "orderBy() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_delete/#limit-method",
            "text": "Purpose:   \nThe limit() method is for limiting the number of returned results from a query.  Format:      limit(number)  Examples:      // Limit the number of result rows to 10\n$db ->limit(10)",
            "title": "limit() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_create/",
            "text": "Database Class Methods\n\n\ncreate() method\n\n\nPurpose:\n \n\nThe create() method tells the database class that you want to create a new table/collection.\n\n\nFormat:\n  \n\n\ncreate(new_table_name)\n\n\n\n\nExamples:\n  \n\n\n// Create a table/collection named 'locations'\n$db ->create('locations')\n    ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n    ->field('name', 'varchar(255)')\n    ->field('address', 'varchar(255)')\n    ->field('user_id', 'int')\n    ->primaryKey('id')\n    ->foreignKey('user_id', 'users', 'id')\n    ->exec();\n\n\n\n\nfield() method\n\n\nPurpose:\n \n\nThe field() method denotes a column you want to create on a table.\n\n\nFormat:\n  \n\n\nfield(column_name, column_type, special_attributes)\n\n\n\n\nExamples:\n  \n\n\n// Create a table/collection named 'locations'\n// Create id, name, address, and user_id columns on it.\n$db ->create('locations')\n    ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n    ->field('name', 'varchar(255)')\n    ->field('address', 'varchar(255)')\n    ->field('user_id', 'int')\n    ->primaryKey('id')\n    ->foreignKey('user_id', 'users', 'id')\n    ->exec();\n\n\n\n\nprimaryKey() method\n\n\nPurpose:\n \n\nThe primaryKey() method tells the database class you want to create a primary key index on a column if the underlying\ndatabase supports it.\n\n\nFormat:\n  \n\n\nprimaryKey(column_name)\n\n\n\n\nExamples:\n  \n\n\n// Create a table/collection named 'locations'\n// Sets the 'id' column as primary.\n$db ->create('locations')\n    ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n    ->field('name', 'varchar(255)')\n    ->field('address', 'varchar(255)')\n    ->field('user_id', 'int')\n    ->primaryKey('id')\n    ->foreignKey('user_id', 'users', 'id')\n    ->exec();\n\n\n\n\nforeignKey() method\n\n\nPurpose:\n \n\nThe foreignKey() method tells the database class that you want to create for foreign key relationship\nbetween a column on the table you are creating and a column in a different table.\n\n\nFormat:\n  \n\n\nforeignKey(column_name, foreign_table_name, foreign_column_name)\n\n\n\n\nExamples:\n  \n\n\n// Create a table/collection named 'locations'\n// Creates a relationship between the user_id column on this table and the\n// 'id' column on a different 'users' table.\n$db ->create('locations')\n    ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n    ->field('name', 'varchar(255)')\n    ->field('address', 'varchar(255)')\n    ->field('user_id', 'int')\n    ->primaryKey('id')\n    ->foreignKey('user_id', 'users', 'id')\n    ->exec();",
            "title": "CREATE Methods"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_create/#database-class-methods",
            "text": "",
            "title": "Database Class Methods"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_create/#create-method",
            "text": "Purpose:   \nThe create() method tells the database class that you want to create a new table/collection.  Format:     create(new_table_name)  Examples:     // Create a table/collection named 'locations'\n$db ->create('locations')\n    ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n    ->field('name', 'varchar(255)')\n    ->field('address', 'varchar(255)')\n    ->field('user_id', 'int')\n    ->primaryKey('id')\n    ->foreignKey('user_id', 'users', 'id')\n    ->exec();",
            "title": "create() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_create/#field-method",
            "text": "Purpose:   \nThe field() method denotes a column you want to create on a table.  Format:     field(column_name, column_type, special_attributes)  Examples:     // Create a table/collection named 'locations'\n// Create id, name, address, and user_id columns on it.\n$db ->create('locations')\n    ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n    ->field('name', 'varchar(255)')\n    ->field('address', 'varchar(255)')\n    ->field('user_id', 'int')\n    ->primaryKey('id')\n    ->foreignKey('user_id', 'users', 'id')\n    ->exec();",
            "title": "field() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_create/#primarykey-method",
            "text": "Purpose:   \nThe primaryKey() method tells the database class you want to create a primary key index on a column if the underlying\ndatabase supports it.  Format:     primaryKey(column_name)  Examples:     // Create a table/collection named 'locations'\n// Sets the 'id' column as primary.\n$db ->create('locations')\n    ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n    ->field('name', 'varchar(255)')\n    ->field('address', 'varchar(255)')\n    ->field('user_id', 'int')\n    ->primaryKey('id')\n    ->foreignKey('user_id', 'users', 'id')\n    ->exec();",
            "title": "primaryKey() method"
        },
        {
            "location": "/documentation/v2/databaseclass/methods_create/#foreignkey-method",
            "text": "Purpose:   \nThe foreignKey() method tells the database class that you want to create for foreign key relationship\nbetween a column on the table you are creating and a column in a different table.  Format:     foreignKey(column_name, foreign_table_name, foreign_column_name)  Examples:     // Create a table/collection named 'locations'\n// Creates a relationship between the user_id column on this table and the\n// 'id' column on a different 'users' table.\n$db ->create('locations')\n    ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n    ->field('name', 'varchar(255)')\n    ->field('address', 'varchar(255)')\n    ->field('user_id', 'int')\n    ->primaryKey('id')\n    ->foreignKey('user_id', 'users', 'id')\n    ->exec();",
            "title": "foreignKey() method"
        },
        {
            "location": "/documentation/v2/databaseclass/databaseresult/",
            "text": "",
            "title": "DatabaseResult Class"
        },
        {
            "location": "/documentation/v2/dependency-injection/overview/",
            "text": "Dependency Injection\n\n\n\nDependency Injection is a method of decoupling code. The end result is code that's easier to test, easier to modify in the future, and easier to reason about without having to look at the inner workings to understand what's going on.\n\n\n\nIn this article we'll cover what exactly dependency injection is, how it works using Cora's provided classes, and best practices including potential pitfalls.\n\n\nAn Introduction to Dependency Injection\n\n\nGeneral purpose info - not Cora specific\n\n\nWhen writing applications, it's common to write code that utilizes other code. For instance, if you are writing a section of your app that sends out emails, you may decide to utilize a 3rd party library such as Amazon's SES (Simple Email Service) to handle the delivery of the emails for you. Or, you may write a class that manages your Users' permissions and reuse that User class across many areas of your app. Code packaging and reuse is an extremely fundamental part of all programming paradigms.\n\n\nDependency Injection is the process of passing in (aka \"injecting\") from an external source the dependencies a piece of code relies on. This is important because it decouples to some extent the pieces of code. Let's look at an example of code that DOES NOT use dependency injection:\n\n\nclass Example\n{\n    // Dependencies\n    protected $mailer;\n\n    public function __construct()\n    {\n        $this->mailer = new Mailer();\n    }\n}\n\n\n\n\nNotice the \"new\" declaration which is creating the dependent object. The fact that the dependency is getting created by the class which needs it means it isn't coming from an external source. So why is this generally considered bad? To answer that question imagine you are going to run some automated tests on your code and at some point you call \"$mailer->send()\" to send out an email. During testing you don't want emails getting sent out to people, so you want to stub out the Mailer class using a fake version that won't fire off the email. The problem is, with the setup shown above, you can't easily stub out (aka create a double of) the Mailer class because it's getting created in the constructor.\n\n\nLet's look at the same code, but have it use injection so the dependency is getting passed in:\n\n\nclass Example\n{\n    // Dependencies\n    protected $mailer;\n\n    public function __construct($mailer)\n    {\n        $this->mailer = $mailer;\n    }\n}\n\n\n\n\nNow with this code, if we need to pass a fake or modified version of any of the Mailer class in, we can! Below we'll pretend we're in our test function and pass our Example class a fake Mailer dependency.\n\n\npublic function myTest() \n{\n    $example = new Example(new FakeMailer());\n}\n\n\n\n\nAs long as FakeMailer adheres to the same Interface as Mailer, the Example class will be able to use it just fine without issue, but FakeMailer's send() method will presumably not send out real emails. This concept is referred to as dependency inversion due to the fact that Example is no longer directly dependent on the Mailer class, instead it's dependent on the Mailer Interface.\n\n\n\nNOTE: An \"Interface\" refers to the publicly available methods within a class. If two classes have the same Interface, that means they both agree to expose a set of matching public methods to consumers of the class. That doesn't mean both classes need to have ALL the same methods, just that they both agree to at least have the methods defined as part of the Interface.\n\n\n\n\nOk, let's pretend you don't care about testing (I see that smirk...). Is dependency injection still worth doing for other reasons? Yes. The same concept we just showed that can help with testing also can apply to modifying your code in the future. Let's pretend your Example class logs whenever it does something:\n\n\nclass Example\n{\n    // Dependencies\n    protected $mailer;\n    protected $logger;\n\n    public function __construct($mailer)\n    {\n        $this->mailer = $mailer;\n        $this->logger = new DatabaseLogger(); // Logs to a database.\n    }\n\n    public function doWork()\n    {\n        $this->mailer->send('Super Awesome Email');\n        $this->logger->log('A super awesome email was sent out.');\n    }\n}\n\n\n\n\nHowever, let's say that under certain conditions you don't want to log to a database, but instead want to log to a file. What now? You hardcoded \"DatabaseLogger\" in, so replacing it with say a \"FileLogger\" isn't possible unless you implement a setLogger() method (which is another form of dependency injection). Let's again change it so we inject a logger in through the constructor. With the setup seen below, you could easily pass in a Database or File based logger as necessary depending on your needs:\n\n\nclass Example\n{\n    // Dependencies\n    protected $mailer;\n    protected $logger;\n\n    public function __construct($mailer, $logger)\n    {\n        $this->mailer = $mailer;\n        $this->logger = $logger;\n    }\n\n    public function doWork()\n    {\n        $this->mailer->send('Super Awesome Email');\n        $this->logger->log('A super awesome email was sent out.');\n    }\n}\n\n\n\n\nThe Dependency Inversion Principle\n\n\nGeneral purpose info - not Cora specific\n\n\n\nWhat we did in the previous section with the injection of the Logging classes, even though we didn't explicitely define the interface, was an example of the Dependency Inversion Principle.\n \n\n\nIn order to fully understand the principle, it's important to first understand the concepts of Black Box programming and Interfaces:\n\n\nConcept #1: Black Box programming\n\n\nThe concept of \"black box\" programming is probably more widely understood in the world of compiled languages than it is in interpreted language communities, but it's an important general programming concept no matter what. Basically, Black Box programming says you shouldn't need to worry about HOW a code library accomplishes a task internally, you should be able to just look at the interface contract and use it. By \"contract\" we're talking a function/library says give me \"X\" input and I'll give you \"Y\" output. How does it take \"X\" input and generate \"Y\" output from it? WE DON'T CARE. The internals are a black box. There could be magical unicorns in there and giant hampster wheels, we just don't care. What matters is the contract between us and that black box of code which governs its usage.\n\n\nIn some compiled languages, you're forced to utilize this concept as you literally can't see the source code, and are only given the public interface.\n\n\nIn interpreted languages like PHP, you can open up the library and inspect how it works internally... however, you really SHOULDN'T NEED TO. As we'll soon discuss, other developers should be able to look at your interface and use the code just from that.\n\n\nConcept #2: Interfaces\n\n\nInterfaces are a set of public methods that form the contract between you and the library/class/module/function of code you're using. Interfaces state that if you call method \"X\" and provide it with parameters \"Y\", it will do/return \"Z\" as a result. The most important take away is that Interfaces are independent of the implementation. Going back to the logging example from earlier, if we define a LoggingInterface as such:\n\n\ninterface LoggingInterface\n{\n    /**\n     *  Logs the given message to a persistance layer.\n     *\n     *  @param string $message The message to log.\n     *  @return void\n     */\n    public function log($message);\n}\n\n\n\n\nThen the two possible logging classes for database and file logging would implement that Interface:\n\n\nclass DatabaseLogger implements LoggingInterface\n{\n    public function log($message)\n    {\n        // Code to log to a database...\n    }\n}\n\nclass FileLogger implements LoggingInterface\n{\n    public function log($message)\n    {\n        // Code to log to a file...\n    }\n}\n\n\n\n\nSo just to reiterate, Interfaces are independent of any implementation. Rather they represent a contract between you and that piece of software which you can use. As long as you have a clear contract, the internal implmentation details shouldn't matter.\n\n\nDependency Inversion\n\n\nOk, now that we have that common understanding in place, let's unravel how the Dependency Inversion Principle actually works:\n\n\nThis principle states that:\n\n\n    \nHigh-level modules should not depend on low-level modules. Both should depend on abstractions.\n\n    \nAbstractions should not depend on details. Details should depend on abstractions.\n\n    \n\n        - Martin, Robert C. (2003). Agile Software Development, Principles, Patterns, and Practices. Prentice Hall. pp. 127\u2013131. ISBN 978-0135974445.\n    \n\n\n\n\nWhat this principle encourages is thinking about your software system in terms of not just a set of Objects, but rather as a set of Objects AND Interactions between them. Furthermore, thinking about the interactions without regard for the actual implementation. If following the principle 100%, no object would ever be directly tied to another object, but instead the dependency for both would be tied to a set of interactions (an Interface).\n\n\nThe following diagram shows this change in dependencies in a visual way:\n\n\n\n\nIn the first diagram, class B is directly dependent on the presence of class A. In the second diagram, class B has been changed to have a dependency on an Interface X, an interface which class A implements. In this way, if class A is passed to class B, class B's dependency is satisfied. Of course, with the change to a dependency on an Interface, any other class that implements Interface X would also satisfy class B.\n\n\nHopefully those explanations and the Logging example help with understanding how you can improve the adaptability of your application by decoupling direct dependencies between classes. That said, I WOULDN'T necessarily recommend you run out and start making an Interface for everything. The Dependency Inversion principle is a concept that I would argue is important to understand and think about, but also one which you should feel free to break.\n\n\nIn terms of PHP, implementing generic interfaces everywhere in your application can actually make it harder to understand and maintain. Before bothering with an explicit Interface you should examine whether you think you'll ever have another class that uses that same interface, whether you'll need to mock that object, and whether your testing tools even require it for mocking. Just implementing an interface over a class for the sake of having an interface does not by itself reduce coupling in a meaningful way. You really have to be purposeful in thinking about the potential abstraction of interactions and when implementing an Interface will help you achieve a less coupled design.\n\n\nInjection Without Tools and the Challenges Therein\n\n\nGeneral purpose info - not Cora specific\n\n\nBy now we've hopefully established the merits of dependency injection, and we've also given a simple example or two. But let's dive just a little deeper into how to accomplish it WITHOUT any 3rd party assistance from Cora or other tools. This should hopefully not only be educational but also highlight why having tools like Cora's Container class around to help are nice.\n\n\nLet's reuse our Example class from earlier that takes both a Mailer and a Logger object as dependencies, but with a couple modifications.\n\n\nclass Example\n{\n    // Dependencies\n    protected $mailer;\n    protected $logger;\n\n    public function __construct($mailer, $logger)\n    {\n        $this->mailer = $mailer;\n        $this->logger = $logger;\n    }\n\n    public function createUser($name)\n    {\n        $user = new User($name);\n        $this->mailer->send('Welcome', $user);\n        $this->logger->log('A new user was created');\n    }\n}\n\n\n\n\nNotice that we're creating a new User object with a name that we won't know until runtime. Needing to dynamically create objects within classes at runtime is a common issue, but the fact that we use the \"new\" operator should raise a red flag. The way it's written above, the Example class has a dependency on the User class, but it's not clear that this dependency exists because we're not passing the User class in through the constructor! No bueno! Ok, so maybe we need to pass the User object in through the constructor... which feels a little weird... but continuing that thought... what if we needed to create multiple User objects in a loop? Whoa, well then passing in a single User object through the constructor definitely wouldn't make sense. In this scenario of having to create objects dynamically at runtime the solution is to use a Factory. Let's add one more dependency in the form of a UserFactory and make that change:\n\n\nclass Example\n{\n    // Dependencies\n    protected $mailer;\n    protected $logger;\n    protected $userFactory;\n\n    public function __construct($mailer, $logger, $userFactory)\n    {\n        $this->mailer = $mailer;\n        $this->logger = $logger;\n        $this->userFactory = $userFactory;\n    }\n\n    public function createUser($name)\n    {\n        $user = $userFactory->make($name);\n        $this->mailer->send('Welcome', $user);\n        $this->logger->log('A new user was created');\n    }\n}\n\n\n\n\nMuch Better. Now it's clear we have a dependency on the UserFactory class and we're able to create as many User objects at runtime as we want.\n\n\nNow let's talk about creating an instance of our Example class. To perform the injection and create a new Example object in the simplest sense, we would just do something like follows:\n\n\npublic function someMethod() \n{\n    $example = new Example(new Mailer(), new FileLogger(), new UserFactory());\n}\n\n\n\n\nOk, fair enough. However, this is starting to feel kinda verbose don't you agree? I mean, if we only have to create an Example object once or twice in our app... sure. But what if Example is something that gets used in a bunch of places and we want to make this simpler on ourselves? Well the next logical step would be to create an Example factory and use it like so:\n\n\nclass ExampleFactory\n{\n    public static function make() \n    {\n        return new Example(new Mailer(), new FileLogger(), new UserFactory());\n    }\n}\n\nclass SomeController\n{\n    public function someMethod() \n    {\n        $example = ExampleFactory::make();\n    }\n}\n\n\n\n\nNow those pesky dependencies are being handled by our Factory and we just have to ask it to make us a new object. Easy. Time to go home and drink a beer.\n\n\nBut what if our Example class' dependencies also had dependencies?\n\n\nclass ExampleFactory\n{\n    public static function make() \n    {\n        return new Example(new Mailer(new Dependency1, new Dependency2, new Dependency3), new FileLogger(new Dependency1, new Dependency2, new Dependency3), new UserFactory());\n    }\n}\n\n\n\n\nHoly moly Batman! We just got crazy up in here. Let's just get this out of the way, the above is not a good idea. Not only is it hard to read, but if the dependencies of any of those classes ever change, then all the factories that use that class would then also have to be edited. The solution here would be to create some more factories:\n\n\nclass ExampleFactory\n{\n    public static function make() \n    {\n        return new Example(MailerFactory::make(), new FileLoggerFactory::make(), new UserFactory());\n    }\n}\n\n\n\n\nOk, that looks much better. The downside now is we just had to add a bunch of factory classes to our file system that don't do anything except make us an object. For a small project this is no biggie... however, for larger projects, these factories can end up being (IMO) quite a bit of file system clutter. We'll call this handling injection via Concrete (as opposed to Abstract) Factories.\n\n\nPros and Cons of Injection with Concrete Factories\n\n\nPros:\n\n\n\n\nThis form of handling injection works well with IntelliSense. This means you should be able to quickly open files to see what's going on.\n\n\nDependencies are known before runtime. The PHP Engine will throw an error at you if a needed dependency is missing. Likewise, if you were using a compiled language, you'd get a compile time error.\n\n\n\n\nCons:\n\n\n\n\nCan cause a lot of extra files to be added to your app's file directory.\n\n\nThe additional bloat can potentially make it harder to navigate and understand the app.\n\n\nLogic for handling dependencies is spread out over many files.\n\n\n\n\nAn Introduction to Dependency Injection Containers\n\n\nBoth General purpose info and Cora specific implementation\n\n\nA Dependency Injection Container (\"Container\" for short) is a tool that lets you define how to create objects (including any dependencies they need), and then it will handle the work of creating instances of those objects for you. If this sounds oddly similar to a Factory, that's because it is. The difference is that while a factory specializes in creating a specific type of resource, a Container is a general purpose tool that could potentially give you back many different types of objects.\n\n\nCora provides a Container class which can be used to assist with dependency injection and avoid the need for a bunch of factory files. To create a Container, define a resource, and get an instance of that resource works like this:\n\n\n// Create a Container\n$container = new \\Cora\\Container();\n\n// Register a Service\n$container->database = function($c) {\n    return new \\Cora\\Database();\n};\n\n// Grab an object from it\n$db = $container->database;\n\n\n\n\nNow this example is very simple in that we're only defining a single resource and there's no dependencies. Let's dig a little deeper into how we can solve the issues with needing a bunch of extra factories that we ran into earlier when doing injection without any tools.\n\n\nInjection Using a Container\n\n\nBoth General purpose info and Cora specific implementation\n\n\nSo once again we're going back to our Example class which is already setup for dependency injection and looks like so:\n\n\nclass Example\n{\n    // Dependencies\n    protected $mailer;\n    protected $logger;\n    protected $userFactory;\n\n    public function __construct($mailer, $logger, $userFactory)\n    {\n        $this->mailer = $mailer;\n        $this->logger = $logger;\n        $this->userFactory = $userFactory;\n    }\n\n    public function createUser($name)\n    {\n        $user = $userFactory->make($name);\n        $this->mailer->send('Welcome', $user);\n        $this->logger->log('A new user was created');\n    }\n}\n\n\n\n\nThe task before us is to create an instance of the Example class, and in the process handle the injection of its dependencies. \nThe manual way of doing it, which we want to rework, looks like this: \n\n\nclass SomeController\n{\n    public function someMethod() \n    {\n        $example = new Example(\n            new Mailer(new Dependency1, new Dependency2, new Dependency3), \n            new FileLogger(new Dependency1, new Dependency2, new Dependency3), \n            new UserFactory()\n        );\n    }\n}\n\n\n\n\nTo start out, we need to create a Container and register any resources our app will use:\n\n\n// Create a Container\n$container = new \\Cora\\Container();\n\n// Register Resources\n$container->dependency1 = function($c) {\n    return new Dependency1();\n}\n\n$container->dependency2 = function($c) {\n    return new Dependency2();\n}\n\n$container->dependency3 = function($c) {\n    return new Dependency3();\n}\n\n$container->{Example::class} = function($c) {\n    return new Example($c->{Mailer::class}, $c->{FileLogger::class}, $c->{UserFactory::class});\n};\n\n$container->{FileLogger::class} = function($c) {\n    return new FileLogger($c->dependency1, $c->dependency2, $c->dependency3);\n}\n\n$container->{Mailer::class} = function($c) {\n    return new Mailer($c->dependency1, $c->dependency2, $c->dependency3);\n}\n\n$container->{UserFactory::class} = function($c) {\n    return new UserFactory();\n}\n\n\n\n\nHere we defined all the classes we've used in our example. This is probably the worst part of using a Dependency Injection Container, as you have to register any classes you plan on using and tell it how to create instances of them. In the above example I choose to organize the resources alphabetically, but I'd encourage you to do whatever makes sense to you. You could add comment blocks that break your definitions into different sections or utililze a sub-container (see section further down in this document), whatever works.\n\n\nBefore we move on, a few quick things to point out about Cora's implementation. The function that defines each resource is known as a Closure. The \"$c\" parameter that gets passed in to those closures (as you've probably realized) is a self reference to the Container. Each resource is identified by a name, which can be provided as a hard coded string (see Dependency1, Dependency2, Dependency3) or as a generated string by using curly brackets and getting the name of the class it will return such as \"Example::class\". The \"::class\" constant was introduced to PHP in version 5.5, so check if you can use it. Identifying the resource using the ::class constant works well with Intellisense in code editors, which makes inspecting a file to look at the interface a breeze.\n\n\nI'd recommend registering all resources in one place, as this makes reasoning about what resources are available the easiest. Once you have your resources registered, you need to pass your Container to whatever code controls execution flow. In the case of Cora (and many other MVC frameworks) this would be your Controller, and it's usually passed in through the constructor. Modifying our class to use the Container it would now look like:\n\n\nclass SomeController\n{\n    protected $app; // Our Container.\n\n    public function __construct($container) \n    {\n        // Container gets passed in.\n        $this->app = $container;\n    }\n\n    public function someMethod() \n    {\n        // Get a new Example object\n        $example = $this->app->example();\n    }\n}\n\n\n\n\nAnd just like that, our code to grab a new Example object becomes super clean, with all the dependency injections handled for us. I'd say it cost us some pre-setup work to accomplish that, except our other option was to make multiple factory files with the definitions in them, so really this beautiful result cost us nothing extra. Also we get to avoid adding a bunch of factory files to the project. Yay!\n\n\nThere's still usage questions to be answered, so let's continue on...\n\n\nService Locator (anti)Pattern\n\n\nGeneral purpose info - not Cora specific\n\n\nSo some people choose to solve the problem of dependency injection by using a Service Locator (which is a type of Container, but either globally available or passed around between objects) in a way known as the Service Locator Pattern. While a Service Locator / Container can be a useful tool (as just previously described), the Service Locator Pattern is something which should be avoided. Let's dive into that pattern (which many call an \"anti\" pattern because it causes more problems than it solves) and how it works.\n\n\nThe idea behind this pattern is simple and follows this thought process:\n\n\n\nWhy bother doing individual injection of each dependency into your classes? Why not just inject the Service Locator and grab what's needed out of that?\"\n\n\n\nThere's more than one variation on how this pattern can be used, but let's change our Example class to use one of the worst:\n\n\nclass Example\n{\n    // Dependencies\n    protected $app;\n\n    public function __construct($container)\n    {\n        $this->app = $container;\n    }\n\n    public function createUser($name)\n    {\n        $user = $this->app->userFactory->make($name);\n        $this->app->mailer->send('Welcome', $user);\n        $this->app->logger->log('A new user was created');\n    }\n}\n\n\n\n\nAlright, you might be looking at that and thinking it looks fairly clean. Not only that, but the logic behind this pattern might seem to make sense. If the Container is the tool we're using to create objects like a factory, why not just pass it in? Seems like extra work for the same result to define specific dependencies to get injected! However, this way of thinking is a trap.\n\n\nThe biggest problem with the above pattern of passing in a Service Locator and then grabbing what you need out of it, when you need it, is that it's not clear what the dependencies of our class are!!! Now, sure, in a tiny example like we're using here... you can just look and see. But for a real usage scenario, all you'd be able to easily see is the container getting passed in. In order to figure out what the actual dependencies are, you'd have to read through all the methods and look at what's getting grabbed out! This is SUPER bad for having your code be understandable, and will make it much more likely you'll introduce breaking changes without realizing it.\n\n\nWe can refactor to a better version of the pattern like so:\n\n\nclass Example\n{\n    // Dependencies\n    protected $mailer;\n    protected $logger;\n    protected $userFactory;\n\n    public function __construct($container)\n    {\n        $this->mailer = $container->mailer;\n        $this->logger = $container->logger;\n        $this->userFactory = $container->userFactory;\n    }\n\n    public function createUser($name)\n    {\n        $user = $userFactory->make($name);\n        $this->mailer->send('Welcome', $user);\n        $this->logger->log('A new user was created');\n    }\n}\n\n\n\n\nIn this version, at least we're pulling out the services we need in the constructor, so in an interpreted language like PHP that let's us see the source code, we can more easily figure out the dependencies (that's ASSUMING nobody grabs additional stuff out outside the constructor... which is worrying door to have open). However, it still doesn't solve all the issues. First off, let's take a step back from the actual implementation and focus JUST on the interface for our example class. If you were shown the constructor signature for this class without the implementation, would you be able to reason anything about what it does or what it's dependencies are?\n\n\npublic function __construct($container)\n\n\n\n\n^ That signature tells you nothing. Nothing! Regardless of the fact that it \"works\" because it's simple to look at the implemenation in PHP, doesn't make it a good idea. Furthermore, continuing with our line of thinking about the contracts between different software components and black boxes, by passing in a Service Locator you are giving that class access to EVERYTHING. It's like handing over the master key. Handing over that kind of power, but then expecting the class to only use the tiny bit it needs is BAD PRACTICE. Can you get away with it? Probably. Especially in a personal project where you're the only developer. But is a good idea? No.\n\n\n\n\"Passing in the dependencies explicitly forces you as the developer to think about the interfaces between your software components...\"\n\n\n\n\nNot only will you have to worry about that junior developer who ends up working on your app later down the road grabbing things out in the wrong places, it will also make reasoning about the app harder for you too! Passing in the dependencies explicitly forces you as the developer to think about the interfaces between your software components, who's job it is to do what, and what they need to do that job. Just arbitrarily passing around the power to do anything in your application runs the risk of creating spaghetti code.\n\n\nAnd the last couple reasons I'll mention on why this is an anti-pattern are that:\n\n\n\n\nIt creates a dependency on the container (a minor concern)\n\n\nIt ruins the benefit of being able to substitute a dependency that we had by doing normal injection (more important)\n\n\n\n\nOn the first point, if you are just using the Container to handle injection for you from within your Controllers, then theoretically you could remove the Container and switch back to a plain factory implementation without having to change your class files at all. However, once you start grabbing things out of the Service Locator / Container from within your classes, now you've made your application much more dependent on it. \n\n\nTo the second point, a major benefit of dependency injection is the ability to swap dependencies out with other versions, something you lose if you use the Service Locator Pattern. If you wanted to substitute a dependency before running a test, you'd have to redefine the service's definition before running the test, which could be more of a hassle.\n\n\nAvoiding the (anti)Pattern\n\n\nGeneral purpose info that's not Cora specific\n\n\nSo if you have a sharp eye for details, you might have noticed something that looks like a contradiction. In the previous section about basic injection using a Container, we injected our Container into our Controller, and then used it to create a new object within a method like so:\n\n\n// GOOD EXAMPLE\nclass SomeController\n{\n    protected $app; // Our Container\n\n    public function __construct($container) \n    {\n        // Container gets passed in.\n        $this->app = $container;\n    }\n\n    public function someMethod() \n    {\n        // Get a new Example object\n        $example = $this->app->example();\n    }\n}\n\n\n\n\nHowever, in the next section right after that when talking about the Service Locator Anti-Pattern, it's stated that injecting the container and grabbing resources out within methods is a terrible practice! This was the code shown as bad practice:\n\n\n// BAD EXAMPLE\nclass Example\n{\n    // Dependencies\n    protected $app;\n\n    public function __construct($container)\n    {\n        $this->app = $container;\n    }\n\n    public function createUser($name)\n    {\n        $user = $this->app->userFactory->make($name);\n        $this->app->mailer->send('Welcome', $user);\n        $this->app->logger->log('A new user was created');\n    }\n}\n\n\n\n\nSo which is it? Is it bad practice to inject the container and grab stuff out of it or not?\n\n\n\nThe answer is it depends on the roles and responsibilities of the code in question. \n\n\nFirst off, notice that the \"BAD\" example above is injection of the container into a class file belonging to our application, while the \"GOOD\" example is using the container in the context of a Controller. If you think about it, at SOME POINT, SOMEWHERE, actual objects have to get created before you can do dependency injection using them. Whether it's using a factory's make() method or grabbing a resource out of a Container, at some point somebody has to make those creation calls without having the objects handed to them.\n\n\nHypothetically, let's say we wanted to avoid grabbing things out of the Container from within a Controller method, and instead wanted to do dependency injection for our Controllers (SideNote: \nCora actually has this capability\n). Normally, the Router in Cora maps a URL to a Controller method directly, such that the first line in the Controller method is the real \"start\" point in the application (obviously not counting the framework setup code). But let's say we create a new \"Pre-Controller\" logic layer, and have our router map to it rather than our Controller method directly. \n\n\n\n\"it's the Controller's role and responsibility to make the necessary creation calls...\"\n\n\n\n\nThis Pre-Controller now will handle making the calls to create the objects and then inject those dependencies into our Controller! Now our Controller is not tied down with those pesky dependencies! Haha, we're geniuses! Except wait, now our Pre-Controller isn't benefitting from injection! No worries, we'll just create a Pre-Pre-Controller and have it inject into the Pre-Controller and... Ok, you get the point. At some point the buck stops and someone has to make the creation calls without benefitting from injection.\n\n\nAlthough there are different flavors of the MVC pattern, in the context of the Cora framework, a Controller's job is to take any user input, coordinate any calls to backend classes, and then return a response back to the user. A Controller should be kept \"thin\" such that it doesn't implement any of the logic that powers your app, it just coordinates between the user and the domain logic. In this sense, it's the Controller's role and responsibility to make the necessary creation calls and coordinate the high level logic flow into the app by handing off execution control. Which is why, combined with the fact that it handles user input and wouldn't typically be unit tested anyway, that it's perfectly legitimate for it to be using the Container.\n\n\nOn the other hand, the Example class would be a lower level of logic that should use dependency injection for the reasons already discussed.\n\n\nCreating Abstract Factories\n\n\nInfo Specific to the Cora Framework\n\n\nSo we've established that it's best practice to only grab resources out of a Container from within a Controller. Any lower level classes should receive the dependencies they need through injection. But that leaves the question of how do you deal with classes that need to make objects? For example:\n\n\nclass A\n{\n    public function foo()\n    {\n        $results = [];\n        while ($condition) {\n            $results[] = new Item();\n        }\n    }\n}\n\n\n\n\nObviously we can't pass in \"Item\" as a dependency through the constructor, we need to create a variable number of Item objects. Passing in the Container itself is also a no-go, as we've discussed how that's a bad practice. The easy and proper solution is to again utilize a Factory like so:\n\n\nclass A\n{\n    protected $itemFactory;\n\n    public function __construct($itemFactory)\n    {\n        $this->itemFactory = $itemFactory;\n    }\n\n    public function foo()\n    {\n        $results = [];\n        while ($condition) {\n            $results[] = $itemFactory->make();\n        }\n    }\n}\n\n\n\n\nNow the class has a dependency on an ItemFactory who's job it is to create Item objects (all good and proper). However, creating an ItemFactory class adds another file to our filesystem, and also potentially creates code duplication if we end up defining how to create an Item object in both our Container and our ItemFactory. The question we should be asking now is, if we are already defining how to instantiate an object in our Container, can we just reuse that same logic in a Factory? The answer is \"yes\", and the solution is Cora's AbstractFactory class.\n\n\n\nSidenote: Repositories also utilize a Factory. See clarification further down.\n\n\n\n\nAn Abstract Factory works just like any other Factory, the difference being the type of object it makes can be dynamically defined. In our case, we want to create an instance of an AbstractFactory that uses our \"Item\" definition from the Container to define the type of objects it returns. Cora's Container class provides a \"getFactory\" method for this exact purpose. By calling getFactory and passing it the name of a resource, you'll be given back an AbstractFactory configured to return that type of object.\n\n\nWe can use our Dependency Injection Container to define \"class A\" so that it receives a factory for Item like so:\n\n\n// Create a Container\n$container = new \\Cora\\Container();\n\n// Define \"Item\"\n$container->{Item::class} = function($c) {\n    return new Item();\n};\n\n// Define \"class A\"\n$container->{A::class} = function($c) {\n    return new A($c->getFactory(Item::class));\n};\n\n\n\n\nAnd of course using it, we know the Container handles the injection of the factory for us:\n\n\nclass SomeController\n{\n    protected $app; // Our Container\n\n    public function __construct($container) \n    {\n        // Container gets passed in.\n        $this->app = $container;\n    }\n\n    public function someMethod() \n    {\n        // Get a new A object\n        $objectA = $this->app->{A::class};\n    }\n}\n\n\n\n\nRecap\n\n\nSo just to recap the issue of dynamically creating objects from within a class:\n\n\nclass A\n{\n    public function foo()\n    {\n        $results = [];\n        while ($condition) {\n            $results[] = new B(new C());            // Option 1 - BAD, using \"new\" keyword in class.\n            $results[] = $this->app->B();           // Option 2 - BAD, using Service Locator pattern.\n            $results[] = $BFactory->make();         // Option 3 - GOOD. Factory making object from scratch.\n        }\n    }\n}\n\n\n\n\nUtilizing Repositories Instead\n\n\nSo one important clarification I think is needed to avoid confusion when utilizing Cora's ORM. Above we list out 3 options for making an object dynamically, with a Factory being the correct method of doing so. However, there is a 4th option which is also valid, which has to do with fetching an object through a Repository.\n\n\nJust like a Factory's role is to create new objects, a Repository's role is to retrieve objects based off data fetched from a persistance layer (usually a database). Under the hood, a Repository will utilize a Factory to create objects out of the data that gets fetched. Why is this important? Because I don't want anyone getting confused about the roles of a Repository vs a Factory. Both return objects, a repository is just a little higher level of logic and is only concerned with creating objects from existing data, not new objects from scratch.\n\n\nGrabbing objects from a Repository at runtime is perfectly acceptable. Although before using one in a loop, it is important to keep in mind each Repository call will be running a persistance layer (i.e. database) query/search - so keep performance in mind. But we could modify our \"class A\" dependency to utilize a Repository instead of a plain Factory by doing something like so:\n\n\nclass A\n{\n    protected $itemRepo;\n\n    public function __construct($itemRepo)\n    {\n        $this->itemRepo = $itemRepo;\n    }\n\n    public function foo()\n    {\n        $results = $itemRepo->findAll($condition);  // Option 4 - GOOD.\n    }\n}\n\n\n\n\nCreating Static Services\n\n\nInfo Specific to the Cora Framework\n\n\nCora by default creates a new object anytime a resource is requested from it. This is the opposite methodology as some other Containers such as \nPimple\n. If you want a resource to always return the same object, you'll need to either assign a value explicitly or define the resource as a Singleton.\n\n\nDefine as Singleton:\n\n\nIn Container Setup:\n\n\n<?php\n$container = new \\Cora\\Container();\n$container->singleton('singleUser', function($c, $email) {\n    return new \\Models\\User($email);\n});\n\n\n\n\nResult in Usage:\n\n\n$obj1 = $repo->singleUser('Johnny@gmail.com');\n$obj2 = $repo->singleUser('Bobby@gmail.com');\n$obj3 = $repo->singleUser;\necho $obj1->email.\"<br>\";   // Outputs \"Johnny@gmail.com\"\necho $obj2->email.\"<br>\";   // Outputs \"Johnny@gmail.com\"\necho $obj3->email.\"<br>\";   // Outputs \"Johnny@gmail.com\"\n\n\n\n\nResources can be fetched out of Cora's Container either as a resource offset or as a method call. In the above example we use both. Because the closure requires an email for the User object, the first two times we fetch an object we pass along an email address. The last time we forgo passing any runtime input, which if this weren't defined as a Singleton would cause an exception, but in this case doesn't matter.\n\n\nLet's explain what's going on here. When defining resources in the Container using a closure, no resources are created until you ask for them. So when the first call:\n\n\n$obj1 = $repo->singleUser('Johnny@gmail.com');\n\n\n\n\nhappens, there's no object in the container for that resource. It creates the resource as requested, and before handing it back checks if the resource was defined as a Singleton. If yes, then it stores the object created for return on any future requests for that resource. This is why the result of the above code is three pointers to the same object with an email of \"Johnny@gmail.com\".\n\n\nAs a sidenote, I'd recommend avoiding using Singletons for objects that require runtime input like the above example. The fact that you can ask for a User object and pass in an email only to have that email disregarded as happened with \"Bobby@gmail.com\" above could be a point of confusion for developers. I may make that throw an exception in the future... so you've been warned.\n\n\nAssign Explicit Value:\n\n\nIn Container Setup:\n\n\n<?php\n$container = new \\Cora\\Container();\n$container->singleUser = new \\Models\\User('BobbyJones@gmail.com');\n\n\n\n\nResult in Usage:\n\n\n$obj1 = $repo->singleUser('Johnny@gmail.com');\n$obj2 = $repo->singleUser;\necho $obj1->email.\"<br>\";   // Outputs \"BobbyJones@gmail.com\"\necho $obj2->email.\"<br>\";   // Outputs \"BobbyJones@gmail.com\"\n\n\n\n\nIn this case, we assign an object to the \"singleUser\" offset of the Container directly with no closures involved. When asked for that resource later on, the Container will return the object already created.\n\n\nUsing Runtime Inputs\n\n\nInfo Specific to the Cora Framework\n\n\nThis has been covered indirectly many times throughout examples in this article, but let's quickly cover how to pass runtime inputs to a Container resource. A closure that defines a Container resource always must accept a reference to the Container as the first argument. In all our examples this Container reference is denoted by the variable \"c\":\n\n\n$container->{Example::class} = function($c) {\n    return new Example($c->{Mailer::class});\n};\n\n$container->example2 = function($c) {\n    return new Example2();\n};\n\n\n\n\nAs seen above, it's using this \"$c\" Container reference within the closure that allows defining the dependencies that need to be passed in to the object getting created. However, it's important to understand that this self reference to the Container will be given to the closure AUTOMATICALLY. You don't need to do anything except keep the first argument to the closure reserved for it.\n\n\nWhich brings us to passing runtime input to the closure. To pass runtime input, just add new variables after the \"$c\" like so:\n\n\n$container->{Example::class} = function($c, $type, $amount) {\n    return new Example($type, $c->{Mailer::class}, $amount);\n};\n\n$container->example2 = function($c, $name) {\n    return new Example2($name);\n};\n\n\n\n\nThen to get an instance of our Example classes we'd do:\n\n\n$example  = $container->{Example::class}('MyType', 50);\n$example2 = $container->example2('someName');\n\n\n\n\nNotice we're not passing passing any Container reference, that get's handled for us. You just pass along any custom parameters you've defined.\n\n\nSub-Containers\n\n\nInfo Specific to the Cora Framework\n\n\nThere may be times where you want to better organize the resources in your Container or modify the definitions of a certain type of resource in a loop. To that end, Containers have the capability to be nested such that any children still have access to the resources in the parent Container, even though they can be interated over separately.\n\n\nHere's an example:\n\n\n<?php\n// Create main Container\n$container = new \\Cora\\Container();\n\n// Define some resources in main container\n$container->load = function($c) {\n    return new \\Cora\\App\\Load();\n};\n$container->mailer = function($c) {\n    return new \\Cora\\Mailer($c->PHPMailer());\n};\n$container->PHPMailer = function($c) {\n    return new \\PHPMailer;\n};\n\n// Define sub-Container\n$container->listeners = new \\Cora\\Container($container);\n\n// Define sub-sub-Container\n$container->listeners->emails = new \\Cora\\Container($container->listeners);\n\n// Tell the container to return the listeners as closures.\n$container->listeners->emails->returnClosure(true);\n\n// Define a resource in the sub-sub-Container. Uses dependencies defined in the top level Container.\n$container->listeners->emails->sendPasswordResetToken = function($c) {\n    return new \\Listeners\\Emails\\SendPasswordResetToken($c->mailer, $c->load);\n};\n\n\n\n\nIn the above example we define two sub-containers. The first, \"listeners\" is a child of the main Container, and the second, \"emails\" is a child of listeners. Each time we pass in the parent Container in the constructor. Finally, we see in the \"sendPasswordResetToken\" definition that we can use resources defined in any parent Container up the chain. To get an instance of \"sendPasswordResetToken\" you do:\n\n\n$listener = $container->listeners->emails->sendPasswordResetToken;\n\n\n\n\nIf you wanted to perform any actions on one of these sub-groupings of resources you could do so like this:\n\n\n/**\n *  Loop through all our email listeners and stub them all.\n */\nforeach ($this->app->listeners->emails as $listener => $v) {\n    $this->app->listeners->emails->$listener = function($c) {\n        return $c->PHPUnit->getMockBuilder('\\Cora\\Listener')->getMock();\n    };\n}\n\n\n\n\nOne other thing we were able to do with a sub-container is define that all resources defined within that Container should return the closure directly, rather than resolve it into an object. We did that with the line:\n\n\n// Tell the container to return the listeners as closures.\n$container->listeners->emails->returnClosure(true);",
            "title": "Dependency Injection"
        },
        {
            "location": "/documentation/v2/dependency-injection/overview/#dependency-injection",
            "text": "Dependency Injection is a method of decoupling code. The end result is code that's easier to test, easier to modify in the future, and easier to reason about without having to look at the inner workings to understand what's going on.  In this article we'll cover what exactly dependency injection is, how it works using Cora's provided classes, and best practices including potential pitfalls.",
            "title": "Dependency Injection"
        },
        {
            "location": "/documentation/v2/dependency-injection/overview/#an-introduction-to-dependency-injection",
            "text": "General purpose info - not Cora specific  When writing applications, it's common to write code that utilizes other code. For instance, if you are writing a section of your app that sends out emails, you may decide to utilize a 3rd party library such as Amazon's SES (Simple Email Service) to handle the delivery of the emails for you. Or, you may write a class that manages your Users' permissions and reuse that User class across many areas of your app. Code packaging and reuse is an extremely fundamental part of all programming paradigms.  Dependency Injection is the process of passing in (aka \"injecting\") from an external source the dependencies a piece of code relies on. This is important because it decouples to some extent the pieces of code. Let's look at an example of code that DOES NOT use dependency injection:  class Example\n{\n    // Dependencies\n    protected $mailer;\n\n    public function __construct()\n    {\n        $this->mailer = new Mailer();\n    }\n}  Notice the \"new\" declaration which is creating the dependent object. The fact that the dependency is getting created by the class which needs it means it isn't coming from an external source. So why is this generally considered bad? To answer that question imagine you are going to run some automated tests on your code and at some point you call \"$mailer->send()\" to send out an email. During testing you don't want emails getting sent out to people, so you want to stub out the Mailer class using a fake version that won't fire off the email. The problem is, with the setup shown above, you can't easily stub out (aka create a double of) the Mailer class because it's getting created in the constructor.  Let's look at the same code, but have it use injection so the dependency is getting passed in:  class Example\n{\n    // Dependencies\n    protected $mailer;\n\n    public function __construct($mailer)\n    {\n        $this->mailer = $mailer;\n    }\n}  Now with this code, if we need to pass a fake or modified version of any of the Mailer class in, we can! Below we'll pretend we're in our test function and pass our Example class a fake Mailer dependency.  public function myTest() \n{\n    $example = new Example(new FakeMailer());\n}  As long as FakeMailer adheres to the same Interface as Mailer, the Example class will be able to use it just fine without issue, but FakeMailer's send() method will presumably not send out real emails. This concept is referred to as dependency inversion due to the fact that Example is no longer directly dependent on the Mailer class, instead it's dependent on the Mailer Interface.  \nNOTE: An \"Interface\" refers to the publicly available methods within a class. If two classes have the same Interface, that means they both agree to expose a set of matching public methods to consumers of the class. That doesn't mean both classes need to have ALL the same methods, just that they both agree to at least have the methods defined as part of the Interface.  Ok, let's pretend you don't care about testing (I see that smirk...). Is dependency injection still worth doing for other reasons? Yes. The same concept we just showed that can help with testing also can apply to modifying your code in the future. Let's pretend your Example class logs whenever it does something:  class Example\n{\n    // Dependencies\n    protected $mailer;\n    protected $logger;\n\n    public function __construct($mailer)\n    {\n        $this->mailer = $mailer;\n        $this->logger = new DatabaseLogger(); // Logs to a database.\n    }\n\n    public function doWork()\n    {\n        $this->mailer->send('Super Awesome Email');\n        $this->logger->log('A super awesome email was sent out.');\n    }\n}  However, let's say that under certain conditions you don't want to log to a database, but instead want to log to a file. What now? You hardcoded \"DatabaseLogger\" in, so replacing it with say a \"FileLogger\" isn't possible unless you implement a setLogger() method (which is another form of dependency injection). Let's again change it so we inject a logger in through the constructor. With the setup seen below, you could easily pass in a Database or File based logger as necessary depending on your needs:  class Example\n{\n    // Dependencies\n    protected $mailer;\n    protected $logger;\n\n    public function __construct($mailer, $logger)\n    {\n        $this->mailer = $mailer;\n        $this->logger = $logger;\n    }\n\n    public function doWork()\n    {\n        $this->mailer->send('Super Awesome Email');\n        $this->logger->log('A super awesome email was sent out.');\n    }\n}",
            "title": "An Introduction to Dependency Injection"
        },
        {
            "location": "/documentation/v2/dependency-injection/overview/#the-dependency-inversion-principle",
            "text": "General purpose info - not Cora specific  \nWhat we did in the previous section with the injection of the Logging classes, even though we didn't explicitely define the interface, was an example of the Dependency Inversion Principle.    In order to fully understand the principle, it's important to first understand the concepts of Black Box programming and Interfaces:",
            "title": "The Dependency Inversion Principle"
        },
        {
            "location": "/documentation/v2/dependency-injection/overview/#concept-1-black-box-programming",
            "text": "The concept of \"black box\" programming is probably more widely understood in the world of compiled languages than it is in interpreted language communities, but it's an important general programming concept no matter what. Basically, Black Box programming says you shouldn't need to worry about HOW a code library accomplishes a task internally, you should be able to just look at the interface contract and use it. By \"contract\" we're talking a function/library says give me \"X\" input and I'll give you \"Y\" output. How does it take \"X\" input and generate \"Y\" output from it? WE DON'T CARE. The internals are a black box. There could be magical unicorns in there and giant hampster wheels, we just don't care. What matters is the contract between us and that black box of code which governs its usage.  In some compiled languages, you're forced to utilize this concept as you literally can't see the source code, and are only given the public interface.  In interpreted languages like PHP, you can open up the library and inspect how it works internally... however, you really SHOULDN'T NEED TO. As we'll soon discuss, other developers should be able to look at your interface and use the code just from that.",
            "title": "Concept #1: Black Box programming"
        },
        {
            "location": "/documentation/v2/dependency-injection/overview/#concept-2-interfaces",
            "text": "Interfaces are a set of public methods that form the contract between you and the library/class/module/function of code you're using. Interfaces state that if you call method \"X\" and provide it with parameters \"Y\", it will do/return \"Z\" as a result. The most important take away is that Interfaces are independent of the implementation. Going back to the logging example from earlier, if we define a LoggingInterface as such:  interface LoggingInterface\n{\n    /**\n     *  Logs the given message to a persistance layer.\n     *\n     *  @param string $message The message to log.\n     *  @return void\n     */\n    public function log($message);\n}  Then the two possible logging classes for database and file logging would implement that Interface:  class DatabaseLogger implements LoggingInterface\n{\n    public function log($message)\n    {\n        // Code to log to a database...\n    }\n}\n\nclass FileLogger implements LoggingInterface\n{\n    public function log($message)\n    {\n        // Code to log to a file...\n    }\n}  So just to reiterate, Interfaces are independent of any implementation. Rather they represent a contract between you and that piece of software which you can use. As long as you have a clear contract, the internal implmentation details shouldn't matter.",
            "title": "Concept #2: Interfaces"
        },
        {
            "location": "/documentation/v2/dependency-injection/overview/#dependency-inversion",
            "text": "Ok, now that we have that common understanding in place, let's unravel how the Dependency Inversion Principle actually works:  This principle states that: \n     High-level modules should not depend on low-level modules. Both should depend on abstractions. \n     Abstractions should not depend on details. Details should depend on abstractions. \n     \n        - Martin, Robert C. (2003). Agile Software Development, Principles, Patterns, and Practices. Prentice Hall. pp. 127\u2013131. ISBN 978-0135974445.\n       What this principle encourages is thinking about your software system in terms of not just a set of Objects, but rather as a set of Objects AND Interactions between them. Furthermore, thinking about the interactions without regard for the actual implementation. If following the principle 100%, no object would ever be directly tied to another object, but instead the dependency for both would be tied to a set of interactions (an Interface).",
            "title": "Dependency Inversion"
        },
        {
            "location": "/documentation/v2/dependency-injection/overview/#the-following-diagram-shows-this-change-in-dependencies-in-a-visual-way",
            "text": "In the first diagram, class B is directly dependent on the presence of class A. In the second diagram, class B has been changed to have a dependency on an Interface X, an interface which class A implements. In this way, if class A is passed to class B, class B's dependency is satisfied. Of course, with the change to a dependency on an Interface, any other class that implements Interface X would also satisfy class B.  Hopefully those explanations and the Logging example help with understanding how you can improve the adaptability of your application by decoupling direct dependencies between classes. That said, I WOULDN'T necessarily recommend you run out and start making an Interface for everything. The Dependency Inversion principle is a concept that I would argue is important to understand and think about, but also one which you should feel free to break.  In terms of PHP, implementing generic interfaces everywhere in your application can actually make it harder to understand and maintain. Before bothering with an explicit Interface you should examine whether you think you'll ever have another class that uses that same interface, whether you'll need to mock that object, and whether your testing tools even require it for mocking. Just implementing an interface over a class for the sake of having an interface does not by itself reduce coupling in a meaningful way. You really have to be purposeful in thinking about the potential abstraction of interactions and when implementing an Interface will help you achieve a less coupled design.",
            "title": "The following diagram shows this change in dependencies in a visual way:"
        },
        {
            "location": "/documentation/v2/dependency-injection/overview/#injection-without-tools-and-the-challenges-therein",
            "text": "General purpose info - not Cora specific  By now we've hopefully established the merits of dependency injection, and we've also given a simple example or two. But let's dive just a little deeper into how to accomplish it WITHOUT any 3rd party assistance from Cora or other tools. This should hopefully not only be educational but also highlight why having tools like Cora's Container class around to help are nice.  Let's reuse our Example class from earlier that takes both a Mailer and a Logger object as dependencies, but with a couple modifications.  class Example\n{\n    // Dependencies\n    protected $mailer;\n    protected $logger;\n\n    public function __construct($mailer, $logger)\n    {\n        $this->mailer = $mailer;\n        $this->logger = $logger;\n    }\n\n    public function createUser($name)\n    {\n        $user = new User($name);\n        $this->mailer->send('Welcome', $user);\n        $this->logger->log('A new user was created');\n    }\n}  Notice that we're creating a new User object with a name that we won't know until runtime. Needing to dynamically create objects within classes at runtime is a common issue, but the fact that we use the \"new\" operator should raise a red flag. The way it's written above, the Example class has a dependency on the User class, but it's not clear that this dependency exists because we're not passing the User class in through the constructor! No bueno! Ok, so maybe we need to pass the User object in through the constructor... which feels a little weird... but continuing that thought... what if we needed to create multiple User objects in a loop? Whoa, well then passing in a single User object through the constructor definitely wouldn't make sense. In this scenario of having to create objects dynamically at runtime the solution is to use a Factory. Let's add one more dependency in the form of a UserFactory and make that change:  class Example\n{\n    // Dependencies\n    protected $mailer;\n    protected $logger;\n    protected $userFactory;\n\n    public function __construct($mailer, $logger, $userFactory)\n    {\n        $this->mailer = $mailer;\n        $this->logger = $logger;\n        $this->userFactory = $userFactory;\n    }\n\n    public function createUser($name)\n    {\n        $user = $userFactory->make($name);\n        $this->mailer->send('Welcome', $user);\n        $this->logger->log('A new user was created');\n    }\n}  Much Better. Now it's clear we have a dependency on the UserFactory class and we're able to create as many User objects at runtime as we want.  Now let's talk about creating an instance of our Example class. To perform the injection and create a new Example object in the simplest sense, we would just do something like follows:  public function someMethod() \n{\n    $example = new Example(new Mailer(), new FileLogger(), new UserFactory());\n}  Ok, fair enough. However, this is starting to feel kinda verbose don't you agree? I mean, if we only have to create an Example object once or twice in our app... sure. But what if Example is something that gets used in a bunch of places and we want to make this simpler on ourselves? Well the next logical step would be to create an Example factory and use it like so:  class ExampleFactory\n{\n    public static function make() \n    {\n        return new Example(new Mailer(), new FileLogger(), new UserFactory());\n    }\n}\n\nclass SomeController\n{\n    public function someMethod() \n    {\n        $example = ExampleFactory::make();\n    }\n}  Now those pesky dependencies are being handled by our Factory and we just have to ask it to make us a new object. Easy. Time to go home and drink a beer.  But what if our Example class' dependencies also had dependencies?  class ExampleFactory\n{\n    public static function make() \n    {\n        return new Example(new Mailer(new Dependency1, new Dependency2, new Dependency3), new FileLogger(new Dependency1, new Dependency2, new Dependency3), new UserFactory());\n    }\n}  Holy moly Batman! We just got crazy up in here. Let's just get this out of the way, the above is not a good idea. Not only is it hard to read, but if the dependencies of any of those classes ever change, then all the factories that use that class would then also have to be edited. The solution here would be to create some more factories:  class ExampleFactory\n{\n    public static function make() \n    {\n        return new Example(MailerFactory::make(), new FileLoggerFactory::make(), new UserFactory());\n    }\n}  Ok, that looks much better. The downside now is we just had to add a bunch of factory classes to our file system that don't do anything except make us an object. For a small project this is no biggie... however, for larger projects, these factories can end up being (IMO) quite a bit of file system clutter. We'll call this handling injection via Concrete (as opposed to Abstract) Factories.",
            "title": "Injection Without Tools and the Challenges Therein"
        },
        {
            "location": "/documentation/v2/dependency-injection/overview/#pros-and-cons-of-injection-with-concrete-factories",
            "text": "",
            "title": "Pros and Cons of Injection with Concrete Factories"
        },
        {
            "location": "/documentation/v2/dependency-injection/overview/#pros",
            "text": "This form of handling injection works well with IntelliSense. This means you should be able to quickly open files to see what's going on.  Dependencies are known before runtime. The PHP Engine will throw an error at you if a needed dependency is missing. Likewise, if you were using a compiled language, you'd get a compile time error.",
            "title": "Pros:"
        },
        {
            "location": "/documentation/v2/dependency-injection/overview/#cons",
            "text": "Can cause a lot of extra files to be added to your app's file directory.  The additional bloat can potentially make it harder to navigate and understand the app.  Logic for handling dependencies is spread out over many files.",
            "title": "Cons:"
        },
        {
            "location": "/documentation/v2/dependency-injection/overview/#an-introduction-to-dependency-injection-containers",
            "text": "Both General purpose info and Cora specific implementation  A Dependency Injection Container (\"Container\" for short) is a tool that lets you define how to create objects (including any dependencies they need), and then it will handle the work of creating instances of those objects for you. If this sounds oddly similar to a Factory, that's because it is. The difference is that while a factory specializes in creating a specific type of resource, a Container is a general purpose tool that could potentially give you back many different types of objects.  Cora provides a Container class which can be used to assist with dependency injection and avoid the need for a bunch of factory files. To create a Container, define a resource, and get an instance of that resource works like this:  // Create a Container\n$container = new \\Cora\\Container();\n\n// Register a Service\n$container->database = function($c) {\n    return new \\Cora\\Database();\n};\n\n// Grab an object from it\n$db = $container->database;  Now this example is very simple in that we're only defining a single resource and there's no dependencies. Let's dig a little deeper into how we can solve the issues with needing a bunch of extra factories that we ran into earlier when doing injection without any tools.",
            "title": "An Introduction to Dependency Injection Containers"
        },
        {
            "location": "/documentation/v2/dependency-injection/overview/#injection-using-a-container",
            "text": "Both General purpose info and Cora specific implementation  So once again we're going back to our Example class which is already setup for dependency injection and looks like so:  class Example\n{\n    // Dependencies\n    protected $mailer;\n    protected $logger;\n    protected $userFactory;\n\n    public function __construct($mailer, $logger, $userFactory)\n    {\n        $this->mailer = $mailer;\n        $this->logger = $logger;\n        $this->userFactory = $userFactory;\n    }\n\n    public function createUser($name)\n    {\n        $user = $userFactory->make($name);\n        $this->mailer->send('Welcome', $user);\n        $this->logger->log('A new user was created');\n    }\n}  The task before us is to create an instance of the Example class, and in the process handle the injection of its dependencies. \nThe manual way of doing it, which we want to rework, looks like this:   class SomeController\n{\n    public function someMethod() \n    {\n        $example = new Example(\n            new Mailer(new Dependency1, new Dependency2, new Dependency3), \n            new FileLogger(new Dependency1, new Dependency2, new Dependency3), \n            new UserFactory()\n        );\n    }\n}  To start out, we need to create a Container and register any resources our app will use:  // Create a Container\n$container = new \\Cora\\Container();\n\n// Register Resources\n$container->dependency1 = function($c) {\n    return new Dependency1();\n}\n\n$container->dependency2 = function($c) {\n    return new Dependency2();\n}\n\n$container->dependency3 = function($c) {\n    return new Dependency3();\n}\n\n$container->{Example::class} = function($c) {\n    return new Example($c->{Mailer::class}, $c->{FileLogger::class}, $c->{UserFactory::class});\n};\n\n$container->{FileLogger::class} = function($c) {\n    return new FileLogger($c->dependency1, $c->dependency2, $c->dependency3);\n}\n\n$container->{Mailer::class} = function($c) {\n    return new Mailer($c->dependency1, $c->dependency2, $c->dependency3);\n}\n\n$container->{UserFactory::class} = function($c) {\n    return new UserFactory();\n}  Here we defined all the classes we've used in our example. This is probably the worst part of using a Dependency Injection Container, as you have to register any classes you plan on using and tell it how to create instances of them. In the above example I choose to organize the resources alphabetically, but I'd encourage you to do whatever makes sense to you. You could add comment blocks that break your definitions into different sections or utililze a sub-container (see section further down in this document), whatever works.  Before we move on, a few quick things to point out about Cora's implementation. The function that defines each resource is known as a Closure. The \"$c\" parameter that gets passed in to those closures (as you've probably realized) is a self reference to the Container. Each resource is identified by a name, which can be provided as a hard coded string (see Dependency1, Dependency2, Dependency3) or as a generated string by using curly brackets and getting the name of the class it will return such as \"Example::class\". The \"::class\" constant was introduced to PHP in version 5.5, so check if you can use it. Identifying the resource using the ::class constant works well with Intellisense in code editors, which makes inspecting a file to look at the interface a breeze.  I'd recommend registering all resources in one place, as this makes reasoning about what resources are available the easiest. Once you have your resources registered, you need to pass your Container to whatever code controls execution flow. In the case of Cora (and many other MVC frameworks) this would be your Controller, and it's usually passed in through the constructor. Modifying our class to use the Container it would now look like:  class SomeController\n{\n    protected $app; // Our Container.\n\n    public function __construct($container) \n    {\n        // Container gets passed in.\n        $this->app = $container;\n    }\n\n    public function someMethod() \n    {\n        // Get a new Example object\n        $example = $this->app->example();\n    }\n}  And just like that, our code to grab a new Example object becomes super clean, with all the dependency injections handled for us. I'd say it cost us some pre-setup work to accomplish that, except our other option was to make multiple factory files with the definitions in them, so really this beautiful result cost us nothing extra. Also we get to avoid adding a bunch of factory files to the project. Yay!  There's still usage questions to be answered, so let's continue on...",
            "title": "Injection Using a Container"
        },
        {
            "location": "/documentation/v2/dependency-injection/overview/#service-locator-antipattern",
            "text": "General purpose info - not Cora specific  So some people choose to solve the problem of dependency injection by using a Service Locator (which is a type of Container, but either globally available or passed around between objects) in a way known as the Service Locator Pattern. While a Service Locator / Container can be a useful tool (as just previously described), the Service Locator Pattern is something which should be avoided. Let's dive into that pattern (which many call an \"anti\" pattern because it causes more problems than it solves) and how it works.  The idea behind this pattern is simple and follows this thought process:  \nWhy bother doing individual injection of each dependency into your classes? Why not just inject the Service Locator and grab what's needed out of that?\"  There's more than one variation on how this pattern can be used, but let's change our Example class to use one of the worst:  class Example\n{\n    // Dependencies\n    protected $app;\n\n    public function __construct($container)\n    {\n        $this->app = $container;\n    }\n\n    public function createUser($name)\n    {\n        $user = $this->app->userFactory->make($name);\n        $this->app->mailer->send('Welcome', $user);\n        $this->app->logger->log('A new user was created');\n    }\n}  Alright, you might be looking at that and thinking it looks fairly clean. Not only that, but the logic behind this pattern might seem to make sense. If the Container is the tool we're using to create objects like a factory, why not just pass it in? Seems like extra work for the same result to define specific dependencies to get injected! However, this way of thinking is a trap.  The biggest problem with the above pattern of passing in a Service Locator and then grabbing what you need out of it, when you need it, is that it's not clear what the dependencies of our class are!!! Now, sure, in a tiny example like we're using here... you can just look and see. But for a real usage scenario, all you'd be able to easily see is the container getting passed in. In order to figure out what the actual dependencies are, you'd have to read through all the methods and look at what's getting grabbed out! This is SUPER bad for having your code be understandable, and will make it much more likely you'll introduce breaking changes without realizing it.  We can refactor to a better version of the pattern like so:  class Example\n{\n    // Dependencies\n    protected $mailer;\n    protected $logger;\n    protected $userFactory;\n\n    public function __construct($container)\n    {\n        $this->mailer = $container->mailer;\n        $this->logger = $container->logger;\n        $this->userFactory = $container->userFactory;\n    }\n\n    public function createUser($name)\n    {\n        $user = $userFactory->make($name);\n        $this->mailer->send('Welcome', $user);\n        $this->logger->log('A new user was created');\n    }\n}  In this version, at least we're pulling out the services we need in the constructor, so in an interpreted language like PHP that let's us see the source code, we can more easily figure out the dependencies (that's ASSUMING nobody grabs additional stuff out outside the constructor... which is worrying door to have open). However, it still doesn't solve all the issues. First off, let's take a step back from the actual implementation and focus JUST on the interface for our example class. If you were shown the constructor signature for this class without the implementation, would you be able to reason anything about what it does or what it's dependencies are?  public function __construct($container)  ^ That signature tells you nothing. Nothing! Regardless of the fact that it \"works\" because it's simple to look at the implemenation in PHP, doesn't make it a good idea. Furthermore, continuing with our line of thinking about the contracts between different software components and black boxes, by passing in a Service Locator you are giving that class access to EVERYTHING. It's like handing over the master key. Handing over that kind of power, but then expecting the class to only use the tiny bit it needs is BAD PRACTICE. Can you get away with it? Probably. Especially in a personal project where you're the only developer. But is a good idea? No.  \n\"Passing in the dependencies explicitly forces you as the developer to think about the interfaces between your software components...\"  Not only will you have to worry about that junior developer who ends up working on your app later down the road grabbing things out in the wrong places, it will also make reasoning about the app harder for you too! Passing in the dependencies explicitly forces you as the developer to think about the interfaces between your software components, who's job it is to do what, and what they need to do that job. Just arbitrarily passing around the power to do anything in your application runs the risk of creating spaghetti code.  And the last couple reasons I'll mention on why this is an anti-pattern are that:   It creates a dependency on the container (a minor concern)  It ruins the benefit of being able to substitute a dependency that we had by doing normal injection (more important)   On the first point, if you are just using the Container to handle injection for you from within your Controllers, then theoretically you could remove the Container and switch back to a plain factory implementation without having to change your class files at all. However, once you start grabbing things out of the Service Locator / Container from within your classes, now you've made your application much more dependent on it.   To the second point, a major benefit of dependency injection is the ability to swap dependencies out with other versions, something you lose if you use the Service Locator Pattern. If you wanted to substitute a dependency before running a test, you'd have to redefine the service's definition before running the test, which could be more of a hassle.",
            "title": "Service Locator (anti)Pattern"
        },
        {
            "location": "/documentation/v2/dependency-injection/overview/#avoiding-the-antipattern",
            "text": "General purpose info that's not Cora specific  So if you have a sharp eye for details, you might have noticed something that looks like a contradiction. In the previous section about basic injection using a Container, we injected our Container into our Controller, and then used it to create a new object within a method like so:  // GOOD EXAMPLE\nclass SomeController\n{\n    protected $app; // Our Container\n\n    public function __construct($container) \n    {\n        // Container gets passed in.\n        $this->app = $container;\n    }\n\n    public function someMethod() \n    {\n        // Get a new Example object\n        $example = $this->app->example();\n    }\n}  However, in the next section right after that when talking about the Service Locator Anti-Pattern, it's stated that injecting the container and grabbing resources out within methods is a terrible practice! This was the code shown as bad practice:  // BAD EXAMPLE\nclass Example\n{\n    // Dependencies\n    protected $app;\n\n    public function __construct($container)\n    {\n        $this->app = $container;\n    }\n\n    public function createUser($name)\n    {\n        $user = $this->app->userFactory->make($name);\n        $this->app->mailer->send('Welcome', $user);\n        $this->app->logger->log('A new user was created');\n    }\n}  So which is it? Is it bad practice to inject the container and grab stuff out of it or not?  The answer is it depends on the roles and responsibilities of the code in question.   First off, notice that the \"BAD\" example above is injection of the container into a class file belonging to our application, while the \"GOOD\" example is using the container in the context of a Controller. If you think about it, at SOME POINT, SOMEWHERE, actual objects have to get created before you can do dependency injection using them. Whether it's using a factory's make() method or grabbing a resource out of a Container, at some point somebody has to make those creation calls without having the objects handed to them.  Hypothetically, let's say we wanted to avoid grabbing things out of the Container from within a Controller method, and instead wanted to do dependency injection for our Controllers (SideNote:  Cora actually has this capability ). Normally, the Router in Cora maps a URL to a Controller method directly, such that the first line in the Controller method is the real \"start\" point in the application (obviously not counting the framework setup code). But let's say we create a new \"Pre-Controller\" logic layer, and have our router map to it rather than our Controller method directly.   \n\"it's the Controller's role and responsibility to make the necessary creation calls...\"  This Pre-Controller now will handle making the calls to create the objects and then inject those dependencies into our Controller! Now our Controller is not tied down with those pesky dependencies! Haha, we're geniuses! Except wait, now our Pre-Controller isn't benefitting from injection! No worries, we'll just create a Pre-Pre-Controller and have it inject into the Pre-Controller and... Ok, you get the point. At some point the buck stops and someone has to make the creation calls without benefitting from injection.  Although there are different flavors of the MVC pattern, in the context of the Cora framework, a Controller's job is to take any user input, coordinate any calls to backend classes, and then return a response back to the user. A Controller should be kept \"thin\" such that it doesn't implement any of the logic that powers your app, it just coordinates between the user and the domain logic. In this sense, it's the Controller's role and responsibility to make the necessary creation calls and coordinate the high level logic flow into the app by handing off execution control. Which is why, combined with the fact that it handles user input and wouldn't typically be unit tested anyway, that it's perfectly legitimate for it to be using the Container.  On the other hand, the Example class would be a lower level of logic that should use dependency injection for the reasons already discussed.",
            "title": "Avoiding the (anti)Pattern"
        },
        {
            "location": "/documentation/v2/dependency-injection/overview/#creating-abstract-factories",
            "text": "Info Specific to the Cora Framework  So we've established that it's best practice to only grab resources out of a Container from within a Controller. Any lower level classes should receive the dependencies they need through injection. But that leaves the question of how do you deal with classes that need to make objects? For example:  class A\n{\n    public function foo()\n    {\n        $results = [];\n        while ($condition) {\n            $results[] = new Item();\n        }\n    }\n}  Obviously we can't pass in \"Item\" as a dependency through the constructor, we need to create a variable number of Item objects. Passing in the Container itself is also a no-go, as we've discussed how that's a bad practice. The easy and proper solution is to again utilize a Factory like so:  class A\n{\n    protected $itemFactory;\n\n    public function __construct($itemFactory)\n    {\n        $this->itemFactory = $itemFactory;\n    }\n\n    public function foo()\n    {\n        $results = [];\n        while ($condition) {\n            $results[] = $itemFactory->make();\n        }\n    }\n}  Now the class has a dependency on an ItemFactory who's job it is to create Item objects (all good and proper). However, creating an ItemFactory class adds another file to our filesystem, and also potentially creates code duplication if we end up defining how to create an Item object in both our Container and our ItemFactory. The question we should be asking now is, if we are already defining how to instantiate an object in our Container, can we just reuse that same logic in a Factory? The answer is \"yes\", and the solution is Cora's AbstractFactory class.  \nSidenote: Repositories also utilize a Factory. See clarification further down.  An Abstract Factory works just like any other Factory, the difference being the type of object it makes can be dynamically defined. In our case, we want to create an instance of an AbstractFactory that uses our \"Item\" definition from the Container to define the type of objects it returns. Cora's Container class provides a \"getFactory\" method for this exact purpose. By calling getFactory and passing it the name of a resource, you'll be given back an AbstractFactory configured to return that type of object.  We can use our Dependency Injection Container to define \"class A\" so that it receives a factory for Item like so:  // Create a Container\n$container = new \\Cora\\Container();\n\n// Define \"Item\"\n$container->{Item::class} = function($c) {\n    return new Item();\n};\n\n// Define \"class A\"\n$container->{A::class} = function($c) {\n    return new A($c->getFactory(Item::class));\n};  And of course using it, we know the Container handles the injection of the factory for us:  class SomeController\n{\n    protected $app; // Our Container\n\n    public function __construct($container) \n    {\n        // Container gets passed in.\n        $this->app = $container;\n    }\n\n    public function someMethod() \n    {\n        // Get a new A object\n        $objectA = $this->app->{A::class};\n    }\n}",
            "title": "Creating Abstract Factories"
        },
        {
            "location": "/documentation/v2/dependency-injection/overview/#recap",
            "text": "So just to recap the issue of dynamically creating objects from within a class:  class A\n{\n    public function foo()\n    {\n        $results = [];\n        while ($condition) {\n            $results[] = new B(new C());            // Option 1 - BAD, using \"new\" keyword in class.\n            $results[] = $this->app->B();           // Option 2 - BAD, using Service Locator pattern.\n            $results[] = $BFactory->make();         // Option 3 - GOOD. Factory making object from scratch.\n        }\n    }\n}",
            "title": "Recap"
        },
        {
            "location": "/documentation/v2/dependency-injection/overview/#utilizing-repositories-instead",
            "text": "So one important clarification I think is needed to avoid confusion when utilizing Cora's ORM. Above we list out 3 options for making an object dynamically, with a Factory being the correct method of doing so. However, there is a 4th option which is also valid, which has to do with fetching an object through a Repository.  Just like a Factory's role is to create new objects, a Repository's role is to retrieve objects based off data fetched from a persistance layer (usually a database). Under the hood, a Repository will utilize a Factory to create objects out of the data that gets fetched. Why is this important? Because I don't want anyone getting confused about the roles of a Repository vs a Factory. Both return objects, a repository is just a little higher level of logic and is only concerned with creating objects from existing data, not new objects from scratch.  Grabbing objects from a Repository at runtime is perfectly acceptable. Although before using one in a loop, it is important to keep in mind each Repository call will be running a persistance layer (i.e. database) query/search - so keep performance in mind. But we could modify our \"class A\" dependency to utilize a Repository instead of a plain Factory by doing something like so:  class A\n{\n    protected $itemRepo;\n\n    public function __construct($itemRepo)\n    {\n        $this->itemRepo = $itemRepo;\n    }\n\n    public function foo()\n    {\n        $results = $itemRepo->findAll($condition);  // Option 4 - GOOD.\n    }\n}",
            "title": "Utilizing Repositories Instead"
        },
        {
            "location": "/documentation/v2/dependency-injection/overview/#creating-static-services",
            "text": "Info Specific to the Cora Framework  Cora by default creates a new object anytime a resource is requested from it. This is the opposite methodology as some other Containers such as  Pimple . If you want a resource to always return the same object, you'll need to either assign a value explicitly or define the resource as a Singleton.",
            "title": "Creating Static Services"
        },
        {
            "location": "/documentation/v2/dependency-injection/overview/#define-as-singleton",
            "text": "In Container Setup:  <?php\n$container = new \\Cora\\Container();\n$container->singleton('singleUser', function($c, $email) {\n    return new \\Models\\User($email);\n});  Result in Usage:  $obj1 = $repo->singleUser('Johnny@gmail.com');\n$obj2 = $repo->singleUser('Bobby@gmail.com');\n$obj3 = $repo->singleUser;\necho $obj1->email.\"<br>\";   // Outputs \"Johnny@gmail.com\"\necho $obj2->email.\"<br>\";   // Outputs \"Johnny@gmail.com\"\necho $obj3->email.\"<br>\";   // Outputs \"Johnny@gmail.com\"  Resources can be fetched out of Cora's Container either as a resource offset or as a method call. In the above example we use both. Because the closure requires an email for the User object, the first two times we fetch an object we pass along an email address. The last time we forgo passing any runtime input, which if this weren't defined as a Singleton would cause an exception, but in this case doesn't matter.  Let's explain what's going on here. When defining resources in the Container using a closure, no resources are created until you ask for them. So when the first call:  $obj1 = $repo->singleUser('Johnny@gmail.com');  happens, there's no object in the container for that resource. It creates the resource as requested, and before handing it back checks if the resource was defined as a Singleton. If yes, then it stores the object created for return on any future requests for that resource. This is why the result of the above code is three pointers to the same object with an email of \"Johnny@gmail.com\".  As a sidenote, I'd recommend avoiding using Singletons for objects that require runtime input like the above example. The fact that you can ask for a User object and pass in an email only to have that email disregarded as happened with \"Bobby@gmail.com\" above could be a point of confusion for developers. I may make that throw an exception in the future... so you've been warned.",
            "title": "Define as Singleton:"
        },
        {
            "location": "/documentation/v2/dependency-injection/overview/#assign-explicit-value",
            "text": "In Container Setup:  <?php\n$container = new \\Cora\\Container();\n$container->singleUser = new \\Models\\User('BobbyJones@gmail.com');  Result in Usage:  $obj1 = $repo->singleUser('Johnny@gmail.com');\n$obj2 = $repo->singleUser;\necho $obj1->email.\"<br>\";   // Outputs \"BobbyJones@gmail.com\"\necho $obj2->email.\"<br>\";   // Outputs \"BobbyJones@gmail.com\"  In this case, we assign an object to the \"singleUser\" offset of the Container directly with no closures involved. When asked for that resource later on, the Container will return the object already created.",
            "title": "Assign Explicit Value:"
        },
        {
            "location": "/documentation/v2/dependency-injection/overview/#using-runtime-inputs",
            "text": "Info Specific to the Cora Framework  This has been covered indirectly many times throughout examples in this article, but let's quickly cover how to pass runtime inputs to a Container resource. A closure that defines a Container resource always must accept a reference to the Container as the first argument. In all our examples this Container reference is denoted by the variable \"c\":  $container->{Example::class} = function($c) {\n    return new Example($c->{Mailer::class});\n};\n\n$container->example2 = function($c) {\n    return new Example2();\n};  As seen above, it's using this \"$c\" Container reference within the closure that allows defining the dependencies that need to be passed in to the object getting created. However, it's important to understand that this self reference to the Container will be given to the closure AUTOMATICALLY. You don't need to do anything except keep the first argument to the closure reserved for it.  Which brings us to passing runtime input to the closure. To pass runtime input, just add new variables after the \"$c\" like so:  $container->{Example::class} = function($c, $type, $amount) {\n    return new Example($type, $c->{Mailer::class}, $amount);\n};\n\n$container->example2 = function($c, $name) {\n    return new Example2($name);\n};  Then to get an instance of our Example classes we'd do:  $example  = $container->{Example::class}('MyType', 50);\n$example2 = $container->example2('someName');  Notice we're not passing passing any Container reference, that get's handled for us. You just pass along any custom parameters you've defined.",
            "title": "Using Runtime Inputs"
        },
        {
            "location": "/documentation/v2/dependency-injection/overview/#sub-containers",
            "text": "Info Specific to the Cora Framework  There may be times where you want to better organize the resources in your Container or modify the definitions of a certain type of resource in a loop. To that end, Containers have the capability to be nested such that any children still have access to the resources in the parent Container, even though they can be interated over separately.  Here's an example:  <?php\n// Create main Container\n$container = new \\Cora\\Container();\n\n// Define some resources in main container\n$container->load = function($c) {\n    return new \\Cora\\App\\Load();\n};\n$container->mailer = function($c) {\n    return new \\Cora\\Mailer($c->PHPMailer());\n};\n$container->PHPMailer = function($c) {\n    return new \\PHPMailer;\n};\n\n// Define sub-Container\n$container->listeners = new \\Cora\\Container($container);\n\n// Define sub-sub-Container\n$container->listeners->emails = new \\Cora\\Container($container->listeners);\n\n// Tell the container to return the listeners as closures.\n$container->listeners->emails->returnClosure(true);\n\n// Define a resource in the sub-sub-Container. Uses dependencies defined in the top level Container.\n$container->listeners->emails->sendPasswordResetToken = function($c) {\n    return new \\Listeners\\Emails\\SendPasswordResetToken($c->mailer, $c->load);\n};  In the above example we define two sub-containers. The first, \"listeners\" is a child of the main Container, and the second, \"emails\" is a child of listeners. Each time we pass in the parent Container in the constructor. Finally, we see in the \"sendPasswordResetToken\" definition that we can use resources defined in any parent Container up the chain. To get an instance of \"sendPasswordResetToken\" you do:  $listener = $container->listeners->emails->sendPasswordResetToken;  If you wanted to perform any actions on one of these sub-groupings of resources you could do so like this:  /**\n *  Loop through all our email listeners and stub them all.\n */\nforeach ($this->app->listeners->emails as $listener => $v) {\n    $this->app->listeners->emails->$listener = function($c) {\n        return $c->PHPUnit->getMockBuilder('\\Cora\\Listener')->getMock();\n    };\n}  One other thing we were able to do with a sub-container is define that all resources defined within that Container should return the closure directly, rather than resolve it into an object. We did that with the line:  // Tell the container to return the listeners as closures.\n$container->listeners->emails->returnClosure(true);",
            "title": "Sub-Containers"
        },
        {
            "location": "/documentation/v2/events/overview/",
            "text": "Event System\n\n\ntl;dr - You can fire events that trigger the execution of other blocks of code.\n\n\nSo Cora's event system offers an alternate way to execute code from the\nusual controller logic flow. Anything you can accomplish using events you can\nalso accomplish without them, but there are situations where\nusing events may make more sense than traditional controller logic.\n\n\nThe Basic Idea\n\n\nThe basic idea is that somewhere in your executed code (probably a controller),\nyou \"fire\" an Event. That Event will have any number of listeners attached to it\nthat \"listen\" for that event to happen. Each of those listeners are passed a\ncopy of the Event object and then execute whatever action they are designed to\nimplement.\n\n\nSay for instance you are building a game and want a number of things to happen\nwhen a new user registers on your site:\n\n\n\n\nSign the user up for your game's newsletter.\n\n\nCredit the new player's account with a starting amount of in-game credit.\n\n\nForward the user to a special \"Welcome new player\" page.\n\n\n\n\nDoing this using normal Controller based logic might look like this:\n\n\n// A Controller\nclass Users extends \\MyApp\n    public function register()\n    {\n        // Form submission verification\n        // Check that data is valid and username is available.\n        // (not shown)\n\n        // Grab registration form data\n        $username = $this->input->post('username');\n        $email    = $this->input->post('email');\n        $password = $this->input->post('password');\n\n        // Load an Authorization library\n        $auth = new \\Library\\Auth();\n\n        // Register User\n        $auth->register($username, $password, $email);\n\n        // Sign user up for newsletter\n        $newsletter = new Newsletter($this->container);\n        $newsletter->signup($username, $email);\n\n        // Credit user's account with game currency\n        $gameAccount = new GameAccount($this->container);\n        $gameAccount->addCredit($username, 500);\n\n        // Forward user to Welcome page\n        $this->welcome();\n    }\n}\n\n\n\n\nAnd honestly, if you look at the above example, it's not bad. There's perfectly\nnothing wrong with handling the user registration process that way. That said,\nif you wanted to keep your \"register\" method clean of extra code and focused\nsolely on the act of registering a user, using Events is an option. Let's do\nthe same thing again, but this time let's see what the Controller looks like\nwith an Event:",
            "title": "Overview"
        },
        {
            "location": "/documentation/v2/events/overview/#event-system",
            "text": "tl;dr - You can fire events that trigger the execution of other blocks of code.  So Cora's event system offers an alternate way to execute code from the\nusual controller logic flow. Anything you can accomplish using events you can\nalso accomplish without them, but there are situations where\nusing events may make more sense than traditional controller logic.",
            "title": "Event System"
        },
        {
            "location": "/documentation/v2/events/overview/#the-basic-idea",
            "text": "The basic idea is that somewhere in your executed code (probably a controller),\nyou \"fire\" an Event. That Event will have any number of listeners attached to it\nthat \"listen\" for that event to happen. Each of those listeners are passed a\ncopy of the Event object and then execute whatever action they are designed to\nimplement.  Say for instance you are building a game and want a number of things to happen\nwhen a new user registers on your site:   Sign the user up for your game's newsletter.  Credit the new player's account with a starting amount of in-game credit.  Forward the user to a special \"Welcome new player\" page.   Doing this using normal Controller based logic might look like this:  // A Controller\nclass Users extends \\MyApp\n    public function register()\n    {\n        // Form submission verification\n        // Check that data is valid and username is available.\n        // (not shown)\n\n        // Grab registration form data\n        $username = $this->input->post('username');\n        $email    = $this->input->post('email');\n        $password = $this->input->post('password');\n\n        // Load an Authorization library\n        $auth = new \\Library\\Auth();\n\n        // Register User\n        $auth->register($username, $password, $email);\n\n        // Sign user up for newsletter\n        $newsletter = new Newsletter($this->container);\n        $newsletter->signup($username, $email);\n\n        // Credit user's account with game currency\n        $gameAccount = new GameAccount($this->container);\n        $gameAccount->addCredit($username, 500);\n\n        // Forward user to Welcome page\n        $this->welcome();\n    }\n}  And honestly, if you look at the above example, it's not bad. There's perfectly\nnothing wrong with handling the user registration process that way. That said,\nif you wanted to keep your \"register\" method clean of extra code and focused\nsolely on the act of registering a user, using Events is an option. Let's do\nthe same thing again, but this time let's see what the Controller looks like\nwith an Event:",
            "title": "The Basic Idea"
        },
        {
            "location": "/documentation/v2/events/eventmanager/",
            "text": "",
            "title": "Event Manager"
        },
        {
            "location": "/documentation/v2/events/eventmapping/",
            "text": "",
            "title": "Event Mapping"
        },
        {
            "location": "/documentation/v2/events/event/",
            "text": "",
            "title": "Event"
        },
        {
            "location": "/documentation/v2/events/listener/",
            "text": "",
            "title": "Listener"
        },
        {
            "location": "/documentation/v2/mvc/overview/",
            "text": "",
            "title": "Overview"
        },
        {
            "location": "/documentation/v2/mvc/models/",
            "text": "Description of models in the generic MVC sense.",
            "title": "Models"
        },
        {
            "location": "/documentation/v2/mvc/views/",
            "text": "",
            "title": "Views"
        },
        {
            "location": "/documentation/v2/mvc/controllers/",
            "text": "",
            "title": "Controllers"
        },
        {
            "location": "/documentation/v2/mvc/libraries/",
            "text": "$lib = new \\Library\\TestLib();\n\n\n\n\n$this->load->library('Validate', $this, true);",
            "title": "Libraries"
        },
        {
            "location": "/documentation/v2/routing/overview/",
            "text": "Routing in Cora\n\n\nThe default way Cora handles routing is fairly intuitive and I think the general gist can be explained in a few sentences... so here goes:\n\n\n\nCora looks at the URL and matches this against the files and folders in your Controllers directory. To the first matching controller+method combination it discovers, it passes control. If it fails to find a match, it returns a 404 page not found.\n\n\n\nThis can be changed a bit by turning Automatic Routing off and/or defining Custom Routes, but even then the internal routing that happens will follow the logic defined in this document.\n\n\nOk, so to remove the fuzziness on how this works, let's work through some examples. \n\n\nHow it works\n\n\nLet's walk through a few scenarios using a Controllers directory that looks like this:\n\n\n\n\nThe key thing to notice upfront is that there's both a Users controller and a Users folder.\n\n\nLet's say a user goes to the following URL:\n\n\nMySite.com/\nusers/profile\n/view/22\n\n\n\nThe first part of the URL the router is going to look at are the two pieces in red. \n\n\nIt asks the question:  \n\n\nIs there a Users controller?\n\n\nThe answer of course is YES, there is a Users controller. Which leads to the next question of:  \n\n\nIs there a method in the Users controller named \"profile\"?\n\n\n\n\nScenario 1\n\n\n\n\n(reposting image for reference)\n\n\nLet's pretend that there \nIS\n a \"profile\" method in the Users controller and that it looks like this:\n\n\npublic function profile($action, $id)\n{\n    echo $action, \"<br>\", $id;\n}\n\n\n\n\nThe router will have found a matching Controller+Method combination, and so will consider its job done and hand off execution control.\n\n\nWhen application control gets handed off to this method, the remaining two pieces of the URL will get passed in as arguments. So in this case:\n\n\n\n\n$action\n will have the value \n\"view\"\n\n\n$id\n will have the value \n\"22\"\n\n\n\n\n(This isn't a likely use-case for a real app, just explaining how the routing logic works)\n\n\n\n\nScenario 2\n\n\n\n\n(reposting image for reference)\n\n\nLet's pretend that there \nISN'T\n a \"profile\" method in the Users controller. Under this scenario the router will then check if there's instead a \"users\" directory. In our case there is, so it will traverse into that directory and accordingly alter the part of the URL it's looking at.\n\n\nThe router will now focus on this part of the URL:\n\n\nMySite.com/users/\nprofile/view\n/22\n\n\n\nNow it asks the question: \n\n\nIs there a Profile controller inside the Users directory?\n\n\nThe answer is YES, there is a Profile controller. Which you might guess leads to the next question of:  \n\n\nIs there a method in the Profile controller named \"view\"?\n\n\n\n\nYes, there's a \nview\n method:\n   \n\nIn this case, the router will have found a matching Controller+Method combo, and so will pass off control and the remaining piece of the URL (the number 22) will be passed in to that method as an argument if it accepts one.\n\n\n\n\npublic function view($user_id) {\n    // code\n}\n\n\n\n\n\n\nNo, there isn't any \nview\n method:\n   \n\nIf there \nISN'T\n a View method in the Profile controller, then it will repeat the process it did earlier and check if there's a \"profile\" directory inside the \"users\" directory. This time there isn't any subdirectory for it to traverse into, so it will fail to find a matching Controller+Method combo and result in a 404 not found response.\n\n\n\n\n\n\nThe best way to fully understand how the routing works is to play around with it on your own. You should quickly find that it works fairly intuitively. Just make sure your Controllers have the correct namespace (read up on Controllers if you are unfamiliar with what that means).\n\n\nAnother Example\n\n\nLet's say a user goes to:\n\n\nwww.MySite.com/\narticles/news\n/view/107\n\n\n\n\n\nFirst Pass\n\n\nCora checks if there's an \"Articles\" controller with a \"news\" method.\n\n\nPublic function news($action, $id)\n\n\n\n\n\n\n\n\nIF YES\n, then it calls that controller+method and passes it two arguments: \"view\" and \"107\".\n\n\nIF NO\n, then it checks if there's an \"articles\" directory.\n\n\nYes - Then it moves on to 2nd pass.\n\n\nNO - Then it directs user to 404 not found.\n\n\n\n\n\n\n\n\n\n\nSecond Pass\n\n\nCora, now in the \"articles\" directory, refocuses its attention on the next two pieces of the URL:\n\n\nwww.MySite.com/articles/\nnews/view\n/107\n\n\n\n\n\nCora checks if there's a \"News\" controller with a \"view\" method.\n\n\nPublic function view($id)\n\n\n\n\n\n\nIF YES\n, then it calls that controller+method and passes it one argument: \"107\".\n\n\nIF NO\n, then it checks if there's a \"news\" directory.\n\n\nYes - Then it moves on to 3nd pass.\n\n\nNO - Then it directs user to 404 not found.\n\n\n\n\n\n\n\n\n\n\nThird Pass\n\n\nCora, now in the \"news\" directory (which doesn't exist in our screenshots, but let's pretend we had one), \nrefocuses its attention on the next two pieces of the URL:\n\n\nwww.MySite.com/articles/news/\nview/107\n\n\n\n\n\n\nIf RESTful routing enabled (on my default):\n\n\nCora checks if there's a \"View\" controller with an \"itemGET\" method. It knows that a number is not a valid method name, so it makes the assumption that you are trying to fetch an item out of a collection. \"itemGET\" is a pre-defined method name for working with collections. See the RESTful routing section of this article.\n\n\nPublic function itemGET($id)\n\n\n\n\nIs there a View controller with an itemGET method?\n\n\n\n\nIF YES\n, then it calls that controller+method and passes it one argument: \"107\".\n\n\nIF NO\n, Then it directs user to a 404 not found because it's reached the end of the URL.\n\n\n\n\n\n\nIf RESTful routing disabled:\n\n\nCora checks if there's an \"View\" controller with a $default (defined in config) method. Because the URL section it would expect a method to be in is numeric, it directs to the default method and passes the number as an argument.\n\n\nPublic function $default($id)\n\n\n\n\nIs there a View controller with a $default method?\n\n\n\n\nIF YES\n, then it calls that controller+method and passes it one argument: \"107\".\n\n\nIF NO\n, Then it directs user to a 404 not found because it's reached the end of the URL.\n\n\n\n\nVisibility\n\n\nA little, but important thing to know about how Cora's routing works is that it obeys the visibility definitions on your methods. So if you define a method as protected or private, \nIT WILL NOT BE ACCESSIBLE FROM A URL\n. If someone tried going to a URL that gets routed to a non-public method, they will instead be given a 404 Not Found response.\n\n\nAgain, the goal was to make automatic routing feel natural and work in a way that makes sense.\n\n\nRESTful Routing\n\n\nBy default, RESTful routing is enabled in Cora's config. What this does is cause requests to the same URL to route to different controller methods in your app depending on the HTTP method defined in the request.\n\n\nIn the examples below, we are going to assume the default method in Cora's config is defined to be \"index\" (unless you've changed it, that's what it normally is).\n\n\nA Request to a Collection\n\n\nA request to \nwww.MySite.com/articles/\n of the following types works like this:\n\n\n\n    \n\n        \nRequest Type\n\n        \nRouted to Method\n\n        \nExpected Result (you have to implement)\n\n    \n\n    \n\n        \nGET /articles/\n\n        \nindex()\n\n        \nUser views collection of articles\n\n    \n\n    \n\n        \nPOST /articles/\n\n        \nindexPOST()\n\n        \nCreate a new article\n\n    \n\n    \n\n        \nPUT /articles/\n\n        \nindexPUT()\n\n        \nReplace a collection with another\n\n    \n\n    \n\n        \nDELETE /articles/\n\n        \nindexDELETE()\n\n        \nDelete collection\n\n    \n\n    \n\n        \n\n        \n\n        \n\n    \n\n    \n\n        \nGET /articles/107\n\n        \nitemGET($id)\n\n        \nView a specific article\n\n    \n\n    \n\n        \nPOST /articles/107\n\n        \nitemPOST($id)\n\n        \nNOT TYPICALLY USED\n\n    \n\n    \n\n        \nPUT /articles/107\n\n        \nitemPUT($id)\n\n        \nUpdate a specific article\n\n    \n\n    \n\n        \nDELETE /articles/107\n\n        \nitemDELETE($id)\n\n        \nDELETE a specific article\n\n    \n\n\n\n\n\nA Request to a Method/Action\n\n\nA request to \nwww.MySite.com/articles/create/\n of the following types works like this:  \n\n\nNote that any remaining pieces of the URL will get passed in as variables to the method.\n\n\n\n    \n\n        \nRequest Type\n\n        \nRouted to Method\n\n        \nExpected Result (you have to implement)\n\n    \n\n    \n\n        \nGET /articles/create/\n\n        \ncreate()\n\n        \nShow creation form\n\n    \n\n    \n\n        \nPOST /articles/create/\n\n        \ncreatePOST()\n\n        \nProcess form submission\n\n    \n\n    \n\n        \nPUT /articles/create/\n\n        \ncreatePUT()\n\n        \nNothing. See collections instead\n\n    \n\n    \n\n        \nDELETE /articles/create/\n\n        \ncreateDELETE()\n\n        \nNothing. See collections instead\n\n    \n\n\n\n\n\nRouting Options\n\n\nThere's a few routing options that can be set in the config. They are as follows:\n\n\nMost used options (also shows default values)\n\n\n\n\n\n\n$config['automatic_routing'] = true;\n \n\nShould Cora try to automatically match URLs to a controller+method? If this is turned off, then you WILL HAVE TO manually define a route for every part of your application using custom route definitions.\n\n\n\n\n\n\n$config['enable_RESTful'] = true;\n \n\nShould Cora route differently depending on the incoming HTTP request type?\n\n\n\n\n\n\n$config['default_controller'] = 'Home';\n \n\nWhat is the default controller users should be sent to if they visit your homepage? (www.MySite.com)\n\n\n\n\n\n\n$config['default_method'] = 'index';\n  \n\nWhat is the default method for controllers? If a user goes to www.MySite.com/articles/ what method within the Articles controller should be given execution control?\n\n\n\n\n\n\nOptions that have to be set correctly, but can usually be left as default\n\n\n\n\n\n\n$config['lowercase_url'] = true;\n  \n\nIf your project is hosted on a case-sensitive system (e.g. Linux) and you want a URL to work regardless of whether a user typed part of it as uppercase.\n\n\n\n\n\n\n$config['psr4_namespaces'] = TRUE;\n  \n\nBy Default, all classes in your app must be namespaced. If your controllers are located in a \"controllers\" directory, they must have a namespace of \"controllers\". If your models are in a \"models\" directory, they must have the namespace \"models\", etc. If you are working with a legacy app that was not built with namespacing in mind, you have the option to turn this off. If off, all controllers, models, classes, libraries, etc, in their respective root folders (/classes, /models, /controllers) will be in the global namespace.\n\n\n\n\n\n\n$config['pathToControllers'] = $config['basedir'].'controllers/';\n  \n\nIf for some reason you want your controllers to be located elsewhere than in the Controllers directory.\n\n\n\n\n\n\n$config['controllersPrefix'] = 'controller.';\n  \n\nPrefix for your controller files. E.g. controller.Articles.php\n\n\n\n\n\n\n$config['controllersPostfix'] = '';\n  \n\nPostfix for your controller files. E.g. controller.Articles.inc.php\n\n\n\n\n\n\nCustom Routes Introduction\n\n\nCustom routes allow you to control how URLs are routed within your application. Some examples of things you can do with them include:\n\n\n\n\nMake a URL more friendly by hiding the exact internal route to reach the Controller.\n\n\nRedirect specific parts of your app to new Controllers without affecting functionality that hasn't been upgraded yet.\n\n\nCheck user permissions before allowing access to parts of your site. \n\n\netc\n\n\n\n\nAlso, some teams may not like the idea of Automatic Routing and may instead want to manually define all the routes - fair enough. All this is accomplished by defining \"paths\" for your app. An example might look like this:\n\n\n// Let's forward GET and PUT requests to our api to the new version 2.\n$path = new \\Cora\\Path();\n    $path->url = '/api/{collection}/{id}';          // The URL entered in a web browser\n    $path->route = '/api/v2/{collection}/{id}';     // The internal route that Cora will use.\n    $path->def['{id}'] = '[0-9]+';                  // Defining ID to be numeric.\n    $path->actions = 'GET|PUT';                     // The HTTP request types to match to this path.\n$paths->add($path);\n\n\n\n\nTo learn more about Custom Routes check out the documentation page on that topic under Routing. Clicking the button below will take you straight there.\n\n\n\n\nCustom Routes Documentation",
            "title": "Overview"
        },
        {
            "location": "/documentation/v2/routing/overview/#routing-in-cora",
            "text": "The default way Cora handles routing is fairly intuitive and I think the general gist can be explained in a few sentences... so here goes:  \nCora looks at the URL and matches this against the files and folders in your Controllers directory. To the first matching controller+method combination it discovers, it passes control. If it fails to find a match, it returns a 404 page not found.  This can be changed a bit by turning Automatic Routing off and/or defining Custom Routes, but even then the internal routing that happens will follow the logic defined in this document.  Ok, so to remove the fuzziness on how this works, let's work through some examples.",
            "title": "Routing in Cora"
        },
        {
            "location": "/documentation/v2/routing/overview/#how-it-works",
            "text": "Let's walk through a few scenarios using a Controllers directory that looks like this:   The key thing to notice upfront is that there's both a Users controller and a Users folder.  Let's say a user goes to the following URL: \nMySite.com/ users/profile /view/22  The first part of the URL the router is going to look at are the two pieces in red.   It asks the question:    Is there a Users controller?  The answer of course is YES, there is a Users controller. Which leads to the next question of:    Is there a method in the Users controller named \"profile\"?",
            "title": "How it works"
        },
        {
            "location": "/documentation/v2/routing/overview/#scenario-1",
            "text": "(reposting image for reference)  Let's pretend that there  IS  a \"profile\" method in the Users controller and that it looks like this:  public function profile($action, $id)\n{\n    echo $action, \"<br>\", $id;\n}  The router will have found a matching Controller+Method combination, and so will consider its job done and hand off execution control.  When application control gets handed off to this method, the remaining two pieces of the URL will get passed in as arguments. So in this case:   $action  will have the value  \"view\"  $id  will have the value  \"22\"   (This isn't a likely use-case for a real app, just explaining how the routing logic works)",
            "title": "Scenario 1"
        },
        {
            "location": "/documentation/v2/routing/overview/#scenario-2",
            "text": "(reposting image for reference)  Let's pretend that there  ISN'T  a \"profile\" method in the Users controller. Under this scenario the router will then check if there's instead a \"users\" directory. In our case there is, so it will traverse into that directory and accordingly alter the part of the URL it's looking at.  The router will now focus on this part of the URL: \nMySite.com/users/ profile/view /22  Now it asks the question:   Is there a Profile controller inside the Users directory?  The answer is YES, there is a Profile controller. Which you might guess leads to the next question of:    Is there a method in the Profile controller named \"view\"?   Yes, there's a  view  method:     \nIn this case, the router will have found a matching Controller+Method combo, and so will pass off control and the remaining piece of the URL (the number 22) will be passed in to that method as an argument if it accepts one.   public function view($user_id) {\n    // code\n}   No, there isn't any  view  method:     \nIf there  ISN'T  a View method in the Profile controller, then it will repeat the process it did earlier and check if there's a \"profile\" directory inside the \"users\" directory. This time there isn't any subdirectory for it to traverse into, so it will fail to find a matching Controller+Method combo and result in a 404 not found response.    The best way to fully understand how the routing works is to play around with it on your own. You should quickly find that it works fairly intuitively. Just make sure your Controllers have the correct namespace (read up on Controllers if you are unfamiliar with what that means).",
            "title": "Scenario 2"
        },
        {
            "location": "/documentation/v2/routing/overview/#another-example",
            "text": "Let's say a user goes to: \nwww.MySite.com/ articles/news /view/107",
            "title": "Another Example"
        },
        {
            "location": "/documentation/v2/routing/overview/#first-pass",
            "text": "Cora checks if there's an \"Articles\" controller with a \"news\" method.  Public function news($action, $id)    IF YES , then it calls that controller+method and passes it two arguments: \"view\" and \"107\".  IF NO , then it checks if there's an \"articles\" directory.  Yes - Then it moves on to 2nd pass.  NO - Then it directs user to 404 not found.",
            "title": "First Pass"
        },
        {
            "location": "/documentation/v2/routing/overview/#second-pass",
            "text": "Cora, now in the \"articles\" directory, refocuses its attention on the next two pieces of the URL: \nwww.MySite.com/articles/ news/view /107   Cora checks if there's a \"News\" controller with a \"view\" method.  Public function view($id)   IF YES , then it calls that controller+method and passes it one argument: \"107\".  IF NO , then it checks if there's a \"news\" directory.  Yes - Then it moves on to 3nd pass.  NO - Then it directs user to 404 not found.",
            "title": "Second Pass"
        },
        {
            "location": "/documentation/v2/routing/overview/#third-pass",
            "text": "Cora, now in the \"news\" directory (which doesn't exist in our screenshots, but let's pretend we had one), \nrefocuses its attention on the next two pieces of the URL: \nwww.MySite.com/articles/news/ view/107    If RESTful routing enabled (on my default):  Cora checks if there's a \"View\" controller with an \"itemGET\" method. It knows that a number is not a valid method name, so it makes the assumption that you are trying to fetch an item out of a collection. \"itemGET\" is a pre-defined method name for working with collections. See the RESTful routing section of this article.  Public function itemGET($id)  Is there a View controller with an itemGET method?   IF YES , then it calls that controller+method and passes it one argument: \"107\".  IF NO , Then it directs user to a 404 not found because it's reached the end of the URL.    If RESTful routing disabled:  Cora checks if there's an \"View\" controller with a $default (defined in config) method. Because the URL section it would expect a method to be in is numeric, it directs to the default method and passes the number as an argument.  Public function $default($id)  Is there a View controller with a $default method?   IF YES , then it calls that controller+method and passes it one argument: \"107\".  IF NO , Then it directs user to a 404 not found because it's reached the end of the URL.",
            "title": "Third Pass"
        },
        {
            "location": "/documentation/v2/routing/overview/#visibility",
            "text": "A little, but important thing to know about how Cora's routing works is that it obeys the visibility definitions on your methods. So if you define a method as protected or private,  IT WILL NOT BE ACCESSIBLE FROM A URL . If someone tried going to a URL that gets routed to a non-public method, they will instead be given a 404 Not Found response.  Again, the goal was to make automatic routing feel natural and work in a way that makes sense.",
            "title": "Visibility"
        },
        {
            "location": "/documentation/v2/routing/overview/#restful-routing",
            "text": "By default, RESTful routing is enabled in Cora's config. What this does is cause requests to the same URL to route to different controller methods in your app depending on the HTTP method defined in the request.  In the examples below, we are going to assume the default method in Cora's config is defined to be \"index\" (unless you've changed it, that's what it normally is).",
            "title": "RESTful Routing"
        },
        {
            "location": "/documentation/v2/routing/overview/#a-request-to-a-collection",
            "text": "A request to  www.MySite.com/articles/  of the following types works like this:  \n     \n         Request Type \n         Routed to Method \n         Expected Result (you have to implement) \n     \n     \n         GET /articles/ \n         index() \n         User views collection of articles \n     \n     \n         POST /articles/ \n         indexPOST() \n         Create a new article \n     \n     \n         PUT /articles/ \n         indexPUT() \n         Replace a collection with another \n     \n     \n         DELETE /articles/ \n         indexDELETE() \n         Delete collection \n     \n     \n         \n         \n         \n     \n     \n         GET /articles/107 \n         itemGET($id) \n         View a specific article \n     \n     \n         POST /articles/107 \n         itemPOST($id) \n         NOT TYPICALLY USED \n     \n     \n         PUT /articles/107 \n         itemPUT($id) \n         Update a specific article \n     \n     \n         DELETE /articles/107 \n         itemDELETE($id) \n         DELETE a specific article",
            "title": "A Request to a Collection"
        },
        {
            "location": "/documentation/v2/routing/overview/#a-request-to-a-methodaction",
            "text": "A request to  www.MySite.com/articles/create/  of the following types works like this:    Note that any remaining pieces of the URL will get passed in as variables to the method.  \n     \n         Request Type \n         Routed to Method \n         Expected Result (you have to implement) \n     \n     \n         GET /articles/create/ \n         create() \n         Show creation form \n     \n     \n         POST /articles/create/ \n         createPOST() \n         Process form submission \n     \n     \n         PUT /articles/create/ \n         createPUT() \n         Nothing. See collections instead \n     \n     \n         DELETE /articles/create/ \n         createDELETE() \n         Nothing. See collections instead",
            "title": "A Request to a Method/Action"
        },
        {
            "location": "/documentation/v2/routing/overview/#routing-options",
            "text": "There's a few routing options that can be set in the config. They are as follows:",
            "title": "Routing Options"
        },
        {
            "location": "/documentation/v2/routing/overview/#most-used-options-also-shows-default-values",
            "text": "$config['automatic_routing'] = true;   \nShould Cora try to automatically match URLs to a controller+method? If this is turned off, then you WILL HAVE TO manually define a route for every part of your application using custom route definitions.    $config['enable_RESTful'] = true;   \nShould Cora route differently depending on the incoming HTTP request type?    $config['default_controller'] = 'Home';   \nWhat is the default controller users should be sent to if they visit your homepage? (www.MySite.com)    $config['default_method'] = 'index';    \nWhat is the default method for controllers? If a user goes to www.MySite.com/articles/ what method within the Articles controller should be given execution control?",
            "title": "Most used options (also shows default values)"
        },
        {
            "location": "/documentation/v2/routing/overview/#options-that-have-to-be-set-correctly-but-can-usually-be-left-as-default",
            "text": "$config['lowercase_url'] = true;    \nIf your project is hosted on a case-sensitive system (e.g. Linux) and you want a URL to work regardless of whether a user typed part of it as uppercase.    $config['psr4_namespaces'] = TRUE;    \nBy Default, all classes in your app must be namespaced. If your controllers are located in a \"controllers\" directory, they must have a namespace of \"controllers\". If your models are in a \"models\" directory, they must have the namespace \"models\", etc. If you are working with a legacy app that was not built with namespacing in mind, you have the option to turn this off. If off, all controllers, models, classes, libraries, etc, in their respective root folders (/classes, /models, /controllers) will be in the global namespace.    $config['pathToControllers'] = $config['basedir'].'controllers/';    \nIf for some reason you want your controllers to be located elsewhere than in the Controllers directory.    $config['controllersPrefix'] = 'controller.';    \nPrefix for your controller files. E.g. controller.Articles.php    $config['controllersPostfix'] = '';    \nPostfix for your controller files. E.g. controller.Articles.inc.php",
            "title": "Options that have to be set correctly, but can usually be left as default"
        },
        {
            "location": "/documentation/v2/routing/overview/#custom-routes-introduction",
            "text": "Custom routes allow you to control how URLs are routed within your application. Some examples of things you can do with them include:   Make a URL more friendly by hiding the exact internal route to reach the Controller.  Redirect specific parts of your app to new Controllers without affecting functionality that hasn't been upgraded yet.  Check user permissions before allowing access to parts of your site.   etc   Also, some teams may not like the idea of Automatic Routing and may instead want to manually define all the routes - fair enough. All this is accomplished by defining \"paths\" for your app. An example might look like this:  // Let's forward GET and PUT requests to our api to the new version 2.\n$path = new \\Cora\\Path();\n    $path->url = '/api/{collection}/{id}';          // The URL entered in a web browser\n    $path->route = '/api/v2/{collection}/{id}';     // The internal route that Cora will use.\n    $path->def['{id}'] = '[0-9]+';                  // Defining ID to be numeric.\n    $path->actions = 'GET|PUT';                     // The HTTP request types to match to this path.\n$paths->add($path);  To learn more about Custom Routes check out the documentation page on that topic under Routing. Clicking the button below will take you straight there.   Custom Routes Documentation",
            "title": "Custom Routes Introduction"
        },
        {
            "location": "/documentation/v2/routing/custom_routes/",
            "text": "Custom Routes\n\n\nDefining custom routes can serve several purposes. The primary purpose is to allow a URL to be mapped to a different internal address. Another primary purpose is to perform authorization checking on sections of a site.\nIn Cora, custom routes are implemented by defining \"paths\" from a URL to some internal address.\n\n\nUnderstanding Cora's Implementation\n\n\nThe code in Cora's Route class that pertains to hooking up custom defined routes looks like the below. It creates an empty array of paths called \"$paths\", loads \"Cora\\App\\Paths.php\" if it exists in the project, then finalizes \"$paths\" as the custom path array.\n\n\n$paths = [];\nif (file_exists($this->config['basedir'].'cora/app/Paths.php')) {\n    include($this->config['basedir'].'cora/app/Paths.php');\n}\n$this->paths = $paths;\n\n\n\n\nSo in order to define custom routes for our app, all we need to do is create that file in our Cora\\App directory and define $paths to be something that isn't an empty array.\n\n\nExample Cora/App/Paths.php file:\n\n\n<?php\n// Create paths container\n$paths = new \\Cora\\Container();\n\n// Path 1\n$path = new \\Cora\\Path();\n    $path->url = '/users/login';\n    $path->route = '/users/newLogin';\n$paths->add($path);\n\n// Path 2\n$path = new \\Cora\\Path();\n    $path->url = '/users/forgotPassword';\n    $path->route = '/users/newForgotPassword';\n$paths->add($path);\n\n\n\n\nAlternate Syntax:\n\n\nA quick note before we dive into things. The examples given in this document use regular object syntax, where each Path is an object, we define some properties on each, and then add them to our Paths collection. Alternatively, developers may prefer to pass in the path definition as an array to the constructor. This allows for some cleaner in-lining, and may be visually less cluttered to some peoples' eyes. The above example using this syntax looks like this:\n\n\n <?php\n// Create paths container\n$paths = new \\Cora\\Container();\n\n// Path 1\n$paths->add(new \\Cora\\Path([\n    'url'   => '/users/login',\n    'route' => '/users/newLogin'\n]));\n\n// Path 2\n$paths->add(new \\Cora\\Path([\n    'url'   => '/users/forgotPassword',\n    'route' => '/users/newForgotPassword'\n]));\n\n\n\n\nFeel free to use that syntax if you prefer it.\n\n\nSimple Internal Redirect\n\n\nThe simplest example of using a custom route is just going to be re-routing some URL to a different internal address. This takes defining a path with two attributes, the URL you want to match in the user's browser and the internal route you actually want executed.\n\n\n$path = new \\Cora\\Path();\n    $path->url = '/users/login';\n    $path->route = '/users/newLogin';\n$paths->add($path);\n\n\n\n\nIn this example, going to \"www.MySite.com/users/login\" will internally (not visible to the user) get redirected to \"www.MySite.com/users/newLogin\".\n\n\nURL Variables\n\n\nA more advanced feature of custom routes is the ability to use variables in the URL and internal Route. By default variables will capture letters, numbers, and underscores, but you can define them however you need.\n\n\nIn the below example, if a user were to go to:\n\n\nMySite.com/blogs/politics-bjohnson\n\n\n\n\nthis would get redirected to an internal address of: \n\n\nMySite.com/articles/personal/view/bjohnson/politics\n\n\n\n\nExample:\n\n\n$path = new \\Cora\\Path();\n    $path->url = '/blogs/{category}-{person}';\n    $path->route = '/articles/personal/view/{person}/{category}';\n$paths->add($path);\n\n\n\n\nVariables in the URL must have a separator of some sort between them. In the example above, the separator is a hyphen, but it could have just as easily been a forward slash like in the \"route\" attribute. Also notice that we reversed the order of {category} and {person} in the route. Once you've defined part of the input URL as a variable, you can reuse that variable however you like in the internal route.\n\n\nThe variables grabbed from the URL in this way will be available to the preMatch and preExec methods as an array named \"vars\". Using the example from above, it works like this to check if the category being viewed is politics:\n\n\n$path->preExec = function($vars, $app) {\n    if ($vars['category'] == 'politics') {\n        return true; // grant access\n    }\n    return false; // deny access\n};\n\n\n\n\nDefining Variables\n\n\nYou can define variables in your URL using regular expressions if you need them to match a particular format. The most common use-case for this would likely be defining that a variable must be a number.\n\n\n$path = new \\Cora\\Path();\n    $path->url = '/blogs/{id}';\n    $path->route = '/articles/personal/{id}';\n    $path->def['{id}'] = '[0-9]+';\n$paths->add($path);\n\n\n\n\n\nIn the above example we use a regular expression to define {id} as being a number.\n\n\n{Anything} Variable\n\n\nThere's one special variable name which is predefined for you to match any character. That special variable is {anything}. {Anything} is useful when you don't care what the end of the URL is, but you do need to use it.\n\n\nSay you have the following valid URLs as part of your app:\n\n\nMySite.com/pets/dogs/retrievers\nMySite.com/pets/dogs/terriers\nMySite.com/pets/cats/persians/view/56\n\n\n\n\nBut you are re-organizing your site and decided to rename your Pets controller to Animals. The only problem is, you don't want to break links that people have bookmarked using the old version. A solution in this case would be to use the {anything} variable as a wildcard like so:\n\n\n$path = new \\Cora\\Path();\n    $path->url = '/pets/{anything}';\n    $path->route = '/animals/{anything}';\n    $path->passive = true;\n$paths->add($path);\n\n\n\n\nThis would capture and redirect all the requests that start with Pets to instead use Animals, without having to worry about defining a specific route for each possible path that was available under Pets.\n\n\nThe \"passive\" attribute is likely something that would want to be used here, so it's included. You can read about it further down in this documentation.\n\n\nHTTP Methods\n\n\nBy default, paths will be matched for all HTTP methods. Then once a path is matched and a route is executed, Cora's normal handling of HTTP methods will apply (a POST request being routed to methodPOST for example). However, both these behaviors can be changed on a path by path basis.\n\n\nTo make your path only match HTTP requests of a certain type, define an \"actions\" attribute on the path with the methods you want listed like so:\n\n\n$path = new \\Cora\\Path();\n    $path->url = '/users/test/{action}-{action2}';\n    $path->route = '/home/view/{action2}/{action}';\n    $path->actions = 'GET|POST';\n$paths->add($path);\n\n\n\n\nTo disable Cora's RESTful routing behavior for a path, define an attribute \"RESTful\" as false:\n\n\n$path = new \\Cora\\Path();\n    $path->url = '/articles/api';\n    $path->route = '/articles/api/create';\n    $path->actions = 'POST';\n    $path->RESTful = false;\n$paths->add($path);\n\n\n\n\nIn the above example, a POST request to:\n\n\nMySite.com/articles/api\n\n\n\n\nWould get routed to the \"Articles/Api\" controller and \"create\" method (Not createPOST).\n\n\nRoute Authentication\n\n\nSo another popular use case for custom routes is going to be protecting certain features or sections of a site from un-authorized users. The way you can do that with custom routes is using the \"preExec\" attribute to define a function. If this preExec function returns false, execution of the path will be prevented.\n\n\nIn the example below \"$app\" is Cora's container. From it we are calling Cora's Auth library to check if a user is logged in. You can read-up on Cora's Auth library or use your own permission system if you like. Just remember that if this function returns false execution of the path will be prevented. The \"$vars\" parameter holds any variables defined in the URL (see URL Variables section).\n\n\nExample:\n\n\n$path = new \\Cora\\Path();\n    $path->url = '/home/private';\n    $path->route = '/home/view/protected/area';\n    $path->preExec = function($vars, $app) {\n        if (!$app->auth->access(new \\Models\\Auth\\LoggedIn)) { return false; }\n        return true;\n    };\n$paths->add($path);\n\n\n\n\nClosely tied to route authentication is the use of Passive routes. So make sure to check out that section.\n\n\nPassive Routes\n\n\nNormally, the search for custom routes that match the URL ends after the first match found. However, when performing authentication for a route, you may not want this behavior. Say for instance that you have a \"Private\" controller and you want anything in that controller or in the Private subdirectory to be protected from unauthorized access. In this scenario you may want to check that a user has access, then have the search for custom routes continue afterwards. This is where \"Passive\" routes come into play.\n\n\nFirst let's look at an example without a passive path that DOESN'T work, and explain why:\n\n\n$path = new \\Cora\\Path();\n    $path->url = '/dashboard/{anything}';\n    $path->route = '/v2/dashboard/{anything}';\n$paths->add($path);\n\n\n$path = new \\Cora\\Path();\n    $path->url = '/v2/dashboard/admin/{anything}';\n    $path->preExec = function($vars, $app) {\n        if ($app->auth->access(new \\Models\\Auth\\IsAdmin)) { return true; }\n        return false;\n    };\n$paths->add($path);\n\n\n\n\nIn the above example, there's two things going on. First, we are redirecting any requests for the Dashboard to instead use version 2 of the dashboard. Second, we are making sure any requests for access to the Admin area of the dashboard are checked for the proper permissions. However, this code will not work as desired. The problem is that in order to not waste processing power, Cora will stop at the first non-passive custom route it finds that matches the current URL. So because the \"dashboard/{anything}\" path is defined first, that will get matched for any request to the dashboard area and executed. It WILL properly redirect the request internally to V2, but then it will check for a valid Controller+Method combo without looking at the 2nd custom path that specifies the authentication check for the admin area.\n\n\nThe solution to this problem, is to add the \"passive\" attribute to the first path so that Cora will restart the search for matching custom paths after the internal route gets changed to v2. In the same example below with the passive attribute, cora will run the first path and change the route to v2, then restart the search through the custom paths collection and match the 2nd path with our authentication check, causing the code to work as desired:\n\n\n$path = new \\Cora\\Path();\n    $path->url = '/dashboard/{anything}';\n    $path->route = '/v2/dashboard/{anything}';\n    $path->passive = true;\n$paths->add($path);\n\n\n$path = new \\Cora\\Path();\n    $path->url = '/v2/dashboard/admin/{anything}';\n    $path->preExec = function($vars, $app) {\n        if ($app->auth->access(new \\Models\\Auth\\IsAdmin)) { return true; }\n        return false;\n    };\n$paths->add($path);\n\n\n\n\nPreventing Infinite Loops\n\n\n(You don't need to do anything for this preventive measure, but I wanted to explain how it works.)\n\n\nOnce a path has been run, it is added to a list so that subsequent searches through the paths array for the current request will not trigger it again. This prevents possible infinite loops. This wouldn't affect our example above because we change the route to \"v2\" in the first path, but imagine if we didn't change the route at all, and instead just checked that a user trying to access the dashboard is logged in:\n\n\n// Check that only logged in users can access dashboard.\n$path = new \\Cora\\Path();\n    $path->url = '/dashboard';\n    $path->preExec = function($vars, $app) {\n        if ($app->auth->access(new \\Models\\Auth\\IsLoggedIn)) { return true; }\n        return false;\n    };\n    $path->passive = true;\n$paths->add($path);\n\n\n// Check that only Admins can access dashboard admin area.\n$path = new \\Cora\\Path();\n    $path->url = '/dashboard/admin';\n    $path->preExec = function($vars, $app) {\n        if ($app->auth->access(new \\Models\\Auth\\IsAdmin)) { return true; }\n        return false;\n    };\n$paths->add($path);\n\n\n\n\nIn this example, we didn't change the internal route being looked at, so it remains whatever the public URL was. So if a user tries to access the dashboard, it will match the first path which will execute the check that the user is logged in, then because the path is passive, it restarts the search for custom paths. The 2nd time through, the route still hasn't changed so it matches the first path AGAIN. If we allowed the first path to run, it would put us in an infinite loop. However, because a list of executed paths is kept, the Router will check the list and know to bypass the first path the 2nd time through. \n\n\nPath Priority\n\n\nBy default, custom routes are matched in the order they are defined from top to bottom. Once a match has been found for the current URL, that path is executed and the search for additional matching paths is cancelled. For this reason, in practical use-case situations you either have to use the \"passive\" attribute on paths or make sure you define the most specific paths at the top.\n\n\nExample that doesn't work:\n\n\n// Check that only logged in users can access dashboard.\n$path = new \\Cora\\Path();\n    $path->url = '/dashboard';\n    $path->preExec = function($vars, $app) {\n        if ($app->auth->access(new \\Models\\Auth\\IsLoggedIn)) { return true; }\n        return false;\n    };\n$paths->add($path);\n\n// Check that only Admins can access dashboard admin area.\n$path = new \\Cora\\Path();\n    $path->url = '/dashboard/admin';\n    $path->preExec = function($vars, $app) {\n        if ($app->auth->access(new \\Models\\Auth\\IsAdmin)) { return true; }\n        return false;\n    };\n$paths->add($path);\n\n\n\n\nThe first path defined would get matched to any request to the dashboard area of the site, which would check that a user is logged in, and if that passes would immediately check for a matching Controller+Method pair and execute the route. This would allow ANY user who is logged in to access the Dashboard/Admin area because the 2nd path never gets checked.\n\n\nFix Option #1:\n\n\n// Check that only Admins can access dashboard admin area.\n$path = new \\Cora\\Path();\n    $path->url = '/dashboard/admin';\n    $path->preExec = function($vars, $app) {\n        if ($app->auth->access(new \\Models\\Auth\\IsAdmin)) { return true; }\n        return false;\n    };\n$paths->add($path);\n\n// Check that only logged in users can access dashboard.\n$path = new \\Cora\\Path();\n    $path->url = '/dashboard';\n    $path->preExec = function($vars, $app) {\n        if ($app->auth->access(new \\Models\\Auth\\IsLoggedIn)) { return true; }\n        return false;\n    };\n$paths->add($path);\n\n\n\n\nWhat we've done above to fix the situation is move the MORE SPECIFIC path to the top so it gets run if there's a match instead of the less specific path. In this case, any request to the Dashboard/Admin area will match the first path and execute that, and any request to an area of the dashboard that isn't the admin area would fall through to the 2nd path.\n\n\nFix Option #2:\n\n\n// Check that only logged in users can access dashboard.\n$path = new \\Cora\\Path();\n    $path->url = '/dashboard';\n    $path->preExec = function($vars, $app) {\n        if ($app->auth->access(new \\Models\\Auth\\IsLoggedIn)) { return true; }\n        return false;\n    };\n    $path->passive = true;\n$paths->add($path);\n\n// Check that only Admins can access dashboard admin area.\n$path = new \\Cora\\Path();\n    $path->url = '/dashboard/admin';\n    $path->preExec = function($vars, $app) {\n        if ($app->auth->access(new \\Models\\Auth\\IsAdmin)) { return true; }\n        return false;\n    };\n$paths->add($path);\n\n\n\n\nHere, instead of moving the more specific path to the top of the page, we've added the \"passive\" attribute to the first path. This causes the search for custom paths to restart after processing the first path, which would make a request to the Admin area get caught by the 2nd path. This allows us to have less specific paths at the top, which fall through to more specific paths below.\n\n\nAdvanced Routes\n\n\nSo to fill out the routing capabilities for situations that require a little bit more complexity than is covered by the other sections of this documentation, the Route class offers the \"preMatch\" callback and the \"args\" property.\n\n\nExplained: \"preMatch\" Callback\n\n\nFirst let's talk about the preMatch() callback. This method is similar to the preExec() callback, except instead of getting \ncalled after a path has been matched, preMatch gets called after the Router finds what looks like a matching path, but \nbefore it's officially considered a match (which would then stop the search for additional paths and trigger preExec). If \nthe preMatch callback returns true, then the path gets locked in as a match, if it returns false, then the potential path \nis rejected and the search continues.\n\n\n$path = new \\Cora\\Path();\n    $path->url = '/api/member/{id}/{anything}';\n    $path->route = '/api/member/{anything}';\n    $path->preMatch = function($vars, $app) {\n        if ($app->loggedInUser->canViewMember($vars['id'])) {\n            return true; // Causes Path to get matched and execute.\n        }\n        return false; // Rejects this path and search continues.\n    };\n$paths->add($path);\n\n\n\n\nIt's important to note that while returning false from the preExec callback causes a 403 Access Denied response, \nreturning false from the preMatch callback simply rejects the possible path in question. If no other matching Path \nis found, the user will end up getting a 404 Not Found response. In this sense, preExec let's a user know the path \nexists, but they aren't being given access, while preMatch can hide the existance of the path altogether.\n\n\nExplained: \"args\" Callback\n\n\nSo the \"args\" callback is an interesting feature and I haven't made up my mind on whether it's really \nuseful... but I'll explain the reasoning behind it and how it works, and let you be the judge.\n\n\nNormally, Controllers can't really be unit tested, as they just handle user input, pass off logic processing to other backend classes (which can be unit tested), and return some output. If you are testing the controllers, it's probably through a front-end tool like Selenium. The thought I had, which inspired this feature, was what I could do to make Controllers more testable by way of unit testing. \n\n\nIn developing apps... depending on how thin I made the controllers, the usage of the AmBlend ORM, etc, I could get in situations where I felt like unit testing the controller made sense as opposed to making the controller method any thinner. Here's a hypothetical example below where I use AmBlend to grab data models and I return them as JSON:\n\n\npublic function index($category, $year, $month)\n{\n    // Grab database query object\n    $query = $this->app->articles->getDb();\n\n    // Set query parameters\n    $query->where('category', $category)\n          ->where('year', $year)\n          ->where('month', $month);\n\n    // Grab GET variables from query string in URL\n    $sortField = $this->input->get('sortField');\n    $sortDirection = $this->input->get('sortDirection');\n\n    // Optionally order the data as needed\n    if ($sortField && $sortDirection) {\n        $query->orderBy($sortField, $sortDirection);\n    }\n\n    // Fetch matching articles\n    $articles = $this->app->articles->findAll($query);\n\n    // Return results\n    echo $articles->toJson();\n}\n\n\n\n\nThis is a prime example of Controller code that feels like it could benefit from unit testing if left as-is. Now we COULD make this Controller thinner by offloading the calls to the ORM to an intermediate logic layer:\n\n\npublic function index($category, $year, $month)\n{\n    // Grab GET variables from query string in URL\n    $sortField = $this->input->get('sortField');\n    $sortDirection = $this->input->get('sortDirection');\n\n    // Fetch matching articles\n    $articles = $this->app->articleManager->findAll($category, $year, $month, $sortField, $sortDirection);\n\n    // Return results\n    echo $articles->toJson();\n}\n\n\n\n\nThen we could unit test the findAll method in our new \"articleManager\" class and accomplish unit testing that way. This IS\n the normal way I would handle the situation, and definitely what I would recommend any developer reading this guide do. The reason being, you'll probably have other logic tied to who can edit and delete articles, etc, where it would make sense to have that logic be portable and not tied to a specific controller endpoint. This would also make your code testable outside the context of the Cora Framework. However, since all the work to fetch the articles is already being handled by the ORM classes, the articleManager in this case might end up feeling like it's mostly a pointless middleman.\n\n\nLet's say you don't care about code portability, and you'd rather reduce redundancy and just have the calls to the ORM live directly in the Controller like our original example.\n\n\nThe problem you run into is those pesky global references to $_GET variables. Yes, you COULD set any needed globals when running a unit test, but it just feels dirty. What I ended up deciding I wanted to accomplish, was to have a way to eliminate global variables from Controllers and instead have all user input passed in as method arguments. THAT is where the \"args\" callback comes into play.\n\n\nThe args callback should return an array of arguments to be passed into the controller method resolved from the path.\n\n\nExample\n\n\nIf your path is defined as:\n\n\n$path = new \\Cora\\Path();\n    $path->url = '/api/v1.0/articles/{category}/{year}/{month}/';\n    $path->route = '/api/v1.0/articles/view/{category}/{year}/{month}/';\n    $path->args = function($vars, $app) {\n        return [$vars['category'], $vars['year'], $vars['month'], $_GET['sortField'], $_GET['sortDirection']];\n    };\n$paths->add($path);\n\n\n\n\nYou go to the following URL in the browser:\n\n\nMySite.com/api/v1.0/articles/politics/2017/06/?sortField=title&sortDirection=desc\n\n\n\n\nand then your controller method looks like so, the result will be as commented:\n\n\npublic function view($category, $year, $month, $sortField = 'author', $sortDirection = 'asc') \n{\n    echo \"$category<br>\";       // Will output \"politics\"\n    echo \"$year<br>\";           // Will output \"2017\"\n    echo \"$month<br>\";          // Will output \"06\"\n    echo \"$sortField<br>\";      // Will output \"title\"\n    echo \"$sortDirection\";      // Will output \"desc\"\n}\n\n\n\n\nIn-case you missed it, what we did was pull the globals out of the Controller method and instead inject them as part of the \nmethod signature. The controller is now free from global variables, and we can even set default values. Our little API Controller \nmethod is now in a place where we could easily write some unit tests for it.\n\n\nIs this useful? Like I said, I still haven't decided. But there you have it.",
            "title": "Custom Routes"
        },
        {
            "location": "/documentation/v2/routing/custom_routes/#custom-routes",
            "text": "Defining custom routes can serve several purposes. The primary purpose is to allow a URL to be mapped to a different internal address. Another primary purpose is to perform authorization checking on sections of a site.\nIn Cora, custom routes are implemented by defining \"paths\" from a URL to some internal address.",
            "title": "Custom Routes"
        },
        {
            "location": "/documentation/v2/routing/custom_routes/#understanding-coras-implementation",
            "text": "The code in Cora's Route class that pertains to hooking up custom defined routes looks like the below. It creates an empty array of paths called \"$paths\", loads \"Cora\\App\\Paths.php\" if it exists in the project, then finalizes \"$paths\" as the custom path array.  $paths = [];\nif (file_exists($this->config['basedir'].'cora/app/Paths.php')) {\n    include($this->config['basedir'].'cora/app/Paths.php');\n}\n$this->paths = $paths;  So in order to define custom routes for our app, all we need to do is create that file in our Cora\\App directory and define $paths to be something that isn't an empty array.",
            "title": "Understanding Cora's Implementation"
        },
        {
            "location": "/documentation/v2/routing/custom_routes/#example-coraapppathsphp-file",
            "text": "<?php\n// Create paths container\n$paths = new \\Cora\\Container();\n\n// Path 1\n$path = new \\Cora\\Path();\n    $path->url = '/users/login';\n    $path->route = '/users/newLogin';\n$paths->add($path);\n\n// Path 2\n$path = new \\Cora\\Path();\n    $path->url = '/users/forgotPassword';\n    $path->route = '/users/newForgotPassword';\n$paths->add($path);",
            "title": "Example Cora/App/Paths.php file:"
        },
        {
            "location": "/documentation/v2/routing/custom_routes/#alternate-syntax",
            "text": "A quick note before we dive into things. The examples given in this document use regular object syntax, where each Path is an object, we define some properties on each, and then add them to our Paths collection. Alternatively, developers may prefer to pass in the path definition as an array to the constructor. This allows for some cleaner in-lining, and may be visually less cluttered to some peoples' eyes. The above example using this syntax looks like this:   <?php\n// Create paths container\n$paths = new \\Cora\\Container();\n\n// Path 1\n$paths->add(new \\Cora\\Path([\n    'url'   => '/users/login',\n    'route' => '/users/newLogin'\n]));\n\n// Path 2\n$paths->add(new \\Cora\\Path([\n    'url'   => '/users/forgotPassword',\n    'route' => '/users/newForgotPassword'\n]));  Feel free to use that syntax if you prefer it.",
            "title": "Alternate Syntax:"
        },
        {
            "location": "/documentation/v2/routing/custom_routes/#simple-internal-redirect",
            "text": "The simplest example of using a custom route is just going to be re-routing some URL to a different internal address. This takes defining a path with two attributes, the URL you want to match in the user's browser and the internal route you actually want executed.  $path = new \\Cora\\Path();\n    $path->url = '/users/login';\n    $path->route = '/users/newLogin';\n$paths->add($path);  In this example, going to \"www.MySite.com/users/login\" will internally (not visible to the user) get redirected to \"www.MySite.com/users/newLogin\".",
            "title": "Simple Internal Redirect"
        },
        {
            "location": "/documentation/v2/routing/custom_routes/#url-variables",
            "text": "A more advanced feature of custom routes is the ability to use variables in the URL and internal Route. By default variables will capture letters, numbers, and underscores, but you can define them however you need.  In the below example, if a user were to go to:  MySite.com/blogs/politics-bjohnson  this would get redirected to an internal address of:   MySite.com/articles/personal/view/bjohnson/politics  Example:  $path = new \\Cora\\Path();\n    $path->url = '/blogs/{category}-{person}';\n    $path->route = '/articles/personal/view/{person}/{category}';\n$paths->add($path);  Variables in the URL must have a separator of some sort between them. In the example above, the separator is a hyphen, but it could have just as easily been a forward slash like in the \"route\" attribute. Also notice that we reversed the order of {category} and {person} in the route. Once you've defined part of the input URL as a variable, you can reuse that variable however you like in the internal route.  The variables grabbed from the URL in this way will be available to the preMatch and preExec methods as an array named \"vars\". Using the example from above, it works like this to check if the category being viewed is politics:  $path->preExec = function($vars, $app) {\n    if ($vars['category'] == 'politics') {\n        return true; // grant access\n    }\n    return false; // deny access\n};",
            "title": "URL Variables"
        },
        {
            "location": "/documentation/v2/routing/custom_routes/#defining-variables",
            "text": "You can define variables in your URL using regular expressions if you need them to match a particular format. The most common use-case for this would likely be defining that a variable must be a number.  $path = new \\Cora\\Path();\n    $path->url = '/blogs/{id}';\n    $path->route = '/articles/personal/{id}';\n    $path->def['{id}'] = '[0-9]+';\n$paths->add($path);  In the above example we use a regular expression to define {id} as being a number.",
            "title": "Defining Variables"
        },
        {
            "location": "/documentation/v2/routing/custom_routes/#anything-variable",
            "text": "There's one special variable name which is predefined for you to match any character. That special variable is {anything}. {Anything} is useful when you don't care what the end of the URL is, but you do need to use it.  Say you have the following valid URLs as part of your app:  MySite.com/pets/dogs/retrievers\nMySite.com/pets/dogs/terriers\nMySite.com/pets/cats/persians/view/56  But you are re-organizing your site and decided to rename your Pets controller to Animals. The only problem is, you don't want to break links that people have bookmarked using the old version. A solution in this case would be to use the {anything} variable as a wildcard like so:  $path = new \\Cora\\Path();\n    $path->url = '/pets/{anything}';\n    $path->route = '/animals/{anything}';\n    $path->passive = true;\n$paths->add($path);  This would capture and redirect all the requests that start with Pets to instead use Animals, without having to worry about defining a specific route for each possible path that was available under Pets.  The \"passive\" attribute is likely something that would want to be used here, so it's included. You can read about it further down in this documentation.",
            "title": "{Anything} Variable"
        },
        {
            "location": "/documentation/v2/routing/custom_routes/#http-methods",
            "text": "By default, paths will be matched for all HTTP methods. Then once a path is matched and a route is executed, Cora's normal handling of HTTP methods will apply (a POST request being routed to methodPOST for example). However, both these behaviors can be changed on a path by path basis.  To make your path only match HTTP requests of a certain type, define an \"actions\" attribute on the path with the methods you want listed like so:  $path = new \\Cora\\Path();\n    $path->url = '/users/test/{action}-{action2}';\n    $path->route = '/home/view/{action2}/{action}';\n    $path->actions = 'GET|POST';\n$paths->add($path);  To disable Cora's RESTful routing behavior for a path, define an attribute \"RESTful\" as false:  $path = new \\Cora\\Path();\n    $path->url = '/articles/api';\n    $path->route = '/articles/api/create';\n    $path->actions = 'POST';\n    $path->RESTful = false;\n$paths->add($path);  In the above example, a POST request to:  MySite.com/articles/api  Would get routed to the \"Articles/Api\" controller and \"create\" method (Not createPOST).",
            "title": "HTTP Methods"
        },
        {
            "location": "/documentation/v2/routing/custom_routes/#route-authentication",
            "text": "So another popular use case for custom routes is going to be protecting certain features or sections of a site from un-authorized users. The way you can do that with custom routes is using the \"preExec\" attribute to define a function. If this preExec function returns false, execution of the path will be prevented.  In the example below \"$app\" is Cora's container. From it we are calling Cora's Auth library to check if a user is logged in. You can read-up on Cora's Auth library or use your own permission system if you like. Just remember that if this function returns false execution of the path will be prevented. The \"$vars\" parameter holds any variables defined in the URL (see URL Variables section).  Example:  $path = new \\Cora\\Path();\n    $path->url = '/home/private';\n    $path->route = '/home/view/protected/area';\n    $path->preExec = function($vars, $app) {\n        if (!$app->auth->access(new \\Models\\Auth\\LoggedIn)) { return false; }\n        return true;\n    };\n$paths->add($path);  Closely tied to route authentication is the use of Passive routes. So make sure to check out that section.",
            "title": "Route Authentication"
        },
        {
            "location": "/documentation/v2/routing/custom_routes/#passive-routes",
            "text": "Normally, the search for custom routes that match the URL ends after the first match found. However, when performing authentication for a route, you may not want this behavior. Say for instance that you have a \"Private\" controller and you want anything in that controller or in the Private subdirectory to be protected from unauthorized access. In this scenario you may want to check that a user has access, then have the search for custom routes continue afterwards. This is where \"Passive\" routes come into play.  First let's look at an example without a passive path that DOESN'T work, and explain why:  $path = new \\Cora\\Path();\n    $path->url = '/dashboard/{anything}';\n    $path->route = '/v2/dashboard/{anything}';\n$paths->add($path);\n\n\n$path = new \\Cora\\Path();\n    $path->url = '/v2/dashboard/admin/{anything}';\n    $path->preExec = function($vars, $app) {\n        if ($app->auth->access(new \\Models\\Auth\\IsAdmin)) { return true; }\n        return false;\n    };\n$paths->add($path);  In the above example, there's two things going on. First, we are redirecting any requests for the Dashboard to instead use version 2 of the dashboard. Second, we are making sure any requests for access to the Admin area of the dashboard are checked for the proper permissions. However, this code will not work as desired. The problem is that in order to not waste processing power, Cora will stop at the first non-passive custom route it finds that matches the current URL. So because the \"dashboard/{anything}\" path is defined first, that will get matched for any request to the dashboard area and executed. It WILL properly redirect the request internally to V2, but then it will check for a valid Controller+Method combo without looking at the 2nd custom path that specifies the authentication check for the admin area.  The solution to this problem, is to add the \"passive\" attribute to the first path so that Cora will restart the search for matching custom paths after the internal route gets changed to v2. In the same example below with the passive attribute, cora will run the first path and change the route to v2, then restart the search through the custom paths collection and match the 2nd path with our authentication check, causing the code to work as desired:  $path = new \\Cora\\Path();\n    $path->url = '/dashboard/{anything}';\n    $path->route = '/v2/dashboard/{anything}';\n    $path->passive = true;\n$paths->add($path);\n\n\n$path = new \\Cora\\Path();\n    $path->url = '/v2/dashboard/admin/{anything}';\n    $path->preExec = function($vars, $app) {\n        if ($app->auth->access(new \\Models\\Auth\\IsAdmin)) { return true; }\n        return false;\n    };\n$paths->add($path);",
            "title": "Passive Routes"
        },
        {
            "location": "/documentation/v2/routing/custom_routes/#preventing-infinite-loops",
            "text": "(You don't need to do anything for this preventive measure, but I wanted to explain how it works.)  Once a path has been run, it is added to a list so that subsequent searches through the paths array for the current request will not trigger it again. This prevents possible infinite loops. This wouldn't affect our example above because we change the route to \"v2\" in the first path, but imagine if we didn't change the route at all, and instead just checked that a user trying to access the dashboard is logged in:  // Check that only logged in users can access dashboard.\n$path = new \\Cora\\Path();\n    $path->url = '/dashboard';\n    $path->preExec = function($vars, $app) {\n        if ($app->auth->access(new \\Models\\Auth\\IsLoggedIn)) { return true; }\n        return false;\n    };\n    $path->passive = true;\n$paths->add($path);\n\n\n// Check that only Admins can access dashboard admin area.\n$path = new \\Cora\\Path();\n    $path->url = '/dashboard/admin';\n    $path->preExec = function($vars, $app) {\n        if ($app->auth->access(new \\Models\\Auth\\IsAdmin)) { return true; }\n        return false;\n    };\n$paths->add($path);  In this example, we didn't change the internal route being looked at, so it remains whatever the public URL was. So if a user tries to access the dashboard, it will match the first path which will execute the check that the user is logged in, then because the path is passive, it restarts the search for custom paths. The 2nd time through, the route still hasn't changed so it matches the first path AGAIN. If we allowed the first path to run, it would put us in an infinite loop. However, because a list of executed paths is kept, the Router will check the list and know to bypass the first path the 2nd time through.",
            "title": "Preventing Infinite Loops"
        },
        {
            "location": "/documentation/v2/routing/custom_routes/#path-priority",
            "text": "By default, custom routes are matched in the order they are defined from top to bottom. Once a match has been found for the current URL, that path is executed and the search for additional matching paths is cancelled. For this reason, in practical use-case situations you either have to use the \"passive\" attribute on paths or make sure you define the most specific paths at the top.  Example that doesn't work:  // Check that only logged in users can access dashboard.\n$path = new \\Cora\\Path();\n    $path->url = '/dashboard';\n    $path->preExec = function($vars, $app) {\n        if ($app->auth->access(new \\Models\\Auth\\IsLoggedIn)) { return true; }\n        return false;\n    };\n$paths->add($path);\n\n// Check that only Admins can access dashboard admin area.\n$path = new \\Cora\\Path();\n    $path->url = '/dashboard/admin';\n    $path->preExec = function($vars, $app) {\n        if ($app->auth->access(new \\Models\\Auth\\IsAdmin)) { return true; }\n        return false;\n    };\n$paths->add($path);  The first path defined would get matched to any request to the dashboard area of the site, which would check that a user is logged in, and if that passes would immediately check for a matching Controller+Method pair and execute the route. This would allow ANY user who is logged in to access the Dashboard/Admin area because the 2nd path never gets checked.  Fix Option #1:  // Check that only Admins can access dashboard admin area.\n$path = new \\Cora\\Path();\n    $path->url = '/dashboard/admin';\n    $path->preExec = function($vars, $app) {\n        if ($app->auth->access(new \\Models\\Auth\\IsAdmin)) { return true; }\n        return false;\n    };\n$paths->add($path);\n\n// Check that only logged in users can access dashboard.\n$path = new \\Cora\\Path();\n    $path->url = '/dashboard';\n    $path->preExec = function($vars, $app) {\n        if ($app->auth->access(new \\Models\\Auth\\IsLoggedIn)) { return true; }\n        return false;\n    };\n$paths->add($path);  What we've done above to fix the situation is move the MORE SPECIFIC path to the top so it gets run if there's a match instead of the less specific path. In this case, any request to the Dashboard/Admin area will match the first path and execute that, and any request to an area of the dashboard that isn't the admin area would fall through to the 2nd path.  Fix Option #2:  // Check that only logged in users can access dashboard.\n$path = new \\Cora\\Path();\n    $path->url = '/dashboard';\n    $path->preExec = function($vars, $app) {\n        if ($app->auth->access(new \\Models\\Auth\\IsLoggedIn)) { return true; }\n        return false;\n    };\n    $path->passive = true;\n$paths->add($path);\n\n// Check that only Admins can access dashboard admin area.\n$path = new \\Cora\\Path();\n    $path->url = '/dashboard/admin';\n    $path->preExec = function($vars, $app) {\n        if ($app->auth->access(new \\Models\\Auth\\IsAdmin)) { return true; }\n        return false;\n    };\n$paths->add($path);  Here, instead of moving the more specific path to the top of the page, we've added the \"passive\" attribute to the first path. This causes the search for custom paths to restart after processing the first path, which would make a request to the Admin area get caught by the 2nd path. This allows us to have less specific paths at the top, which fall through to more specific paths below.",
            "title": "Path Priority"
        },
        {
            "location": "/documentation/v2/routing/custom_routes/#advanced-routes",
            "text": "So to fill out the routing capabilities for situations that require a little bit more complexity than is covered by the other sections of this documentation, the Route class offers the \"preMatch\" callback and the \"args\" property.",
            "title": "Advanced Routes"
        },
        {
            "location": "/documentation/v2/routing/custom_routes/#explained-prematch-callback",
            "text": "First let's talk about the preMatch() callback. This method is similar to the preExec() callback, except instead of getting \ncalled after a path has been matched, preMatch gets called after the Router finds what looks like a matching path, but \nbefore it's officially considered a match (which would then stop the search for additional paths and trigger preExec). If \nthe preMatch callback returns true, then the path gets locked in as a match, if it returns false, then the potential path \nis rejected and the search continues.  $path = new \\Cora\\Path();\n    $path->url = '/api/member/{id}/{anything}';\n    $path->route = '/api/member/{anything}';\n    $path->preMatch = function($vars, $app) {\n        if ($app->loggedInUser->canViewMember($vars['id'])) {\n            return true; // Causes Path to get matched and execute.\n        }\n        return false; // Rejects this path and search continues.\n    };\n$paths->add($path);  It's important to note that while returning false from the preExec callback causes a 403 Access Denied response, \nreturning false from the preMatch callback simply rejects the possible path in question. If no other matching Path \nis found, the user will end up getting a 404 Not Found response. In this sense, preExec let's a user know the path \nexists, but they aren't being given access, while preMatch can hide the existance of the path altogether.",
            "title": "Explained: \"preMatch\" Callback"
        },
        {
            "location": "/documentation/v2/routing/custom_routes/#explained-args-callback",
            "text": "So the \"args\" callback is an interesting feature and I haven't made up my mind on whether it's really \nuseful... but I'll explain the reasoning behind it and how it works, and let you be the judge.  Normally, Controllers can't really be unit tested, as they just handle user input, pass off logic processing to other backend classes (which can be unit tested), and return some output. If you are testing the controllers, it's probably through a front-end tool like Selenium. The thought I had, which inspired this feature, was what I could do to make Controllers more testable by way of unit testing.   In developing apps... depending on how thin I made the controllers, the usage of the AmBlend ORM, etc, I could get in situations where I felt like unit testing the controller made sense as opposed to making the controller method any thinner. Here's a hypothetical example below where I use AmBlend to grab data models and I return them as JSON:  public function index($category, $year, $month)\n{\n    // Grab database query object\n    $query = $this->app->articles->getDb();\n\n    // Set query parameters\n    $query->where('category', $category)\n          ->where('year', $year)\n          ->where('month', $month);\n\n    // Grab GET variables from query string in URL\n    $sortField = $this->input->get('sortField');\n    $sortDirection = $this->input->get('sortDirection');\n\n    // Optionally order the data as needed\n    if ($sortField && $sortDirection) {\n        $query->orderBy($sortField, $sortDirection);\n    }\n\n    // Fetch matching articles\n    $articles = $this->app->articles->findAll($query);\n\n    // Return results\n    echo $articles->toJson();\n}  This is a prime example of Controller code that feels like it could benefit from unit testing if left as-is. Now we COULD make this Controller thinner by offloading the calls to the ORM to an intermediate logic layer:  public function index($category, $year, $month)\n{\n    // Grab GET variables from query string in URL\n    $sortField = $this->input->get('sortField');\n    $sortDirection = $this->input->get('sortDirection');\n\n    // Fetch matching articles\n    $articles = $this->app->articleManager->findAll($category, $year, $month, $sortField, $sortDirection);\n\n    // Return results\n    echo $articles->toJson();\n}  Then we could unit test the findAll method in our new \"articleManager\" class and accomplish unit testing that way. This IS\n the normal way I would handle the situation, and definitely what I would recommend any developer reading this guide do. The reason being, you'll probably have other logic tied to who can edit and delete articles, etc, where it would make sense to have that logic be portable and not tied to a specific controller endpoint. This would also make your code testable outside the context of the Cora Framework. However, since all the work to fetch the articles is already being handled by the ORM classes, the articleManager in this case might end up feeling like it's mostly a pointless middleman.  Let's say you don't care about code portability, and you'd rather reduce redundancy and just have the calls to the ORM live directly in the Controller like our original example.  The problem you run into is those pesky global references to $_GET variables. Yes, you COULD set any needed globals when running a unit test, but it just feels dirty. What I ended up deciding I wanted to accomplish, was to have a way to eliminate global variables from Controllers and instead have all user input passed in as method arguments. THAT is where the \"args\" callback comes into play.  The args callback should return an array of arguments to be passed into the controller method resolved from the path.",
            "title": "Explained: \"args\" Callback"
        },
        {
            "location": "/documentation/v2/routing/custom_routes/#example",
            "text": "If your path is defined as:  $path = new \\Cora\\Path();\n    $path->url = '/api/v1.0/articles/{category}/{year}/{month}/';\n    $path->route = '/api/v1.0/articles/view/{category}/{year}/{month}/';\n    $path->args = function($vars, $app) {\n        return [$vars['category'], $vars['year'], $vars['month'], $_GET['sortField'], $_GET['sortDirection']];\n    };\n$paths->add($path);  You go to the following URL in the browser:  MySite.com/api/v1.0/articles/politics/2017/06/?sortField=title&sortDirection=desc  and then your controller method looks like so, the result will be as commented:  public function view($category, $year, $month, $sortField = 'author', $sortDirection = 'asc') \n{\n    echo \"$category<br>\";       // Will output \"politics\"\n    echo \"$year<br>\";           // Will output \"2017\"\n    echo \"$month<br>\";          // Will output \"06\"\n    echo \"$sortField<br>\";      // Will output \"title\"\n    echo \"$sortDirection\";      // Will output \"desc\"\n}  In-case you missed it, what we did was pull the globals out of the Controller method and instead inject them as part of the \nmethod signature. The controller is now free from global variables, and we can even set default values. Our little API Controller \nmethod is now in a place where we could easily write some unit tests for it.  Is this useful? Like I said, I still haven't decided. But there you have it.",
            "title": "Example"
        },
        {
            "location": "/documentation/v2/validationclass/overview/",
            "text": "Cora's Validation class\n\n\nThe Validate class is for checking that data matches a set of restrictions. For instance, if you have a form for users to submit and want to require that they fill out the 'email' field and enter something that at least looks like a valid email, Validate can help with that. It's main usage will typically be for validating form submissions, but it can be used to validate any data you pass in.\n\n\nNote that the Validate class must be called from a Controller as any errors returned will be loaded into that controller's \"$this->data->errors\" data member!\n\n\nFront-end vs. Back-end Validation:\n   \n\n\nIf you are unfamiliar with form validation, it's worth mentioning that front-end Javascript validators are easier to setup and can save you that tiny bit of server processing power if efficiency is important. The main drawbacks of front-end validation is that it can be \nbypassed\n (important to know if you didn't already know that) and you have to setup a special API in order to do things like check if a Username is already taken, etc. For this reason, for validation that is even remotely important, you should either use back-end validation like this Validation class provides, or use both a front-end validator and this class on the backend (in-case a user bypasses the front-end validation code).\n\n\nExample Usage\n\n\n// This is a method within a controller.\npublic function createPOST()\n{\n    // Load Validate\n    $this->load->library('Validate', $this, true);  \n\n    // Define validation rules for form inputs.\n    $this->Validate->rule('username', 'required|max_length[55]|trim');\n    $this->Validate->rule('email', 'required|valid_email');\n    $this->Validate->rule('password', 'required');\n    $this->Validate->rule('password2', 'required|matches[password]');\n\n    // Initiate validation\n    if ($this->Validate->run()) {        \n        // Form validation was successful! Do stuff with data.\n    }\n    else {      \n        // The form validation failed!\n        // Redisplay the form to the user so they can fix the errors.\n        $this->create();\n    }\n}\n\n\n\n\nIf you are using the Cora demo project, you can find an example form being used at:\n\n\n/controllers/articles/controller.News.php\n\n\n\n\nWhich can be navigated to in your web browser by going to:\n\n\nlocalhost/myProject/articles/news/create/\n\n\n\n\nTypical Usage Steps\n\n\nUsage typically includes the following steps:\n\n\n\n\nLoad the validation class.\n\n\nDefine any custom validation checks you need.\n\n\nApply validation checks to pieces of data by defining the rules that data must obey.\n\n\nRun the validation checker.\n\n\nDisplay any errors to the user and repopulate the form they submitted if necessary.\n\n\n\n\nLoading\n\n\nAlthough you can certainly load Validate like any other class, the recommended way of loading it into your controller is to use the Load class. The load class handles some references stuff for you automatically which I'll explain later. To use the Load class to get Validate, add the following to your controller:\n\n\n// Recommended way of setup\n$this->load->library('Validate', $this, true);\n\n\n\n\nThe fact that we're specifying that we want to load the Validate class as the first parameter should make sense. What you're probably wondering about is what the other two parameters do. For the 2nd parameter we're passing a reference to the current controller; Validate uses this reference to load any validation errors generated into that controller's \"$this->data->errors\" data member. The third parameter being true tells the Load class to create a reference in the calling controller to Validate for you. In other words it does the equivalent of this:\n\n\n$this->data->Validate = new \\Validate($this);\n\n\n\n\nOk... but why do you need a reference to Validate in the controller like that? Because in order to use Validate's form repopulation methods within a View file, you need a reference to Validate in the data you pass to that view! If this doesn't make sense at the moment, don't worry about it. You might understand it better once you see usage examples below, and even if you don't, it's not important so long as you follow the recommended way of loading specified above.\n\n\nBuilt-In Validation Checks\n\n\nThere are a few built-in validation checks for common concerns. They are:\n\n\n\n\n\n    \n'Check' Name\n\n    \nDescription\n\n\n\n\n\n    \nrequired\n\n    \nSpecifies that a value must be entered for this field (specifying form fields that MUST be filled out).\n\n\n\n\n\n    \nvalid_email\n\n    \nSpecifies that the value must match a valid email pattern.\n\n\n\n\n\n    \nmatches[name]\n\n    \nSpecifies that this field must match the one specified in the brackets (I.E. does 'password' match 'password2'?)\n\n\n\n\n\n    \nmin_length[x]\n\n    \nSpecifies that this field must be at least X characters in length.\n\n\n\n\n\n    \nmax_length[x]\n\n    \nSpecifies that this field must be at most X characters in length.\n\n\n\n\n\n    \ntrim\n\n    \nTrims whitespace from the beginning and end of the field. Doesn't ever fail, this is just a utility method.\n\n\n\n\n\n\n\nHowever, while these work great for general purpose kinda validations, there might be times when you need to check something specific such as \"Is this username already taken?\" In those scenarios you will need to define your own validation \"check\" which can then be applied to a field just like the built-in ones.\n\n\nCustom Validation Checks\n\n\nCustom validation checks allow you to call a method from whatever class you want within your app and pass that method the input value. Below is an example of us defining a custom check that calls a method named \"isNameAvailable\" within our User class, so that we can check if a username a person wants is available when they register. (Note: The 4th parameter is the error message if the name isn't available.)\n\n\nDefining a custom validation check is easy. Here's an example:\n\n\n// Define the check\n$this->Validate->def('userNameAvailable', 'User','isNameAvailable', 'Username already taken.');\n\n// Use the check in a rule\n$this->Validate->rule('username', 'required|userNameAvailable');\n\n\n\n\nThe \"def\" method takes 4 required parameters, with the 5th and 6th being optional. Below is the function signature and a description of what each parameter does:\n\n\n$this->Validate->def($checkName, $class, $method, $errorMessageOnFailure, $passingResponse, $arguments);\n\n\n\n\n\n\n\n    \nParameter Name\n\n    \nDescription\n\n\n\n\n\n    \n$checkName\n\n    \nThis is the name of your new custom check. It's what you will include when defining your data rules.\n\n\n\n\n\n    \n$class\n\n    \nThe class within your app that we want to invoke for this custom check.\n\n\n\n\n\n    \n$method\n\n    \nThe method within that Class that we want to call and pass our input to.\n\n\n\n\n\n    \n$errorMessageOnFailure\n\n    \nThe message to display if this check does not pass.\n\n\n\n\n\n    \n$passingResponse\n\n    \n[OPTIONAL] Custom check methods are expected to return a TRUE or FALSE response when given the form input. This specifies which response is the passing one! By default this is set to TRUE. See below for examples.\n\n\n\n\n\n    \n$arguments\n\n    \n\n        [OPTIONAL] The method you call will always receive as its first argument the value of the field being validated. However,\n        there may be situations in which you need to pass along additional info. This parameter will get passed in as the 2nd argument to the custom check.\n    \n\n\n\n\n\n\n\nSo the optional 5th parameter when defining a custom check needs a little explaining. Basically, whatever methods you call for custom checks are expected to return True or False when given a certain input. However, which response \"passes\" the check, depends on how the method is written - and is why this optional 5th parameter exists. See the examples below:\n\n\n// Example 1 - A 'TRUE' value means the check passes.\n// Check passes if 'isNameAvailable' returns TRUE.\n$this->Validate->def('userNameAvailable', 'User','isNameAvailable', 'Username already taken.', TRUE);\n$this->Validate->rule('username', 'required|userNameAvailable');\n\n// Example 2 - A 'FALSE' value means the check passes.\n// Check passes if 'isNameTaken' returns FALSE.\n$this->Validate->def('userNameIsTaken', 'User','isNameTaken', 'Username already taken.', FALSE);\n$this->Validate->rule('username', 'required|userNameIsTaken');\n\n// Example 3 - A 'FALSE' value means the check passes. But we also need to pass along\n// whether accounts are identified by username or by email.\n// Check passes if 'accountExists' returns FALSE.\n$validationType = 'email'; // As opposed to 'username'\n$this->Validate->def('accountExists', 'Library\\\\Auth','accountExists', \"An account with that $validationType already exists.\"\", false, $validationType);\n$this->Validate->rule('email', 'required|accountExists|trim');\n\n// Then in the Auth Library:\npublic static function accountExists($authValue = false, $authField = false)\n{\n    // $authField is the field we are using for login validation, usually this is either 'username' or 'email'\n    // $authValue is the form data that was passed in. If validating by email, then presumably it's be the user's email address.\n\n    // Do stuff to figure out if an account exists, then return True or False.\n}\n\n\n\n\nHuman Readable Field Names\n\n\nIf you have a form input that has a name which isn't super user friendly, you can replace the name of the input in any error messages with a custom specified name by specifying an optional 3rd parameter when making your rules:\n\n\n$this->Validate->rule('password2', 'required|matches[password]', 'Password Confirmation');\n\n\n\n\nThis will result in the following error message if validation fails: \n\n\n\"Password Confirmation does not match password!\"\n\n\nDisplaying errors\n\n\nFrom within a View, the array of errors can be found within the \"$errors\" variable. They can be displayed by using the Load class' \"repeat\" method (this is the easiest way), or else you can manually iterate over the errors. Both methods are shown below:\n\n\nRepeat Method:\n   \n\n\n// Parameter 1 = Array to iterate over.\n// Parameter 2 = Tag to surround array items with.\n// Parameter 3 = [OPTIONAL] CSS class to attach to each item.\n// Parameter 4 = [OPTIONAL] Tag to wrap entire repeat block with.\n// Parameter 5 = [OPTIONAL] CSS class to attach to wrapper.\n<?= $this->repeat($errors, 'li', 'item', 'ul', 'list'); ?>\n\n\n\n\nGenerates:\n\n\n<ul class=\"list\">\n    <li class=\"item\">Error 1</li>\n    <li class=\"item\">Error 2</li>\n    ...\n</ul>\n\n\n\n\nOR\n\n\nManual Method:\n   \n\n\n<?php if (isset($errors)) { ?>\n    <ul>\n        <?php foreach ($errors as $error) { ?>\n            <li><?= $error; ?></li>\n        <?php } ?>\n    </ul>\n<?php } ?>\n\n\n\n\nRepopulating Forms\n\n\nThere's three methods in the Validate class that are designed to help you repopulate a form if validation fails.\n\n\n// For repopulating text boxes and text areas.\n$Validate->setField($fieldName, $defaultValue = '')\n\n// For repopulating check boxes and ratio buttons.\n$Validate->setCheckbox($fieldName, $fieldValue, $checkedByDefault = FALSE)\n\n// For repopulating select boxes.\n$Validate->setSelect($fieldName, $fieldValue, $selectedByDefault = FALSE)\n\n\n\n\nThese need to be echo'ed inside the HTML tag in question. See below for an example of a complete form with errors display and repopulation of the fields:\n\n\n\n\n\n<h1>Create Article</h1>\n<form method=\"POST\">\n\n    <?= $this->repeat($errors, 'li', 'item', 'ul', 'list'); ?>\n\n\n    <div>\n        <h3>Title:</h3>\n        <input type=\"text\" name=\"title\" value=\"<?= $Validate->setField('title', 'test'); ?>\">\n    </div>\n    <div>\n        <h3>Content:</h3>\n        <textarea name=\"content\"><?= $Validate->setField('content'); ?></textarea>\n    </div>\n    <br>\n\n    <div>\n        Item 1:<input type=\"checkbox\" name=\"mycheck[]\" value=\"1\" <?=$Validate->setCheckbox('mycheck', '1');?>>\n        <br>\n        Item 2:<input type=\"checkbox\" name=\"mycheck[]\" value=\"2\" <?=$Validate->setCheckbox('mycheck', '2', true);?>>\n    </div>\n    <br>\n\n    <div>\n        <select name=\"myselect\">\n            <option value=\"Option One\" <?= $Validate->setSelect('myselect', 'Option One'); ?> >One</option>\n            <option value=\"Option Two\" <?= $Validate->setSelect('myselect', 'Option Two', true); ?> >Two</option>\n            <option value=\"Option Three\" <?= $Validate->setSelect('myselect', 'Option Three'); ?> >Three</option>\n        </select>\n    </div>\n    <br>\n\n    <input type=\"submit\" value=\"Submit\">\n</form>",
            "title": "Validate Class"
        },
        {
            "location": "/documentation/v2/validationclass/overview/#coras-validation-class",
            "text": "The Validate class is for checking that data matches a set of restrictions. For instance, if you have a form for users to submit and want to require that they fill out the 'email' field and enter something that at least looks like a valid email, Validate can help with that. It's main usage will typically be for validating form submissions, but it can be used to validate any data you pass in.  Note that the Validate class must be called from a Controller as any errors returned will be loaded into that controller's \"$this->data->errors\" data member!  Front-end vs. Back-end Validation:      If you are unfamiliar with form validation, it's worth mentioning that front-end Javascript validators are easier to setup and can save you that tiny bit of server processing power if efficiency is important. The main drawbacks of front-end validation is that it can be  bypassed  (important to know if you didn't already know that) and you have to setup a special API in order to do things like check if a Username is already taken, etc. For this reason, for validation that is even remotely important, you should either use back-end validation like this Validation class provides, or use both a front-end validator and this class on the backend (in-case a user bypasses the front-end validation code).",
            "title": "Cora's Validation class"
        },
        {
            "location": "/documentation/v2/validationclass/overview/#example-usage",
            "text": "// This is a method within a controller.\npublic function createPOST()\n{\n    // Load Validate\n    $this->load->library('Validate', $this, true);  \n\n    // Define validation rules for form inputs.\n    $this->Validate->rule('username', 'required|max_length[55]|trim');\n    $this->Validate->rule('email', 'required|valid_email');\n    $this->Validate->rule('password', 'required');\n    $this->Validate->rule('password2', 'required|matches[password]');\n\n    // Initiate validation\n    if ($this->Validate->run()) {        \n        // Form validation was successful! Do stuff with data.\n    }\n    else {      \n        // The form validation failed!\n        // Redisplay the form to the user so they can fix the errors.\n        $this->create();\n    }\n}  If you are using the Cora demo project, you can find an example form being used at:  /controllers/articles/controller.News.php  Which can be navigated to in your web browser by going to:  localhost/myProject/articles/news/create/",
            "title": "Example Usage"
        },
        {
            "location": "/documentation/v2/validationclass/overview/#typical-usage-steps",
            "text": "Usage typically includes the following steps:   Load the validation class.  Define any custom validation checks you need.  Apply validation checks to pieces of data by defining the rules that data must obey.  Run the validation checker.  Display any errors to the user and repopulate the form they submitted if necessary.",
            "title": "Typical Usage Steps"
        },
        {
            "location": "/documentation/v2/validationclass/overview/#loading",
            "text": "Although you can certainly load Validate like any other class, the recommended way of loading it into your controller is to use the Load class. The load class handles some references stuff for you automatically which I'll explain later. To use the Load class to get Validate, add the following to your controller:  // Recommended way of setup\n$this->load->library('Validate', $this, true);  The fact that we're specifying that we want to load the Validate class as the first parameter should make sense. What you're probably wondering about is what the other two parameters do. For the 2nd parameter we're passing a reference to the current controller; Validate uses this reference to load any validation errors generated into that controller's \"$this->data->errors\" data member. The third parameter being true tells the Load class to create a reference in the calling controller to Validate for you. In other words it does the equivalent of this:  $this->data->Validate = new \\Validate($this);  Ok... but why do you need a reference to Validate in the controller like that? Because in order to use Validate's form repopulation methods within a View file, you need a reference to Validate in the data you pass to that view! If this doesn't make sense at the moment, don't worry about it. You might understand it better once you see usage examples below, and even if you don't, it's not important so long as you follow the recommended way of loading specified above.",
            "title": "Loading"
        },
        {
            "location": "/documentation/v2/validationclass/overview/#built-in-validation-checks",
            "text": "There are a few built-in validation checks for common concerns. They are:   \n     'Check' Name \n     Description   \n     required \n     Specifies that a value must be entered for this field (specifying form fields that MUST be filled out).   \n     valid_email \n     Specifies that the value must match a valid email pattern.   \n     matches[name] \n     Specifies that this field must match the one specified in the brackets (I.E. does 'password' match 'password2'?)   \n     min_length[x] \n     Specifies that this field must be at least X characters in length.   \n     max_length[x] \n     Specifies that this field must be at most X characters in length.   \n     trim \n     Trims whitespace from the beginning and end of the field. Doesn't ever fail, this is just a utility method.    However, while these work great for general purpose kinda validations, there might be times when you need to check something specific such as \"Is this username already taken?\" In those scenarios you will need to define your own validation \"check\" which can then be applied to a field just like the built-in ones.",
            "title": "Built-In Validation Checks"
        },
        {
            "location": "/documentation/v2/validationclass/overview/#custom-validation-checks",
            "text": "Custom validation checks allow you to call a method from whatever class you want within your app and pass that method the input value. Below is an example of us defining a custom check that calls a method named \"isNameAvailable\" within our User class, so that we can check if a username a person wants is available when they register. (Note: The 4th parameter is the error message if the name isn't available.)  Defining a custom validation check is easy. Here's an example:  // Define the check\n$this->Validate->def('userNameAvailable', 'User','isNameAvailable', 'Username already taken.');\n\n// Use the check in a rule\n$this->Validate->rule('username', 'required|userNameAvailable');  The \"def\" method takes 4 required parameters, with the 5th and 6th being optional. Below is the function signature and a description of what each parameter does:  $this->Validate->def($checkName, $class, $method, $errorMessageOnFailure, $passingResponse, $arguments);   \n     Parameter Name \n     Description   \n     $checkName \n     This is the name of your new custom check. It's what you will include when defining your data rules.   \n     $class \n     The class within your app that we want to invoke for this custom check.   \n     $method \n     The method within that Class that we want to call and pass our input to.   \n     $errorMessageOnFailure \n     The message to display if this check does not pass.   \n     $passingResponse \n     [OPTIONAL] Custom check methods are expected to return a TRUE or FALSE response when given the form input. This specifies which response is the passing one! By default this is set to TRUE. See below for examples.   \n     $arguments \n     \n        [OPTIONAL] The method you call will always receive as its first argument the value of the field being validated. However,\n        there may be situations in which you need to pass along additional info. This parameter will get passed in as the 2nd argument to the custom check.\n        So the optional 5th parameter when defining a custom check needs a little explaining. Basically, whatever methods you call for custom checks are expected to return True or False when given a certain input. However, which response \"passes\" the check, depends on how the method is written - and is why this optional 5th parameter exists. See the examples below:  // Example 1 - A 'TRUE' value means the check passes.\n// Check passes if 'isNameAvailable' returns TRUE.\n$this->Validate->def('userNameAvailable', 'User','isNameAvailable', 'Username already taken.', TRUE);\n$this->Validate->rule('username', 'required|userNameAvailable');\n\n// Example 2 - A 'FALSE' value means the check passes.\n// Check passes if 'isNameTaken' returns FALSE.\n$this->Validate->def('userNameIsTaken', 'User','isNameTaken', 'Username already taken.', FALSE);\n$this->Validate->rule('username', 'required|userNameIsTaken');\n\n// Example 3 - A 'FALSE' value means the check passes. But we also need to pass along\n// whether accounts are identified by username or by email.\n// Check passes if 'accountExists' returns FALSE.\n$validationType = 'email'; // As opposed to 'username'\n$this->Validate->def('accountExists', 'Library\\\\Auth','accountExists', \"An account with that $validationType already exists.\"\", false, $validationType);\n$this->Validate->rule('email', 'required|accountExists|trim');\n\n// Then in the Auth Library:\npublic static function accountExists($authValue = false, $authField = false)\n{\n    // $authField is the field we are using for login validation, usually this is either 'username' or 'email'\n    // $authValue is the form data that was passed in. If validating by email, then presumably it's be the user's email address.\n\n    // Do stuff to figure out if an account exists, then return True or False.\n}",
            "title": "Custom Validation Checks"
        },
        {
            "location": "/documentation/v2/validationclass/overview/#human-readable-field-names",
            "text": "If you have a form input that has a name which isn't super user friendly, you can replace the name of the input in any error messages with a custom specified name by specifying an optional 3rd parameter when making your rules:  $this->Validate->rule('password2', 'required|matches[password]', 'Password Confirmation');  This will result in the following error message if validation fails:   \"Password Confirmation does not match password!\"",
            "title": "Human Readable Field Names"
        },
        {
            "location": "/documentation/v2/validationclass/overview/#displaying-errors",
            "text": "From within a View, the array of errors can be found within the \"$errors\" variable. They can be displayed by using the Load class' \"repeat\" method (this is the easiest way), or else you can manually iterate over the errors. Both methods are shown below:  Repeat Method:      // Parameter 1 = Array to iterate over.\n// Parameter 2 = Tag to surround array items with.\n// Parameter 3 = [OPTIONAL] CSS class to attach to each item.\n// Parameter 4 = [OPTIONAL] Tag to wrap entire repeat block with.\n// Parameter 5 = [OPTIONAL] CSS class to attach to wrapper.\n<?= $this->repeat($errors, 'li', 'item', 'ul', 'list'); ?>  Generates:  <ul class=\"list\">\n    <li class=\"item\">Error 1</li>\n    <li class=\"item\">Error 2</li>\n    ...\n</ul>  OR  Manual Method:      <?php if (isset($errors)) { ?>\n    <ul>\n        <?php foreach ($errors as $error) { ?>\n            <li><?= $error; ?></li>\n        <?php } ?>\n    </ul>\n<?php } ?>",
            "title": "Displaying errors"
        },
        {
            "location": "/documentation/v2/validationclass/overview/#repopulating-forms",
            "text": "There's three methods in the Validate class that are designed to help you repopulate a form if validation fails.  // For repopulating text boxes and text areas.\n$Validate->setField($fieldName, $defaultValue = '')\n\n// For repopulating check boxes and ratio buttons.\n$Validate->setCheckbox($fieldName, $fieldValue, $checkedByDefault = FALSE)\n\n// For repopulating select boxes.\n$Validate->setSelect($fieldName, $fieldValue, $selectedByDefault = FALSE)  These need to be echo'ed inside the HTML tag in question. See below for an example of a complete form with errors display and repopulation of the fields:   <h1>Create Article</h1>\n<form method=\"POST\">\n\n    <?= $this->repeat($errors, 'li', 'item', 'ul', 'list'); ?>\n\n\n    <div>\n        <h3>Title:</h3>\n        <input type=\"text\" name=\"title\" value=\"<?= $Validate->setField('title', 'test'); ?>\">\n    </div>\n    <div>\n        <h3>Content:</h3>\n        <textarea name=\"content\"><?= $Validate->setField('content'); ?></textarea>\n    </div>\n    <br>\n\n    <div>\n        Item 1:<input type=\"checkbox\" name=\"mycheck[]\" value=\"1\" <?=$Validate->setCheckbox('mycheck', '1');?>>\n        <br>\n        Item 2:<input type=\"checkbox\" name=\"mycheck[]\" value=\"2\" <?=$Validate->setCheckbox('mycheck', '2', true);?>>\n    </div>\n    <br>\n\n    <div>\n        <select name=\"myselect\">\n            <option value=\"Option One\" <?= $Validate->setSelect('myselect', 'Option One'); ?> >One</option>\n            <option value=\"Option Two\" <?= $Validate->setSelect('myselect', 'Option Two', true); ?> >Two</option>\n            <option value=\"Option Three\" <?= $Validate->setSelect('myselect', 'Option Three'); ?> >Three</option>\n        </select>\n    </div>\n    <br>\n\n    <input type=\"submit\" value=\"Submit\">\n</form>",
            "title": "Repopulating Forms"
        },
        {
            "location": "/computerscience/computability/",
            "text": "Computability\n\n\nModern computers are based on what's called a Turing Machine, which was the first general purpose type of computer. What can a Turing Machine based computer compute? What can\u2019t a turing machine based computer compute? \nWhat kind of problems are impractical to compute for anything other than really small data sets? We\u2019ll briefly explore these questions below.\n\n\nStraight up Non-Computable\n\n\nLet's first talk about problems that current computers simply cannot compute.\n\n\nThe Halting Problem\n\n\nIf you are a software developer, you undoubtably have encountered infinite loops. Unlike interpretted\nlanguages such as PHP which will time out, lower level languages such as C++ will just keep running in an infinite loop forever if one exists.\nWith this in mind, it may seem like a good idea for someone to create a debugging program that detects those kinds of run-time errors in apps.\nHowever, you may be surprised to learn that \nthe reason why no such program exists is because it's impossible for a computer to determine if an\narbitrary computer program and input will finish running or not.\n\n\nTo informally prove this, let's assume we have a function called \"does_it_halt\" which we can pass an arbitrary program and input to and have it\ntell us if the program will halt or loop indefinitely.\n\n\n\n\nAssumption:\n \n\nThere exists a way for a computer to detect if any arbitrary program and input will halt or not.\n\n\n\n\nWith that assumption, let's assume someone wrote the following function as a simple way to utilize this knowledge:\n\n\nfunction does_it_halt(program, input) {\n    if (eventually halts)\n        return true;\n    else\n        return false;\n}\n\n\n\n\nFor simplicity's sake let's also say someone wrote wrapper for this function that passes the program as the input. Remember that our\ndoes_it_halt method is supposed to work on any arbitrary input, so passing in the memory location or text of a program works just fine.\n\n\nfunction debug_app(program) {\n    return does_it_halt(program, program);\n}\n\n\n\n\nAlright, hopefully you'll agree this is pretty straight forward. Now let's say someone really smart informed us that our does_it_halt function\ncouldn't possibly work, but we didn't believe him. As a result, he decided to write a cheeky little function called paradox that does the following:\n\n\nfunction paradox(program) {\n    if(debug_app(program))\n        while(1) {};\n    else\n        return true;\n}\n\necho debug_app(paradox);\n\n\n\n\nHa ha ha... so this dude wrote a function that puts itself into an intentional infinite loop if the does_it_halt says the program stops,\nand returns \"true\" if the program does not stop. Then he follows this up by calling our debug function on his code. \nSurely this is the most useless bit of code ever written right?\n\n\nWell, before we can answer that, we have to examine what happens when this dude calls debug_app(paradox).\n\n\nLet's say our debug_app() method returns true when passed Paradox. Let's logically think through what that means in terms of execution:\n\n\n\n\nFirst up, since \"echo debug_app(Paradox)\" returned True, that means that Paradox halts.\n\n\nIn the process of testing if Paradox halts, does_it_halt(), somewhere in its magical logic would have to run Paradox with the given input. That input is also a reference to Paradox. So the call to paradox would look like \"paradox(paradox)\".\n\n\nHowever, inside of Paradox is also a call to debug_app()! This call to \"debug_app(program)\" within Paradox would resolve to \"debug_app(Paradox)\" at runtime.\n\n\nIn order for does_it_halt to detect that Paradox halts, that means the call to \"debug_app(Paradox)\" within Paradox returns False, because otherwise Paradox would send itself into an infinite loop.\n\n\n\n\nUhh oh! Turns out that little piece of code wasn't as useless as we originally thought because it just proved that our does_it_halt function can't possibly exist as we've defined it.\nWe know from point #1 above that \"echo debug_app(Paradox)\" returns true, however, we also know that in order for that to happen, the call to \"debug_app(Paradox)\" as mentioned in point #4 above must return false. So two different calls to \"debug_app(Paradox)\" are returning differing results which is impossible. As such, our premise is proved false by what's called a Proof By Contradiction.\n\n\nThis problem (\"will a program halt\") which is unsolvable by computers by is known commonly as The Halting Problem. Alan Turing proved back in 1936 that a general algorithm to solve it is not possible.\n\n\nPost-Correspondance Problem (PCP)\n\n\nAnother quick example just to peak your interest. Let's say you have a list of some arbitrary number of dominoes which look something like this:\n\n\n\n    \nc\n\n    \ncb\n\n\n\n\n\n\n    \nac\n\n    \na\n\n\n\n\n\n\n    \nb\n\n    \nbc\n\n\n\n\n\n\n    \na\n\n    \nba\n\n\n\n\n\n\n    \na\n\n    \nc\n\n\n\n\n\n\n    \nc\n\n    \nac\n\n\n\n\n\n\n    \ncb\n\n    \n \nc\n\n\n\n\n\n\n    \naa\n\n    \nb\n\n\n\n\n\n\n\n\nYou want to have a computer tell you whether there's a way in which you can order the dominoes such that the sequence of the top row matches the sequence of the bottom row.\nHere's an example of a match where both the top and the bottom read \"abbcbba\":\n\n\n\n\n\n\n    \na\n\n    \nabb\n\n\n\n\n\n\n    \nbb\n\n    \nc\n\n\n\n\n\n\n    \ncb\n\n    \nbb\n\n\n\n\n\n\n    \nba\n\n    \na\n\n\n\n\n\n\n\n\nCan a computer program be made for you that determines if there's an ordering that results in a match for an arbitrary set of dominoes? The answer is \"no\". This is called the Post Correspondence Problem and was introduced by Emil Post back in 1946.\n\n\nEffectively Uncomputable (with our current algorithms)\n\n\nP vs NP\n\n\nIn order to discuss problems that fall into this \"effectively uncomputable\" category, we quickly need to discuss the concept of P vs. NP.\n\"P\" are a class of problems for which their exists an algorithm to both find and verify an answer in polynomial time.\n\"NP\" (non-deterministic polynomial time) are a class of problems for which there exists algorithms to verify an answer in polynomial time, but \nmay or may not\n have algorithms to find an answer.\nNote the \"may or may not\" statement... P vs. NP is actually one of the biggest unknowns in Mathematics/CS because no-one has been able to prove definitively \nthat P = NP or that P != NP. \n\n\nIf P = NP, then that means there DOES exist polynomial time algorithms to solve problems we lump into this category, but that we just haven't found them yet. If P != NP, then that would confirm that no such polynomial time algorithms exist, and we could stop looking. There has been a 1 million dollar reward on the table since the year 2000 for anyone that can prove this one way or the other.\n\n\nSo if you're wondering at this point what the heck polynomial time is, and wishing you could remember all your math lessons from high school, no fear - let's look at an example:\n\n\nx^3 + 2x^2 + 3x = A Polynomial\n\n\n\n\nThe importance of polynomials is that they, and anything less complex than them, can be quickly solved by computers. Equations can be generally clumped into one of a number of different time groups:\n\n\ny = 1       // Constant time\ny = x       // Linear time\ny = x^2     // Polynomial time\ny = 2^x     // Exponential time\ny = x!      // Factorial time\n\n\n\n\nFor a more complete list of time complexities see: \nTime Complexity\n.\n\n\nThe problems we will be discussing which fall into this \"practically uncomputable\" category are \"NP\" problems for which we have no good algorithms to solve them. These are technically referred to as the \"NP-Complete\" class of problems, a term coined in the 1970s by researchers who realized that these problems are all essentially variations of the same thing, and if a solution could be found for one of them, it would mean all of them could in turn be solved.\n\n\nFor a good video on this topic, I'd recommend the following:\n\n\n\n\n\nThe Travelling Salesman Problem\n\n\nThe travelling salesman problem is a certain instance of a problem that has many general purpose applications. The scenario goes like this: you are a salesman who needs to travel to a bunch of cities, and end your trip where you started in your home city. You obviously want to minimize your travel time by taking the most efficient route that takes you through all the cities.\n\n\nFor an example of this problem, let's use a scenario where we want to visit just 4 cities, and so starting at city A, we need to calculate the optimal route. Each city has a travel time \"cost\" to travel between them that we'll use to calculate the best route.\n\n\n\n\nWe are starting in city A, so we just need to evaluate all our options that take us through all the cities and add up the travel costs like so:\n\n\n\n    \n\n        \nRoute\nRoute Costs\nTotal Cost\n\n    \n\n    \n\n        \nA->B->C->D->A\n3+5+6+2\n16\n\n    \n\n    \n\n        \nA->B->D->C->A\n3+3+6+8\n20\n\n    \n\n    \n\n        \nA->D->C->B->A\n2+6+5+3\n16\n\n    \n\n    \n\n        \nA->D->B->C->A\n2+3+5+8\n18\n\n    \n\n    \n\n        \nA->C->B->D->A\n8+5+3+2\n18\n\n    \n\n    \n\n        \nA->C->D->B->A\n8+6+3+3\n20\n\n    \n\n\n\n\n\nOne thing you might notice is that there's two routes that cost 16, two routes that cost 18, and two routes that cost 20. This is because one of each of these pairs is just the same route in reverse. So if you do ABCDA, it's the same route if you do it backwards as ADCBA! For this reason we can eliminate these duplicate routes, cutting our total routes to consider in half, and narrow our choices down to 3 real options. Obviously we would choose the one that costs 16.\n\n\n\n    \n\n        \nRoute\nRoute Costs\nTotal Cost\n\n    \n\n    \n\n        \nA->B->C->D->A\n3+5+6+2\n16\n\n    \n\n    \n\n        \nA->B->D->C->A\n3+3+6+8\n20\n\n    \n\n    \n\n        \nA->C->B->D->A\n8+5+3+2\n18\n\n    \n\n\n\n\n\nNow what if we needed to travel between 5 cities instead of 4? How much extra work would this be to figure out? Let's call this 5th city 'E' and examine just a piece of this expanded problem by determining the routes possible when we start with city B:\n\n\n\n\n\n    \n\n        \nRoute\nRoute Costs\nTotal Cost\n\n    \n\n    \n\n        \nA->B->C->D->E->A\n3+5+6+4+7\n25\n\n    \n\n    \n\n        \nA->B->C->E->D->A\n3+5+2+4+2\n16\n\n    \n\n    \n\n        \nA->B->D->C->E->A\n3+3+6+2+7\n21\n\n    \n\n    \n\n        \nA->B->D->E->C->A\n3+3+4+2+8\n20\n\n    \n\n    \n\n        \nA->B->E->C->D->A\n3+6+2+6+2\n19\n\n    \n\n    \n\n        \nA->B->E->D->C->A\n3+6+4+6+8\n27\n\n    \n\n    \n\n        \nA->C->...(continued)\n...\n...\n\n    \n\n\n\n\n\nWow! Not only does that graph look WAYYYYY more complicated, expanding the problem size to 5 cities gives us a lot more routes to consider.\n\n\nAs you can see, going from just 4 cities to 5 increased our options when we start our travels by going to city B first from just two, up to six! Similarly, our total number of route combinations increased from 6 up to 24 (if you finish the above example by mapping out all the possibilities you'll see there are 24). Of course we can still eliminate duplicates and cut that number of possible routes in half down to 12... but that's still a big jump from the 3 possibilities we had previously. \n\n\nWhat's important to realize is that this travelling salesman problem is one that has a factorial growth rate! To be more exact, the formula for the number of combinations that need to be considered when the number of cities is 'X' is this:\n\n\n(X - 1)! / 2\n\n\n\n\nIf you don't quite remember how factorials are calculated, here's an example:\n\n\n4! = 1 * 2 * 3 * 4 = 24\n\n\n\n\nFactorial growth is even worse than exponential growth!!!\n\n\n\n    \nn\n  \nn! (# of permutations)\n         \n~Time to Compute\n\n    \n\n        \n4\n  \n        \n24\n                             \n        \n-\n\n    \n\n    \n\n        \n5\n  \n        \n120\n                            \n        \n-\n\n    \n\n    \n\n        \n6\n  \n        \n720\n                            \n        \n-\n\n    \n\n    \n\n        \n7\n  \n        \n5,040\n                          \n        \n-\n\n    \n\n    \n\n        \n8\n  \n        \n40,320\n                         \n        \n-\n\n    \n\n    \n\n        \n9\n  \n        \n362,880\n                        \n        \n-\n\n    \n\n    \n\n        \n10\n \n        \n3,628,800\n                      \n        \n3 seconds\n\n    \n\n    \n\n        \n11\n \n        \n39,916,800\n                     \n        \n56 seconds\n\n    \n\n    \n\n        \n12\n \n        \n479,001,600\n                    \n        \n>11 minutes\n\n    \n\n    \n\n        \n13\n \n        \n6,227,020,800\n                  \n        \n~2.5 hours\n\n    \n\n    \n\n        \n14\n \n        \n87,178,291,200\n                 \n        \n~34 hours\n\n    \n\n    \n\n        \n15\n \n        \n1,307,674,368,000\n              \n        \n~21 days\n\n    \n\n    \n\n        \n16\n \n        \n20,922,789,888,000\n             \n        \n~340 days\n\n    \n\n    \n\n        \n17\n \n        \n355,687,428,096,000\n            \n        \n~15.8 years\n\n    \n\n    \n\n        \n18\n \n        \n6,402,373,705,728,000\n          \n        \n~284 years\n\n    \n\n    \n\n        \n19\n \n        \n121,645,100,408,832,000\n        \n        \n~5,411 years\n\n    \n\n    \n\n        \n20\n \n        \n2,432,902,008,176,640,000\n      \n        \n~108,230 years\n\n    \n\n\n\n\n\nExplanation of Factorial Growth\n\n\nLooking at the table to the left, you can see that factorial growth is extremely fast! We very quickly go from small, manageable numbers like the 4! we did an example of above, to astronomically large numbers very quickly. Why this matters is that in order to brute-force a solution to the Travelling Salesman problem, we have to calculate all the routes to determine the best one. So if there are 'n' route permutations (a permutation is a set of data where the order of the data matters), then that means 'n' routes we have to consider. And since the number of possible routes is growing factorially, this quickly means huge numbers as can be seen in the table.\n\n\nIn order to give you an idea of how difficult solving the Travelling Salesman problem is for a modern computer, I decided to do some tests with my Macbook Pro, 2.4ghz Intel i7, with 16 gigs of RAM. I didn't have an exact implementation of the Travelling Salesman on hand for testing, however, I did have an implementation of the Johnson-Trotter algorithm that I wrote. The Johnson-Trotter algorithm is used to generate all the possible permutations of a number of length 'n'. For instance, if you run Johnson-Trotter on number sequences of length 3, you get the following: \n123,\n132, \n312, \n321, \n231, \n213. A total of 6 permutations, which equals 3!. \nIn other words, this is the same factorial growth, consider all the possible permutations, type of problem that we are dealing with for the Travelling Salesman. I ran this algorithm for numbers of length 10 and 11 (thus calculating all the permutations of each), and used the calculation speed gathered from those tests to make estimates for the larger numbers. I think you can see how calculating the best route for the salesman via considering all the possible routes is simply not calculatable for any reasonably large number of cities.\n\n\nIt's not all doom and gloom though! In the same way that humans can look at a map and know that traveling from LA to Boston, then to Seattle, then back to Florida is going to be a horribly inefficient route without even thinking about it, there are ways to figure out the TSP quicker than considering all the possible permutations. The current fastest methods are known as Branch and Bound methods, which you can research if you want to learn more.\n\n\nThe Knapsack Problem\n\n\nAnother problem that falls into the same NP-Complete category as the Travelling Salesman that you might find interesting is the Knapsack Problem. It goes like this: say you are a thief with a backpack that can hold a max of 50 pounds in weight. With a collection of different objects nearby of differing weights and values, you want to know what the most optimal set of items you should steal are that can fit into your pack. This problem is also a factorial growth example.\n\n\nHope these examples peaked your interest into computability!",
            "title": "Computability"
        },
        {
            "location": "/computerscience/computability/#computability",
            "text": "Modern computers are based on what's called a Turing Machine, which was the first general purpose type of computer. What can a Turing Machine based computer compute? What can\u2019t a turing machine based computer compute? \nWhat kind of problems are impractical to compute for anything other than really small data sets? We\u2019ll briefly explore these questions below.",
            "title": "Computability"
        },
        {
            "location": "/computerscience/computability/#straight-up-non-computable",
            "text": "Let's first talk about problems that current computers simply cannot compute.",
            "title": "Straight up Non-Computable"
        },
        {
            "location": "/computerscience/computability/#the-halting-problem",
            "text": "If you are a software developer, you undoubtably have encountered infinite loops. Unlike interpretted\nlanguages such as PHP which will time out, lower level languages such as C++ will just keep running in an infinite loop forever if one exists.\nWith this in mind, it may seem like a good idea for someone to create a debugging program that detects those kinds of run-time errors in apps.\nHowever, you may be surprised to learn that  the reason why no such program exists is because it's impossible for a computer to determine if an\narbitrary computer program and input will finish running or not.  To informally prove this, let's assume we have a function called \"does_it_halt\" which we can pass an arbitrary program and input to and have it\ntell us if the program will halt or loop indefinitely.   Assumption:   \nThere exists a way for a computer to detect if any arbitrary program and input will halt or not.   With that assumption, let's assume someone wrote the following function as a simple way to utilize this knowledge:  function does_it_halt(program, input) {\n    if (eventually halts)\n        return true;\n    else\n        return false;\n}  For simplicity's sake let's also say someone wrote wrapper for this function that passes the program as the input. Remember that our\ndoes_it_halt method is supposed to work on any arbitrary input, so passing in the memory location or text of a program works just fine.  function debug_app(program) {\n    return does_it_halt(program, program);\n}  Alright, hopefully you'll agree this is pretty straight forward. Now let's say someone really smart informed us that our does_it_halt function\ncouldn't possibly work, but we didn't believe him. As a result, he decided to write a cheeky little function called paradox that does the following:  function paradox(program) {\n    if(debug_app(program))\n        while(1) {};\n    else\n        return true;\n}\n\necho debug_app(paradox);  Ha ha ha... so this dude wrote a function that puts itself into an intentional infinite loop if the does_it_halt says the program stops,\nand returns \"true\" if the program does not stop. Then he follows this up by calling our debug function on his code. \nSurely this is the most useless bit of code ever written right?  Well, before we can answer that, we have to examine what happens when this dude calls debug_app(paradox).  Let's say our debug_app() method returns true when passed Paradox. Let's logically think through what that means in terms of execution:   First up, since \"echo debug_app(Paradox)\" returned True, that means that Paradox halts.  In the process of testing if Paradox halts, does_it_halt(), somewhere in its magical logic would have to run Paradox with the given input. That input is also a reference to Paradox. So the call to paradox would look like \"paradox(paradox)\".  However, inside of Paradox is also a call to debug_app()! This call to \"debug_app(program)\" within Paradox would resolve to \"debug_app(Paradox)\" at runtime.  In order for does_it_halt to detect that Paradox halts, that means the call to \"debug_app(Paradox)\" within Paradox returns False, because otherwise Paradox would send itself into an infinite loop.   Uhh oh! Turns out that little piece of code wasn't as useless as we originally thought because it just proved that our does_it_halt function can't possibly exist as we've defined it.\nWe know from point #1 above that \"echo debug_app(Paradox)\" returns true, however, we also know that in order for that to happen, the call to \"debug_app(Paradox)\" as mentioned in point #4 above must return false. So two different calls to \"debug_app(Paradox)\" are returning differing results which is impossible. As such, our premise is proved false by what's called a Proof By Contradiction.  This problem (\"will a program halt\") which is unsolvable by computers by is known commonly as The Halting Problem. Alan Turing proved back in 1936 that a general algorithm to solve it is not possible.",
            "title": "The Halting Problem"
        },
        {
            "location": "/computerscience/computability/#post-correspondance-problem-pcp",
            "text": "Another quick example just to peak your interest. Let's say you have a list of some arbitrary number of dominoes which look something like this:  \n     c \n     cb   \n     ac \n     a   \n     b \n     bc   \n     a \n     ba   \n     a \n     c   \n     c \n     ac   \n     cb \n       c   \n     aa \n     b    You want to have a computer tell you whether there's a way in which you can order the dominoes such that the sequence of the top row matches the sequence of the bottom row.\nHere's an example of a match where both the top and the bottom read \"abbcbba\":   \n     a \n     abb   \n     bb \n     c   \n     cb \n     bb   \n     ba \n     a    Can a computer program be made for you that determines if there's an ordering that results in a match for an arbitrary set of dominoes? The answer is \"no\". This is called the Post Correspondence Problem and was introduced by Emil Post back in 1946.",
            "title": "Post-Correspondance Problem (PCP)"
        },
        {
            "location": "/computerscience/computability/#effectively-uncomputable-with-our-current-algorithms",
            "text": "",
            "title": "Effectively Uncomputable (with our current algorithms)"
        },
        {
            "location": "/computerscience/computability/#p-vs-np",
            "text": "In order to discuss problems that fall into this \"effectively uncomputable\" category, we quickly need to discuss the concept of P vs. NP.\n\"P\" are a class of problems for which their exists an algorithm to both find and verify an answer in polynomial time.\n\"NP\" (non-deterministic polynomial time) are a class of problems for which there exists algorithms to verify an answer in polynomial time, but  may or may not  have algorithms to find an answer.\nNote the \"may or may not\" statement... P vs. NP is actually one of the biggest unknowns in Mathematics/CS because no-one has been able to prove definitively \nthat P = NP or that P != NP.   If P = NP, then that means there DOES exist polynomial time algorithms to solve problems we lump into this category, but that we just haven't found them yet. If P != NP, then that would confirm that no such polynomial time algorithms exist, and we could stop looking. There has been a 1 million dollar reward on the table since the year 2000 for anyone that can prove this one way or the other.  So if you're wondering at this point what the heck polynomial time is, and wishing you could remember all your math lessons from high school, no fear - let's look at an example:  x^3 + 2x^2 + 3x = A Polynomial  The importance of polynomials is that they, and anything less complex than them, can be quickly solved by computers. Equations can be generally clumped into one of a number of different time groups:  y = 1       // Constant time\ny = x       // Linear time\ny = x^2     // Polynomial time\ny = 2^x     // Exponential time\ny = x!      // Factorial time  For a more complete list of time complexities see:  Time Complexity .  The problems we will be discussing which fall into this \"practically uncomputable\" category are \"NP\" problems for which we have no good algorithms to solve them. These are technically referred to as the \"NP-Complete\" class of problems, a term coined in the 1970s by researchers who realized that these problems are all essentially variations of the same thing, and if a solution could be found for one of them, it would mean all of them could in turn be solved.  For a good video on this topic, I'd recommend the following:",
            "title": "P vs NP"
        },
        {
            "location": "/computerscience/computability/#the-travelling-salesman-problem",
            "text": "The travelling salesman problem is a certain instance of a problem that has many general purpose applications. The scenario goes like this: you are a salesman who needs to travel to a bunch of cities, and end your trip where you started in your home city. You obviously want to minimize your travel time by taking the most efficient route that takes you through all the cities.  For an example of this problem, let's use a scenario where we want to visit just 4 cities, and so starting at city A, we need to calculate the optimal route. Each city has a travel time \"cost\" to travel between them that we'll use to calculate the best route.   We are starting in city A, so we just need to evaluate all our options that take us through all the cities and add up the travel costs like so:  \n     \n         Route Route Costs Total Cost \n     \n     \n         A->B->C->D->A 3+5+6+2 16 \n     \n     \n         A->B->D->C->A 3+3+6+8 20 \n     \n     \n         A->D->C->B->A 2+6+5+3 16 \n     \n     \n         A->D->B->C->A 2+3+5+8 18 \n     \n     \n         A->C->B->D->A 8+5+3+2 18 \n     \n     \n         A->C->D->B->A 8+6+3+3 20 \n       One thing you might notice is that there's two routes that cost 16, two routes that cost 18, and two routes that cost 20. This is because one of each of these pairs is just the same route in reverse. So if you do ABCDA, it's the same route if you do it backwards as ADCBA! For this reason we can eliminate these duplicate routes, cutting our total routes to consider in half, and narrow our choices down to 3 real options. Obviously we would choose the one that costs 16.  \n     \n         Route Route Costs Total Cost \n     \n     \n         A->B->C->D->A 3+5+6+2 16 \n     \n     \n         A->B->D->C->A 3+3+6+8 20 \n     \n     \n         A->C->B->D->A 8+5+3+2 18 \n       Now what if we needed to travel between 5 cities instead of 4? How much extra work would this be to figure out? Let's call this 5th city 'E' and examine just a piece of this expanded problem by determining the routes possible when we start with city B:   \n     \n         Route Route Costs Total Cost \n     \n     \n         A->B->C->D->E->A 3+5+6+4+7 25 \n     \n     \n         A->B->C->E->D->A 3+5+2+4+2 16 \n     \n     \n         A->B->D->C->E->A 3+3+6+2+7 21 \n     \n     \n         A->B->D->E->C->A 3+3+4+2+8 20 \n     \n     \n         A->B->E->C->D->A 3+6+2+6+2 19 \n     \n     \n         A->B->E->D->C->A 3+6+4+6+8 27 \n     \n     \n         A->C->...(continued) ... ... \n       Wow! Not only does that graph look WAYYYYY more complicated, expanding the problem size to 5 cities gives us a lot more routes to consider.  As you can see, going from just 4 cities to 5 increased our options when we start our travels by going to city B first from just two, up to six! Similarly, our total number of route combinations increased from 6 up to 24 (if you finish the above example by mapping out all the possibilities you'll see there are 24). Of course we can still eliminate duplicates and cut that number of possible routes in half down to 12... but that's still a big jump from the 3 possibilities we had previously.   What's important to realize is that this travelling salesman problem is one that has a factorial growth rate! To be more exact, the formula for the number of combinations that need to be considered when the number of cities is 'X' is this:  (X - 1)! / 2  If you don't quite remember how factorials are calculated, here's an example:  4! = 1 * 2 * 3 * 4 = 24  Factorial growth is even worse than exponential growth!!!  \n     n    n! (# of permutations)           ~Time to Compute \n     \n         4   \n         24                              \n         - \n     \n     \n         5   \n         120                             \n         - \n     \n     \n         6   \n         720                             \n         - \n     \n     \n         7   \n         5,040                           \n         - \n     \n     \n         8   \n         40,320                          \n         - \n     \n     \n         9   \n         362,880                         \n         - \n     \n     \n         10  \n         3,628,800                       \n         3 seconds \n     \n     \n         11  \n         39,916,800                      \n         56 seconds \n     \n     \n         12  \n         479,001,600                     \n         >11 minutes \n     \n     \n         13  \n         6,227,020,800                   \n         ~2.5 hours \n     \n     \n         14  \n         87,178,291,200                  \n         ~34 hours \n     \n     \n         15  \n         1,307,674,368,000               \n         ~21 days \n     \n     \n         16  \n         20,922,789,888,000              \n         ~340 days \n     \n     \n         17  \n         355,687,428,096,000             \n         ~15.8 years \n     \n     \n         18  \n         6,402,373,705,728,000           \n         ~284 years \n     \n     \n         19  \n         121,645,100,408,832,000         \n         ~5,411 years \n     \n     \n         20  \n         2,432,902,008,176,640,000       \n         ~108,230 years",
            "title": "The Travelling Salesman Problem"
        },
        {
            "location": "/computerscience/computability/#explanation-of-factorial-growth",
            "text": "Looking at the table to the left, you can see that factorial growth is extremely fast! We very quickly go from small, manageable numbers like the 4! we did an example of above, to astronomically large numbers very quickly. Why this matters is that in order to brute-force a solution to the Travelling Salesman problem, we have to calculate all the routes to determine the best one. So if there are 'n' route permutations (a permutation is a set of data where the order of the data matters), then that means 'n' routes we have to consider. And since the number of possible routes is growing factorially, this quickly means huge numbers as can be seen in the table.  In order to give you an idea of how difficult solving the Travelling Salesman problem is for a modern computer, I decided to do some tests with my Macbook Pro, 2.4ghz Intel i7, with 16 gigs of RAM. I didn't have an exact implementation of the Travelling Salesman on hand for testing, however, I did have an implementation of the Johnson-Trotter algorithm that I wrote. The Johnson-Trotter algorithm is used to generate all the possible permutations of a number of length 'n'. For instance, if you run Johnson-Trotter on number sequences of length 3, you get the following: \n123,\n132, \n312, \n321, \n231, \n213. A total of 6 permutations, which equals 3!. \nIn other words, this is the same factorial growth, consider all the possible permutations, type of problem that we are dealing with for the Travelling Salesman. I ran this algorithm for numbers of length 10 and 11 (thus calculating all the permutations of each), and used the calculation speed gathered from those tests to make estimates for the larger numbers. I think you can see how calculating the best route for the salesman via considering all the possible routes is simply not calculatable for any reasonably large number of cities.  It's not all doom and gloom though! In the same way that humans can look at a map and know that traveling from LA to Boston, then to Seattle, then back to Florida is going to be a horribly inefficient route without even thinking about it, there are ways to figure out the TSP quicker than considering all the possible permutations. The current fastest methods are known as Branch and Bound methods, which you can research if you want to learn more.",
            "title": "Explanation of Factorial Growth"
        },
        {
            "location": "/computerscience/computability/#the-knapsack-problem",
            "text": "Another problem that falls into the same NP-Complete category as the Travelling Salesman that you might find interesting is the Knapsack Problem. It goes like this: say you are a thief with a backpack that can hold a max of 50 pounds in weight. With a collection of different objects nearby of differing weights and values, you want to know what the most optimal set of items you should steal are that can fit into your pack. This problem is also a factorial growth example.  Hope these examples peaked your interest into computability!",
            "title": "The Knapsack Problem"
        }
    ]
}