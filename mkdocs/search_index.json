{
    "docs": [
        {
            "location": "/",
            "text": "About Cora\n\n\nCora is an MVC style framework for rapidly building scalable web applications. \nThe goal of the project is to make a powerful and well-built infrastructure that is EASY TO USE and well documented. \nThis is a project aimed at experienced world-class developers and the just starting out novice alike. We don't shy away\nfrom advanced design patterns, but rather make every effort to encapsulate that complexity away from the developer\nso that they can focus on creating apps, not wrestling with a framework. Our hope\nis that this results in cleaner, more understandable code for all involved.\n\n\nCore Values\n\n\n\n\nCora should be easy to use.\n\n\nYou shouldn't need to spend a lot of time configuring things to get up and running.\n\n\nYou shouldn't need a degree in computer science to understand what is going on.\n\n\nYou shouldn't need to take a class on how to use the framework.\n\n\nThe framework should make your life as a developer easier, and help you work faster and better.\n\n\n\n\n\n\nLearning should fun.\n\n\nDocumentation should be useful to both experienced and novice developers alike.\n\n\nDocumentation should provide the needed info to experienced developers at a glance.\n\n\nMore in-depth documentation should be written in a ELI5 (Explain it Like I'm 5) style of explanation.\n\n\nDocumentation should be full of great examples to help bring understanding of the concepts.\n\n\n\n\n\n\nFlexible, Powerful, and Simple - Choose 3.\n\n\nCora should be able to accomodate a variety of programming styles.\n\n\nCora should be integratable into existing software projects.\n\n\nCora should provide developers with powerful tools to help make developing easier/faster.\n\n\nCora should be fully extendable and customizable.\n\n\nCora should do all this while staying simple.\n\n\n\n\n\n\n\n\nBeing a Trend-Setter for PHP\n\n\nPHP originally gained massive popularity for it's ease of entry and wide availability. While the wide availability is still there, \nit feels as though that focus on making PHP accessible to the masses has fallen off in recent years. As a result it could be argued that PHP\nhas lost its sense of identity, leaving it only as a mediocre contender amongst the group of popular programming languages where it can be argued that PHP has a syntax that\nis sub-par and lots of left-over baggage from it's pre-OOP days.\n\n\nIt's the hope of the Cora project to bring back that sense of excitement and identity that made PHP a standout language for so many years.\n\n\nSincerely, \n\nJosiah Bubna & Team\n\n\n\n\nNext: Installation",
            "title": "About"
        },
        {
            "location": "/#about-cora",
            "text": "Cora is an MVC style framework for rapidly building scalable web applications. \nThe goal of the project is to make a powerful and well-built infrastructure that is EASY TO USE and well documented. \nThis is a project aimed at experienced world-class developers and the just starting out novice alike. We don't shy away\nfrom advanced design patterns, but rather make every effort to encapsulate that complexity away from the developer\nso that they can focus on creating apps, not wrestling with a framework. Our hope\nis that this results in cleaner, more understandable code for all involved.",
            "title": "About Cora"
        },
        {
            "location": "/#core-values",
            "text": "Cora should be easy to use.  You shouldn't need to spend a lot of time configuring things to get up and running.  You shouldn't need a degree in computer science to understand what is going on.  You shouldn't need to take a class on how to use the framework.  The framework should make your life as a developer easier, and help you work faster and better.    Learning should fun.  Documentation should be useful to both experienced and novice developers alike.  Documentation should provide the needed info to experienced developers at a glance.  More in-depth documentation should be written in a ELI5 (Explain it Like I'm 5) style of explanation.  Documentation should be full of great examples to help bring understanding of the concepts.    Flexible, Powerful, and Simple - Choose 3.  Cora should be able to accomodate a variety of programming styles.  Cora should be integratable into existing software projects.  Cora should provide developers with powerful tools to help make developing easier/faster.  Cora should be fully extendable and customizable.  Cora should do all this while staying simple.",
            "title": "Core Values"
        },
        {
            "location": "/#being-a-trend-setter-for-php",
            "text": "PHP originally gained massive popularity for it's ease of entry and wide availability. While the wide availability is still there, \nit feels as though that focus on making PHP accessible to the masses has fallen off in recent years. As a result it could be argued that PHP\nhas lost its sense of identity, leaving it only as a mediocre contender amongst the group of popular programming languages where it can be argued that PHP has a syntax that\nis sub-par and lots of left-over baggage from it's pre-OOP days.  It's the hope of the Cora project to bring back that sense of excitement and identity that made PHP a standout language for so many years.  Sincerely,  \nJosiah Bubna & Team   Next: Installation",
            "title": "Being a Trend-Setter for PHP"
        },
        {
            "location": "/setup/install/",
            "text": "Installation and Setup\n\n\nThere are three main ways you can download and start using Cora. The easiest is going to be just using Composer, \nthe 2nd easiest would be to clone the Github repository, and lastly you could just download the ZIP off Github.\nSee below for instructions for each. First before you do that though, make sure you have the needed supporting software\nrunning on your machine.\n\n\nSetting Up A Computer For PHP Development\n\n\nThroughout this documentation there are a few pieces of software which are assumed to be on your computer. If you don't have these programs,\nthen you'll need to get them if you want to follow along with any examples we give.\n\n\nRequired: \"AMP\" stack\n \n\nFirstly, it is necessary you have some sort of \"AMP\" stack available on your computer. If you aren't familiar with this term, it's usually short for\nApache+MySQL+PHP, but is used as a catch-all term for having a web server (like Apache), a database solution (such as MySQL),\nand a programming language (such as PHP or Python). If you are just getting into development work and do not already have this\nsetup available on your computer, see below for some recommendations on getting that in place:\n\n\n\n\nIf you are using Windows or Linux, we'd recommend trying \nXAMPP\n.\n\n\nIf you are using a Mac, we'd recommend trying \nMAMP\n.\n\n\n\n\nRequired: Git\n \n\nGit is a type of version control software. Its most important feature is it allows multiple developers \nto work on a project at the same time by automatically (mostly) combining the code written and allowing \neach developer to grab the latest version of the codebase when someone else submits changes. However, \nit's also highly useful when working alone too. It will allow you to easily undo code if you break something \nand want to return your project to an earlier point in time, it will allow you to work on multiple in-progress \nnew features simultaneously without worrying about one partially finished feature screwing things up for another piece, etc.\nSo it's essential if you end up working in a team, and useful if you're by yourself, and overall a REALLY good habit to get used\nto using it. Pretty much all software developers use Git nowadays.\n\n\nTo install Git:\n\n\n\n\nYour best bet is probably to download Github Desktop which includes a copy of Git with it: \nGithub Desktop\n.\n\n\nAlternatively you can check out the installation options \nhere\n.\n\n\n\n\nRequired: Terminal/Powershell Window\n \n\nGraphical User Interfaces (GUIs) are what made computing friendly for the average Joe Shmo and lead us to the digitally connected society \nwe have today. However, if you're planning on getting into development work, you'll find it much easier to do if you get familar with using a terminal.\nA terminal is just a text interface where you can give your computer commands. If you want to learn more about how to use terminals, try Googling \n\"beginnners guide to using a terminal\" and some results will pop up.\n\n\n\n\nUsing Windows\n: Search your computer for \"Powershell\". Then make a shortcut to Windows Powershell where you can easily access it. It's important to note that the Git install adds Unix style commands to it which you will need to follow along with our tutorials - SO MAKE SURE YOU INSTALL GIT from the instructions above!\n\n\nUsing a Mac\n: We'd recommend you download \niTerm2\n.\n\n\nUsing Linux\n: Let's be honest... you don't need me to tell you how to access the terminal. \ncough\n likey Ctrl+Alt+T \ncough\n\n\n\n\nHighly Recommended: Composer\n \n\nComposer is a dependancy manager that helps you install and update software libraries (aka code written by other people that\nyou end up using in your project). This includes Cora itself! You can use Composer as an easy way to install Cora (instructions in the \nInstallation Using Composer section below) and update to the latest version of Cora later on down the road if a newer release comes out\nafter you've already started your project (see \nHERE\n for details on using Composer with Cora).\n\n\n\n\nTo download Composer go here \nhttps://getcomposer.org/\n.\n\n\n\n\nInstallation Using Composer\n\n\nOpen up a Terminal window and navigate to the location where you'd like to put the Cora folder that holds the project files. \nIf you are installing to your root web directory, typically this will be named \"htdocs\" or \"public_html\". \n\n\nMac\n\n\nFor instance: if you're using a Mac and installed MAMP, you probably want to navigate to\n\n\ncd /Applications/MAMP/htdocs\n\n\n\n\nWindows\n\n\nIf you're using Windows and installed XAMPP, you likely want to go to\n\n\ncd C:\\xampp\\htdocs\n\n\n\n\nGet Cora\n\n\nOnce you are at the location you want to install Cora to, type:\n\n\nphp composer.phar create-project cora/cora\n\n\n\n\nOR if you installed Composer globally as part of your PATH (which we'd recommend doing if you know how) type:\n\n\ncomposer create-project cora/cora\n\n\n\n\nThat's it!\n If all went well you should now have a folder named \"Cora\" in your specified directory.\n\n\nInstallation Using Git\n\n\nOpen up a Terminal window and navigate to the location where you'd like to put the Cora folder that holds the project files. \nIf you are installing to your root web directory, typically this will be named \"htdocs\" or \"public_html\". \nFor instance: if you're using a Mac and installed MAMP, you probably want to navigate to\n\n\ncd /Applications/MAMP/htdocs\n\n\n\n\nIf you're using Windows and installed XAMPP, you likely want to go to\n\n\ncd C:\\xampp\\htdocs\n\n\n\n\nOnce you are at the location you want to install Cora to, type:\n\n\ngit clone https://github.com/joebubna/Cora.git\n\n\n\n\nThat's it!\n If all went well you should now have a folder named \"Cora\" in your specified directory.\n\n\nInstallation From ZIP File\n\n\nGo to \nhttps://github.com/joebubna/Cora\n and click the \"Download ZIP\" button on the right hand side\nof the page. Use your Finder or File Explorer in your OS and go to your web directory (probably either \"C:\\xampp\\htdocs\" if you're on Windows\nor \"/Applications/MAMP/htdocs\" if you're on a Mac). Unpack the contents of the ZIP file into this directory.\n\n\nThat's it!\n If all went well you should now have a folder named \"Cora\" in your specified directory.\n\n\nConfiguration to Get it Working\n\n\nThere's a few configuration options that might need to be setup first before you can start using Cora. Click below to continue to the Configuration instructions. \n\n\n\n\nNext: Configuration",
            "title": "Installation"
        },
        {
            "location": "/setup/install/#installation-and-setup",
            "text": "There are three main ways you can download and start using Cora. The easiest is going to be just using Composer, \nthe 2nd easiest would be to clone the Github repository, and lastly you could just download the ZIP off Github.\nSee below for instructions for each. First before you do that though, make sure you have the needed supporting software\nrunning on your machine.",
            "title": "Installation and Setup"
        },
        {
            "location": "/setup/install/#setting-up-a-computer-for-php-development",
            "text": "Throughout this documentation there are a few pieces of software which are assumed to be on your computer. If you don't have these programs,\nthen you'll need to get them if you want to follow along with any examples we give.  Required: \"AMP\" stack   \nFirstly, it is necessary you have some sort of \"AMP\" stack available on your computer. If you aren't familiar with this term, it's usually short for\nApache+MySQL+PHP, but is used as a catch-all term for having a web server (like Apache), a database solution (such as MySQL),\nand a programming language (such as PHP or Python). If you are just getting into development work and do not already have this\nsetup available on your computer, see below for some recommendations on getting that in place:   If you are using Windows or Linux, we'd recommend trying  XAMPP .  If you are using a Mac, we'd recommend trying  MAMP .   Required: Git   \nGit is a type of version control software. Its most important feature is it allows multiple developers \nto work on a project at the same time by automatically (mostly) combining the code written and allowing \neach developer to grab the latest version of the codebase when someone else submits changes. However, \nit's also highly useful when working alone too. It will allow you to easily undo code if you break something \nand want to return your project to an earlier point in time, it will allow you to work on multiple in-progress \nnew features simultaneously without worrying about one partially finished feature screwing things up for another piece, etc.\nSo it's essential if you end up working in a team, and useful if you're by yourself, and overall a REALLY good habit to get used\nto using it. Pretty much all software developers use Git nowadays.  To install Git:   Your best bet is probably to download Github Desktop which includes a copy of Git with it:  Github Desktop .  Alternatively you can check out the installation options  here .   Required: Terminal/Powershell Window   \nGraphical User Interfaces (GUIs) are what made computing friendly for the average Joe Shmo and lead us to the digitally connected society \nwe have today. However, if you're planning on getting into development work, you'll find it much easier to do if you get familar with using a terminal.\nA terminal is just a text interface where you can give your computer commands. If you want to learn more about how to use terminals, try Googling \n\"beginnners guide to using a terminal\" and some results will pop up.   Using Windows : Search your computer for \"Powershell\". Then make a shortcut to Windows Powershell where you can easily access it. It's important to note that the Git install adds Unix style commands to it which you will need to follow along with our tutorials - SO MAKE SURE YOU INSTALL GIT from the instructions above!  Using a Mac : We'd recommend you download  iTerm2 .  Using Linux : Let's be honest... you don't need me to tell you how to access the terminal.  cough  likey Ctrl+Alt+T  cough   Highly Recommended: Composer   \nComposer is a dependancy manager that helps you install and update software libraries (aka code written by other people that\nyou end up using in your project). This includes Cora itself! You can use Composer as an easy way to install Cora (instructions in the \nInstallation Using Composer section below) and update to the latest version of Cora later on down the road if a newer release comes out\nafter you've already started your project (see  HERE  for details on using Composer with Cora).   To download Composer go here  https://getcomposer.org/ .",
            "title": "Setting Up A Computer For PHP Development"
        },
        {
            "location": "/setup/install/#installation-using-composer",
            "text": "Open up a Terminal window and navigate to the location where you'd like to put the Cora folder that holds the project files. \nIf you are installing to your root web directory, typically this will be named \"htdocs\" or \"public_html\".",
            "title": "Installation Using Composer"
        },
        {
            "location": "/setup/install/#mac",
            "text": "For instance: if you're using a Mac and installed MAMP, you probably want to navigate to  cd /Applications/MAMP/htdocs",
            "title": "Mac"
        },
        {
            "location": "/setup/install/#windows",
            "text": "If you're using Windows and installed XAMPP, you likely want to go to  cd C:\\xampp\\htdocs",
            "title": "Windows"
        },
        {
            "location": "/setup/install/#get-cora",
            "text": "Once you are at the location you want to install Cora to, type:  php composer.phar create-project cora/cora  OR if you installed Composer globally as part of your PATH (which we'd recommend doing if you know how) type:  composer create-project cora/cora  That's it!  If all went well you should now have a folder named \"Cora\" in your specified directory.",
            "title": "Get Cora"
        },
        {
            "location": "/setup/install/#installation-using-git",
            "text": "Open up a Terminal window and navigate to the location where you'd like to put the Cora folder that holds the project files. \nIf you are installing to your root web directory, typically this will be named \"htdocs\" or \"public_html\". \nFor instance: if you're using a Mac and installed MAMP, you probably want to navigate to  cd /Applications/MAMP/htdocs  If you're using Windows and installed XAMPP, you likely want to go to  cd C:\\xampp\\htdocs  Once you are at the location you want to install Cora to, type:  git clone https://github.com/joebubna/Cora.git  That's it!  If all went well you should now have a folder named \"Cora\" in your specified directory.",
            "title": "Installation Using Git"
        },
        {
            "location": "/setup/install/#installation-from-zip-file",
            "text": "Go to  https://github.com/joebubna/Cora  and click the \"Download ZIP\" button on the right hand side\nof the page. Use your Finder or File Explorer in your OS and go to your web directory (probably either \"C:\\xampp\\htdocs\" if you're on Windows\nor \"/Applications/MAMP/htdocs\" if you're on a Mac). Unpack the contents of the ZIP file into this directory.  That's it!  If all went well you should now have a folder named \"Cora\" in your specified directory.",
            "title": "Installation From ZIP File"
        },
        {
            "location": "/setup/install/#configuration-to-get-it-working",
            "text": "There's a few configuration options that might need to be setup first before you can start using Cora. Click below to continue to the Configuration instructions.    Next: Configuration",
            "title": "Configuration to Get it Working"
        },
        {
            "location": "/setup/configuration/",
            "text": "Configuring Cora\n\n\nIF you installed Cora to your root web directory, it should already be working. Test by going to\n\n\nhttp://localhost/cora\n\n\n\n\nIf it loads something, then Cora is working. If it doesn't work, then you probably either need to enable .htaccess files usage in apache,\nenable mod_rewrite in apache, you changed the name of something before reaching this article, or you didn't install Cora to your root web directory.\nIf you are using one of the suggested AMP packages from the installation page, everything should theoretically be working though.\n\n\nIf you didn't install Cora into your root directory, no worries, you'll just need to run through the following config instructions first before\nthings will work.\n\n\nStep 1: Change the Name of the Directory to Match Your Project\n\n\nBy default, the folder for Cora that got copied into your web directory should be named \"cora\". Just a guess, but you probably want to change\nthis to match the name of the project you plan on building. If for instance you want to create an app called \"My Awesome Site\", go ahead and rename\nthat cora directory to \"MyAwesomeSite\".\n\n\nStep 2: Change Your .htaccess File to Match Your Directory Name\n\n\nContinuing our \"MyAwesomeSite\" example, next you would need to open up the hidden \".htaccess\" file located within that directory and change the third line\ndown to:\n\n\nRewriteBase /MyAwesomeSite\n\n\n\n\nOR, if you installed Cora into a subfolder within your web directory, then you will need to include the full path from your root like so:\n\n\nRewriteBase /someFolder/MyAwesomeSite\n\n\n\n\nPerformance Note\n \n\nWhile on this topic, it should be noted that using a .htaccess file does have a performance cost. If you are planning on making an enterprise level app\nthat serves a large number of users, you'll probably want to eventually get rid of the .htaccess file and instead place the mod_rewrite rules into your server config.\nDoing this is beyond the scope of this documentation, but it's just something of which you should be aware.\n\n\nStep 3: Update the Site_Url in Your Config\n\n\nNext you need to open up the \"cora/config/config.php\" file in your project. The full path to this file should look something similar to this:\n\n\n/htdocs/MyAwesomeSite/cora/config/config.php\n\n\n\n\nThe first thing you should see are some commented out examples of commonly changed options like:\n\n\n#$config['debug'] = true;\n#$config['debugHide'] = false;\n#$config['site_url'] = '/cora/';\n#$config['cora_extension'] = 'MyApp';\n\n\n\n\nNote that this config file overrides any defaults that are located in\n\n\n/htdocs/MyAwesomeSite/vendor/cora/cora-framework/system/config/config.php\n\n\n\n\nGo ahead and uncomment the line for 'site_url' and change the value to match your new directory name. If your project is embedded in\nsub-directories, you do not need to include the full path, just the name of the folder the Cora project files are within. Example:\n\n\n$config['site_url'] = '/MyAwesomeSite/';\n\n\n\n\nStep 4: Create Your Project Controller\n\n\nGo ahead and open up any of the example controllers that are included in the controllers directory. The class declaration should look something like:\n\n\nclass Articles extends \\MyApp {\n\n\n\n\nAnytime you create a new controller, you want to have it extend from some \"base\" controller, which in the case above is \"MyApp\". This allows you to\nhave shared data and methods across all your controllers when necessary. Although you can leave the name of this base controller as \"MyApp\" if you want to,\nwe're guessing you'll probably want to change this to something more official sounding that matches the name of your project.\n\n\nNavigate to the \"cora/extensions/MyApp.php\" file in your project and make a copy of it, renaming the copy to \"MyAwesomeSite.php\". After you do this, make sure you open\nthe file and change the class name to MyAwesomeSite too. It should look like the following:\n\n\nclass MyAwesomeSite extends Cora\n\n\n\n\nThen go back and edit the Articles controller to extend from your new base class. Note that once you complete this setup guide and confirm everything is working, you'll then be able to go back and delete the MyApp file later if you want.\n\n\nStep 5: Make All Controllers Extend From Project Controller\n\n\nNow that you have your base project controller ready, you need to open up each of the controllers under your \"controllers\" directory and change them\nto extend from your new base controller instead of MyApp. They should all follow this format:\n\n\nclass Articles extends \\MyAwesomeSite {\n\n\n\n\nStep 6: Configure Your Database\n\n\nNext you need to open up the \"cora/config/database.php\" file in your project.\nThe full path to this file should look something similar to this:\n\n\n/htdocs/MyAwesomeSite/cora/config/database.php\n\n\n\n\nWithin this file you'll find a listing of connections and a way to set the\ndefault connection. You need to edit this with the connection info for your\ndatabase(s). It follows this format:\n\n\n$dbConfig['defaultConnection'] = 'MyFavoriteConnection';\n$dbConfig['connections'] = [\n    'Connection1' => [\n        'adaptor'   => 'MySQL',\n        'host'      => 'localhost:3306',\n        'dbName'    => 'cora',\n        'dbUser'    => 'root',\n        'dbPass'    => 'root'\n    ],\n    'Connection2' => [\n        'adaptor'   => 'MySQL',\n        'host'      => 'localhost:3306',\n        'dbName'    => 'cora2',\n        'dbUser'    => 'root',\n        'dbPass'    => 'root'\n    ],\n    'MyFavoriteConnection' => [\n        'adaptor'   => 'MySQL',\n        'host'      => 'localhost:3306',\n        'dbName'    => 'cora3',\n        'dbUser'    => 'root',\n        'dbPass'    => 'root'\n    ]\n];\n\n\n\n\nIf you are using a package like XAMPP, MAMP, etc, you'll probably want to go to\n\n\nhttp://localhost/phpmyadmin\n\n\n\n\nand create a database first before you can fill in this database config. So look\ninto doing that if you haven't already.\n\n\nFinished\n\n\nThat's it! You should be able to run your project and play around with it and the included demos now.\nIf you are an experienced user who wants to know about the advanced configuration options within Cora, or how Cora can be\nincorporated into an existing software project, click \nhere\n to view the advanced configuration tutorial.\nOtherwise, click below to continue on to the introductory tutorial to help you get acquainted with Cora.\n\n\n\n\nNext: Introduction to Cora",
            "title": "Configuration"
        },
        {
            "location": "/setup/configuration/#configuring-cora",
            "text": "IF you installed Cora to your root web directory, it should already be working. Test by going to  http://localhost/cora  If it loads something, then Cora is working. If it doesn't work, then you probably either need to enable .htaccess files usage in apache,\nenable mod_rewrite in apache, you changed the name of something before reaching this article, or you didn't install Cora to your root web directory.\nIf you are using one of the suggested AMP packages from the installation page, everything should theoretically be working though.  If you didn't install Cora into your root directory, no worries, you'll just need to run through the following config instructions first before\nthings will work.",
            "title": "Configuring Cora"
        },
        {
            "location": "/setup/configuration/#step-1-change-the-name-of-the-directory-to-match-your-project",
            "text": "By default, the folder for Cora that got copied into your web directory should be named \"cora\". Just a guess, but you probably want to change\nthis to match the name of the project you plan on building. If for instance you want to create an app called \"My Awesome Site\", go ahead and rename\nthat cora directory to \"MyAwesomeSite\".",
            "title": "Step 1: Change the Name of the Directory to Match Your Project"
        },
        {
            "location": "/setup/configuration/#step-2-change-your-htaccess-file-to-match-your-directory-name",
            "text": "Continuing our \"MyAwesomeSite\" example, next you would need to open up the hidden \".htaccess\" file located within that directory and change the third line\ndown to:  RewriteBase /MyAwesomeSite  OR, if you installed Cora into a subfolder within your web directory, then you will need to include the full path from your root like so:  RewriteBase /someFolder/MyAwesomeSite  Performance Note   \nWhile on this topic, it should be noted that using a .htaccess file does have a performance cost. If you are planning on making an enterprise level app\nthat serves a large number of users, you'll probably want to eventually get rid of the .htaccess file and instead place the mod_rewrite rules into your server config.\nDoing this is beyond the scope of this documentation, but it's just something of which you should be aware.",
            "title": "Step 2: Change Your .htaccess File to Match Your Directory Name"
        },
        {
            "location": "/setup/configuration/#step-3-update-the-site_url-in-your-config",
            "text": "Next you need to open up the \"cora/config/config.php\" file in your project. The full path to this file should look something similar to this:  /htdocs/MyAwesomeSite/cora/config/config.php  The first thing you should see are some commented out examples of commonly changed options like:  #$config['debug'] = true;\n#$config['debugHide'] = false;\n#$config['site_url'] = '/cora/';\n#$config['cora_extension'] = 'MyApp';  Note that this config file overrides any defaults that are located in  /htdocs/MyAwesomeSite/vendor/cora/cora-framework/system/config/config.php  Go ahead and uncomment the line for 'site_url' and change the value to match your new directory name. If your project is embedded in\nsub-directories, you do not need to include the full path, just the name of the folder the Cora project files are within. Example:  $config['site_url'] = '/MyAwesomeSite/';",
            "title": "Step 3: Update the Site_Url in Your Config"
        },
        {
            "location": "/setup/configuration/#step-4-create-your-project-controller",
            "text": "Go ahead and open up any of the example controllers that are included in the controllers directory. The class declaration should look something like:  class Articles extends \\MyApp {  Anytime you create a new controller, you want to have it extend from some \"base\" controller, which in the case above is \"MyApp\". This allows you to\nhave shared data and methods across all your controllers when necessary. Although you can leave the name of this base controller as \"MyApp\" if you want to,\nwe're guessing you'll probably want to change this to something more official sounding that matches the name of your project.  Navigate to the \"cora/extensions/MyApp.php\" file in your project and make a copy of it, renaming the copy to \"MyAwesomeSite.php\". After you do this, make sure you open\nthe file and change the class name to MyAwesomeSite too. It should look like the following:  class MyAwesomeSite extends Cora  Then go back and edit the Articles controller to extend from your new base class. Note that once you complete this setup guide and confirm everything is working, you'll then be able to go back and delete the MyApp file later if you want.",
            "title": "Step 4: Create Your Project Controller"
        },
        {
            "location": "/setup/configuration/#step-5-make-all-controllers-extend-from-project-controller",
            "text": "Now that you have your base project controller ready, you need to open up each of the controllers under your \"controllers\" directory and change them\nto extend from your new base controller instead of MyApp. They should all follow this format:  class Articles extends \\MyAwesomeSite {",
            "title": "Step 5: Make All Controllers Extend From Project Controller"
        },
        {
            "location": "/setup/configuration/#step-6-configure-your-database",
            "text": "Next you need to open up the \"cora/config/database.php\" file in your project.\nThe full path to this file should look something similar to this:  /htdocs/MyAwesomeSite/cora/config/database.php  Within this file you'll find a listing of connections and a way to set the\ndefault connection. You need to edit this with the connection info for your\ndatabase(s). It follows this format:  $dbConfig['defaultConnection'] = 'MyFavoriteConnection';\n$dbConfig['connections'] = [\n    'Connection1' => [\n        'adaptor'   => 'MySQL',\n        'host'      => 'localhost:3306',\n        'dbName'    => 'cora',\n        'dbUser'    => 'root',\n        'dbPass'    => 'root'\n    ],\n    'Connection2' => [\n        'adaptor'   => 'MySQL',\n        'host'      => 'localhost:3306',\n        'dbName'    => 'cora2',\n        'dbUser'    => 'root',\n        'dbPass'    => 'root'\n    ],\n    'MyFavoriteConnection' => [\n        'adaptor'   => 'MySQL',\n        'host'      => 'localhost:3306',\n        'dbName'    => 'cora3',\n        'dbUser'    => 'root',\n        'dbPass'    => 'root'\n    ]\n];  If you are using a package like XAMPP, MAMP, etc, you'll probably want to go to  http://localhost/phpmyadmin  and create a database first before you can fill in this database config. So look\ninto doing that if you haven't already.",
            "title": "Step 6: Configure Your Database"
        },
        {
            "location": "/setup/configuration/#finished",
            "text": "That's it! You should be able to run your project and play around with it and the included demos now.\nIf you are an experienced user who wants to know about the advanced configuration options within Cora, or how Cora can be\nincorporated into an existing software project, click  here  to view the advanced configuration tutorial.\nOtherwise, click below to continue on to the introductory tutorial to help you get acquainted with Cora.   Next: Introduction to Cora",
            "title": "Finished"
        },
        {
            "location": "/setup/advanced/",
            "text": "Advanced Config Options\n\n\nDebugging\n\n\n$config['debug'] = false;\n$config['debugHide'] = false;\n\n\n\n\nThese options are for helping you problem solve if the router doesn't seem to be finding your\ncontroller. The \"hide\" option just makes the routing messages show up in the HTML comments.\n\n\nCase-Sensitivity\n\n\n$config['lowercase_url'] = true;\n\n\n\n\nBy default Cora converts URLs into lowercase so that you can have consistent behavior on case-sensitive servers (e.g. Linux systems) regardless of whether\nor not a user types capital letters into the URL. However, if you wanted your URLs to be case-sensitive, you can disable this option in the config.\n\n\nDefault Controller\n\n\n$config['default_controller'] = 'Home';\n\n\n\n\nIf a user just goes to your homepage 'www.mysite.com`, what controller should this request\nbe routed to? You can set that here.\n\n\nRESTful Routing\n\n\n$config['enable_RESTful'] = true;\n\n\n\n\nWe'd recommend against it, but if you want to turn off RESTful routing in Cora, you may do so.\nTo learn more about how routing works within Cora, see \nHERE\n.\n\n\nFile Paths\n\n\n$config['basedir'] = dirname(__FILE__).'/../../../../../';\n\n/**\n *  Path to models/classes directory relative to this file.\n */\n$config['pathToModels'] = $config['basedir'].'classes/';\n\n/**\n *  Path to views directory relative to this file.\n */\n$config['pathToViews'] = $config['basedir'].'views/';\n\n/**\n *  Path to controllers directory relative to this file.\n */\n$config['pathToControllers'] = $config['basedir'].'controllers/';\n\n/**\n *  Path to libraries directory relative to this file.\n */\n$config['pathToLibraries'] = $config['basedir'].'libraries/';\n\n/**\n *  Path to events directory relative to this file.\n */\n$config['pathToEvents'] = $config['basedir'].'events/';\n\n/**\n *  Path to listeners directory relative to this file.\n */\n$config['pathToListeners'] = $config['basedir'].'listeners/';\n\n/**\n *  Path to App's Cora directory relative to this file.\n */\n$config['pathToCora'] = $config['basedir'].'cora/';\n\n\n\n\nBy default all these folders are set to be in your project's root - on the same level as the 'vendor' directory.\nHowever, you can obviously change this however you want. Another thing to take special notice of is that the\nfolder names themselves are defined here and can be changed. This might come in useful if you are integrating Cora\ninto an existing software project that already has its class files located in a specific directory somewhere.\n\n\nFile Naming Conventions\n\n\n/**\n *  Model/Class file prefix. I.e. If your class files are named \"class.MyClass.inc.php\"\n *  then enter 'class.' for Prefix and '.inc' for postfix.\n */\n$config['modelsPrefix'] = 'class.';\n$config['modelsPostfix'] = '';\n\n/**\n *  View file prefix / postfix.\n */\n$config['viewsPrefix'] = 'view.';\n$config['viewsPostfix'] = '';\n\n/**\n *  Controller file prefix / postfix.\n */\n$config['controllersPrefix'] = 'controller.';\n$config['controllersPostfix'] = '';\n\n/**\n *  Library file prefix / postfix.\n */\n$config['librariesPrefix'] = '';\n$config['librariesPostfix'] = '';\n\n/**\n *  Event file prefix / postfix.\n */\n$config['eventsPrefix'] = 'event.';\n$config['eventsPostfix'] = '';\n\n/**\n *  Listener file prefix / postfix.\n */\n$config['listenerPrefix'] = 'listen.';\n$config['listenerPostfix'] = '';\n\n\n\n\nHere you can set optional prefix and postfix naming conventions for your files. For instance, if your views\nare named \"view.someView.php\", you tell Cora about that \"view.\" prefix here and then you don't have to worry about the prefix or postfix\nin your controllers. For example: you would be able to load the above view by\n\n\n$this->load->view('someView');",
            "title": "Advanced Configuration"
        },
        {
            "location": "/setup/advanced/#advanced-config-options",
            "text": "",
            "title": "Advanced Config Options"
        },
        {
            "location": "/setup/advanced/#debugging",
            "text": "$config['debug'] = false;\n$config['debugHide'] = false;  These options are for helping you problem solve if the router doesn't seem to be finding your\ncontroller. The \"hide\" option just makes the routing messages show up in the HTML comments.",
            "title": "Debugging"
        },
        {
            "location": "/setup/advanced/#case-sensitivity",
            "text": "$config['lowercase_url'] = true;  By default Cora converts URLs into lowercase so that you can have consistent behavior on case-sensitive servers (e.g. Linux systems) regardless of whether\nor not a user types capital letters into the URL. However, if you wanted your URLs to be case-sensitive, you can disable this option in the config.",
            "title": "Case-Sensitivity"
        },
        {
            "location": "/setup/advanced/#default-controller",
            "text": "$config['default_controller'] = 'Home';  If a user just goes to your homepage 'www.mysite.com`, what controller should this request\nbe routed to? You can set that here.",
            "title": "Default Controller"
        },
        {
            "location": "/setup/advanced/#restful-routing",
            "text": "$config['enable_RESTful'] = true;  We'd recommend against it, but if you want to turn off RESTful routing in Cora, you may do so.\nTo learn more about how routing works within Cora, see  HERE .",
            "title": "RESTful Routing"
        },
        {
            "location": "/setup/advanced/#file-paths",
            "text": "$config['basedir'] = dirname(__FILE__).'/../../../../../';\n\n/**\n *  Path to models/classes directory relative to this file.\n */\n$config['pathToModels'] = $config['basedir'].'classes/';\n\n/**\n *  Path to views directory relative to this file.\n */\n$config['pathToViews'] = $config['basedir'].'views/';\n\n/**\n *  Path to controllers directory relative to this file.\n */\n$config['pathToControllers'] = $config['basedir'].'controllers/';\n\n/**\n *  Path to libraries directory relative to this file.\n */\n$config['pathToLibraries'] = $config['basedir'].'libraries/';\n\n/**\n *  Path to events directory relative to this file.\n */\n$config['pathToEvents'] = $config['basedir'].'events/';\n\n/**\n *  Path to listeners directory relative to this file.\n */\n$config['pathToListeners'] = $config['basedir'].'listeners/';\n\n/**\n *  Path to App's Cora directory relative to this file.\n */\n$config['pathToCora'] = $config['basedir'].'cora/';  By default all these folders are set to be in your project's root - on the same level as the 'vendor' directory.\nHowever, you can obviously change this however you want. Another thing to take special notice of is that the\nfolder names themselves are defined here and can be changed. This might come in useful if you are integrating Cora\ninto an existing software project that already has its class files located in a specific directory somewhere.",
            "title": "File Paths"
        },
        {
            "location": "/setup/advanced/#file-naming-conventions",
            "text": "/**\n *  Model/Class file prefix. I.e. If your class files are named \"class.MyClass.inc.php\"\n *  then enter 'class.' for Prefix and '.inc' for postfix.\n */\n$config['modelsPrefix'] = 'class.';\n$config['modelsPostfix'] = '';\n\n/**\n *  View file prefix / postfix.\n */\n$config['viewsPrefix'] = 'view.';\n$config['viewsPostfix'] = '';\n\n/**\n *  Controller file prefix / postfix.\n */\n$config['controllersPrefix'] = 'controller.';\n$config['controllersPostfix'] = '';\n\n/**\n *  Library file prefix / postfix.\n */\n$config['librariesPrefix'] = '';\n$config['librariesPostfix'] = '';\n\n/**\n *  Event file prefix / postfix.\n */\n$config['eventsPrefix'] = 'event.';\n$config['eventsPostfix'] = '';\n\n/**\n *  Listener file prefix / postfix.\n */\n$config['listenerPrefix'] = 'listen.';\n$config['listenerPostfix'] = '';  Here you can set optional prefix and postfix naming conventions for your files. For instance, if your views\nare named \"view.someView.php\", you tell Cora about that \"view.\" prefix here and then you don't have to worry about the prefix or postfix\nin your controllers. For example: you would be able to load the above view by  $this->load->view('someView');",
            "title": "File Naming Conventions"
        },
        {
            "location": "/tutorials/intro/",
            "text": "Intro\n\n\nThis page is not written yet! In the meantime, please play around in the demo project and refer to the articles under the \"Documentation\" tab for documentation on specific classes.\n\n\nAnother good resource at this point is to view a presentation I made on Cora which has explanations of how the routing works and displaying data. That presentation can be found here: \nCora Presentation on Google Docs.",
            "title": "Intro to Cora"
        },
        {
            "location": "/tutorials/intro/#intro",
            "text": "This page is not written yet! In the meantime, please play around in the demo project and refer to the articles under the \"Documentation\" tab for documentation on specific classes.  Another good resource at this point is to view a presentation I made on Cora which has explanations of how the routing works and displaying data. That presentation can be found here:  Cora Presentation on Google Docs.",
            "title": "Intro"
        },
        {
            "location": "/tutorials/composer/",
            "text": "Using Composer with Cora\n\n\nTest",
            "title": "Using Composer"
        },
        {
            "location": "/tutorials/composer/#using-composer-with-cora",
            "text": "Test",
            "title": "Using Composer with Cora"
        },
        {
            "location": "/documentation/mvc/overview/",
            "text": "",
            "title": "MVC Pattern"
        },
        {
            "location": "/documentation/routing/overview/",
            "text": "",
            "title": "Routing"
        },
        {
            "location": "/documentation/amblend/overview/",
            "text": "What is AmBlend?\n\n\nTL;DR It makes grabbing objects from and saving objects to a database super easy.\n\n\nIn short, AmBlend is the ORM tool developed for, and included with Cora.\nAn ORM (Object Relational Mapping) tool is something that handles moving data to and\nfrom objects and the database. This is useful when doing OO (object oriented) programming\nas it allows developers to focus on the core functionality and features of their application\nand not on the nitty-gritty grunt work of how to fetch and persist (aka 'save') data. This generally results\nin less code that needs to be written, and faster development times.\n\n\nAs an added bonus, using AmBlend allows Cora to build your database for you automatically\nbased on the definitions of your models, if you so desire.\n\n\nHow Does AmBlend Differ From Other ORMs?\n\n\nORM implementations basically boil down into two basic types: Active-Record or Data-Mapper.\nBoth have their pros and cons, but AmBlend was designed as a \"blend\" of both approaches ('AM'\nshort for Active-record and data-Mapper) with the goal of taking the best aspects of each and blending them\ninto a new paradigm. Below are the stereotypical strengths and weaknesses of each approach compared to AmBlend:\n\n\n\n  \n\n    \nProperty:\n\n    \nActive-Record\n\n    \nData-Mapper\n\n    \nAmBlend\n\n  \n\n  \n\n    \nEasy to Setup\n\n    \nYes\n\n    \nNo\n\n    \nYes\n\n  \n\n  \n\n    \nEasy to Use\n\n    \nYes\n\n    \nNo\n\n    \nYes\n\n  \n\n  \n\n    \nEasy to Test\n\n    \nNo\n\n    \nYes\n\n    \nYes\n\n  \n\n  \n\n  \nSRP\n Compliant\n\n    \nNo\n\n    \nYes\n\n    \nYes\n\n  \n\n  \n\n    \nDomain and Database Separation\n\n    \nNo\n\n    \nYes\n\n    \nYes\n\n  \n\n  \n\n    \nPerformance Optimization\n\n    \nDepends\n\n    \nDepends\n\n    \nYes*\n\n  \n\n\n\n\n\n*\n As much as possible, flexibility and optimization were kept in mind when building AmBlend. An explanation of the specific optimizations\nin place can be found in the optimizations section.\n\n\nFor more information about how AmBlend is implemented, see AmBlend's \"Implementation\" page.\n\n\nHow-to-Use Basics\n\n\nFirst you need to have your models extend from Cora's Model class, and add an associative array\nwhich defines the attributes of that model. See below for an example User model\nwhich has an ID, a couple strings in Name and Email, and a Job attribute which\nis another model representing the job of this user.\n\n\n\n\nDefine some Cora models:\n\n\nclass User extends \\Cora\\Model {\n\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar'\n        ],\n        'job' => [\n            'model' => 'job'\n        ]\n    ];\n\n    public function __construct($name = null, $email = null)\n    {\n        $this->name = $name;\n        $this->email = $email;\n    }\n}\n\nclass Job extends \\Cora\\Model {\n\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'title' => [\n            'type' => 'varchar'\n        ],\n        'description' => [\n            'type' => 'varchar'\n        ]\n    ];\n\n    public function __construct($title = null, $description = null)\n    {\n        $this->title = $title;\n        $this->description = $description;\n    }\n}\n\n\n\n\nNotice you didn't have to use any special comments with @ symbols or anything else;\nyou inform Cora about what your model's attributes are using a normal array.\nFurthermore, there's nothing special about the constructors (you can write them\njust like you would any other class), AND there's nothing special about the\nproperties of a model either. If you want to add additional normal properties\nto the model that's all\nperfectly fine. All that's important to know is that unless a property is defined\nin the \"model_attributes\" array, AmBlend won't try to save it to a database.\nTo say that another way, you can add whatever properties you want\nto a model, AmBlend will just ignore them unless you also add that property to the\nmodel_attributes array. In that sense, you can use and create Cora models just\nlike you would any normal class. The only thing you need to be careful of is to not override\nthe _ \n get() and _ \n set() methods.\n\n\nNext you need to create your database(s).\n\n\n\n\nCreate Your Database:\n\n\nThe easiest way to create your database is to use AmBlend's automated database\ncreation tool! In order to take advantage of this feature, you need to make sure\nyou've setup your database configuration. If you haven't done that yet,\n\nClick Here\n to view\ninstructions on doing so. The other thing you'll need (as of me writing this),\nis command line access. In the future, an in-browser\nvisual interface to the database creation tool may be added, but for now it's just\na command line tool.\n\n\n\n\n\nIf on a shared hosting environment:\n  \n\nBecause the database creation feature is a command line tool...\nwhat this means for people who will be hosting their app in\na shared hosting environment without command line access is that you'll need to\ngenerate your database on your local machine and then use a tool (such as PhpMyAdmin)\nto export your generated database into an SQL file you can upload.\n\n\n\n\nTo automatically generate a database based on your model definitions you need\nto do the following:\n\n\n\n\nOpen a Terminal.\n\n\nIf on a Mac, open your Applications, click the Utilities folder, and then\nselect the \"Terminal\" application.\n\n\nIf on a PC, hit your Windows Key + R to open the \"Run\" window, then type\nin \"cmd\" and hit enter.\n\n\nIf on Linux you don't need me to tell you how to do this, but since I can't\nhelp myself I'll mention that Ubuntu and Mint both map the terminal to\nCtrl+Alt+T.\n\n\n\n\n\n\nNavigate to your project's directory.\n\n\nIf you are XAMPP, MAMP, etc, that will likely be wherever you installed\nthat and then in the \"htdocs\" folder within.\n\n\n\n\n\n\nOnce at the root of your project, type \"php Amblend.php dbBuild\" to have\nAmBlend build your database for you.\n\n\nIf you get an error about PHP not being a recognized command, that means\nPHP is not a part of your operating system's PATH. Google \"add php to path\"\nor something similar if you aren't sure how to do this.\n\n\n\n\n\n\n\n\nIf all went well, you should see a flurry of output to the console and your database\nshould be ready to go!\n\n\nOf course, if you want to read through the documentation\nin the Models page to fully understand how the mappings work for the purpose of\nsetting your database(s) up manually, you can, although that takes more expertise\nand effort.\n\n\n\n\nStart Using AmBlend:\n\n\nAnd ... wait for it ... congratulations! You're now ready to start using AmBlend.\nSo we're all good to go, but how do we actually fetch models from and save models\nto the database? The answer is we need to use a Repository.\nSee below for an example Users controller where we use AmBlend to interact with\nour database. This Users controller will be very simple, we'll just have a method\nfor registering a new user, and an ultra simple Profile method that just echoes\nout the user's job title.\n\n\nUsing AmBlend in a Controller:\n\n\nclass Users extends \\MyApp\n{\n    protected $repo;\n    protected $db;\n\n    public function __construct()\n    {\n        parent::__construct();\n        $this->repo = \\Cora\\RepositoryFactory::make('User');\n    }\n\n    /**\n     *  Create a new user.\n     */\n    public function register()\n    {\n        // Grab our inputs. We'll just use fake data instead of\n        // actually capturing it from a form.\n        $name = 'Bob';                // $this->input->post('name');\n        $email = 'Bob@fakeEmail.com'; // $this->input->post('email');\n\n        // Create a new User.\n        $user = new User($name, $email);\n\n        // Assign the user a job.\n        $user->job = new Job('Athlete', 'Track and Field');\n\n        // Save the user to the database.\n        $this->repo->save($user);\n\n        // When the user was saved to the database, AmBlend\n        // assigned the object the unique ID the database provided it.\n        // Let's echo this user's ID.\n        echo $user->id;\n    }\n\n    /**\n     *  Display a user's profile.\n     *  In this case, just echo their job title.\n     */\n    public function profile($id)\n    {\n        $user = $this->repo->find($id);\n        echo $user->job->title;\n    }\n}\n\n\n\n\nIf you have the Cora demo project installed, you can run this code and see it\nworking in action. First you'll want to go to:\n\n\nhttp://localhost/{myProjectName}/users/register\n\n\n\n\n^ Replace \"{myProjectName}\" with the name of the folder your Cora demo project\nis in. This should create our user \"Bob\" and then echo out to the browser\nthe ID number assigned to him. If you use that ID, you can then go to the profile\npage at:\n\n\nhttp://localhost/{myProjectName}/users/profile/{id}\n\n\n\n\n^ Where {id} is the ID of Bob. If Bob's ID is \"2\":\n\n\nhttp://localhost/{myProjectName}/users/profile/2\n\n\n\n\nAnd just like that, AmBlend saved our user Bob to the database as represented\nby the User object, saved a separate Job object to the database that represents\nthe job Bob does, and automatically handled setting up the associations for you\nbetween the objects. This is why you can do:\n\n\necho $user->job->title;\n\n\n\n\non the profile page and have it work so effortlessly. Behind-the-scenes\nAmBlend is doing all the heavy-lifting busy work for you to make saving and\nretrieving objects along with any other objects associated with them a breeze.\n\n\n\n\nExplanation Pitstop:\n \n\nSo the one thing I didn't talk about in the code above is what's happening\nin the constructor for our Users controller where we are creating our Repository object.\n\n\nIn programming lingo a \"factory\" is a class that handles creating objects for you.\nThe easiest way to get a Repository of a certain type is to use Cora's RepositoryFactory\nclass' Make method and telling it what type of repository you want to create.\nSo the code as seen below is just the simplest way of creating a User class repository:\n\n\n$this->repo = \\Cora\\RepositoryFactory::make('User');\n\n\n\n\nFor more information about the Repository, Gateway, Factory pattern I recommend\nreading the documentation page for each under the AmBlend ORM section.\n\n\n\n\nOptimizing Performance\n\n\nOk, now that's we've seen the bare basics of how AmBlend works, let's talk for a minute\nabout how it tries to make your app lean and fast. In general, ORMs get a bad rap\nfor being inefficient, and rightfully so. I've read the horror stories of engineers\ncalled in to speed up programs only to find out the ORM used by the program is spitting\nout super ugly and inefficient queries that are like trying to kill a fly with a\nheavy machine gun! In terms of AmBlend, my goal here is to describe\nexactly how it works so you can make your own judgements about when or when not to use it.\n\n\n\"Light\" Classes:\n\n\nFirst up, when grabbing data from a row in the database for the purpose of populating\nan object, by default, AmBlend will grab all the data in that row. That is to say:\n\n\n$user = $this->repo->find($id);\n\n\n\n\nIs the SQL equivalent to doing:\n\n\nSELECT * FROM users WHERE id = :id\n\n\n\n\nOne of the optimizations in AmBlend is the ability to dynamically create \"light\"\nversions of a class by not grabbing all the class data, and instead only grabbing\nthe data you need. This is possible because AmBlend uses Cora's Database class\nto interact with the persistence layer, and allows you to pass a partial query\nalong to the repository when asking for models. See below for example. You can\nadd the following method to the Users controller we previously used to see this in\naction:\n\n\npublic function lightClassDemo($id)\n{\n    $this->db->where('id', $id);\n    $this->db->select(['id', 'name']);\n    $user = $this->repo->findOne($this->db);  \n    var_dump($user);\n}\n\n\n\n\nIs equivalent to doing:\n\n\nSELECT id, name FROM users WHERE id = :id\n\n\n\n\nWhat we're leaving out here is the user's email and their job, maybe because whatever we're\ndoing with the object doesn't require that info. It's a general rule when optimizing\nperformance to only grab what you need, and with this functionality, AmBlend\ngives you that capability.\n\n\n(Note that you can use findAll() to similarly fetch\na collection of \"light\" objects.)\n\n\nCollection Subsets:\n\n\nAlright, say you want to print out a list of users, but you don't want to list all\nusers, just the ones that are Admins. Using the same methodology we\nused in the previous section to create a \"light\" version of a class, we can also\nlimit the objects we are grabbing to a subset of a whole collection. (Note: this\nexample assumes there's some sort of \"type\" attribute on the user model):\n\n\npublic function subsetDemo()\n{\n    $this->db->where('type', 'Admin');\n    $users = $this->repo->findAll($this->db);\n\n    foreach ($users as $user) {\n        echo $user->name.'<br>';\n    }\n}\n\n\n\n\nThis is yet another example of how AmBlend let's you only fetch the data you need,\nso you aren't wasting system resources.\n\n\nDynamic Loading\n\n\nAKA - How related objects are fetched:\n\n\nAlright, now that we've talked about how data on the class' main table can be limited\n(\"light\" classes) and how repositories can be asked to return only a subset of\nobjects in a collection... let's continue our discussion of performance by going\nover HOW AmBlend grabs related objects.\n\n\nBy \"related objects\" what I'm referring to is say the Job object associated with\na user from one of our previous examples on this page. Another example would be\nif you were creating a blogging site and each user had a collection of \"articles\"\nthey've written where each article is its own object. If you are an experienced\ndeveloper who's concerned about performance, how AmBlend grabs these related objects\nfrom a database is something you should know.\n\n\nThe answer to that question is that AmBlend only grabs related objects \"on-demand\"\nutilizing what I call Dynamic Loading. The way in which this is done varies a little\nbit depending on how the data is stored, but all follows the same concept.\nGoing back to the \"User has a Job\" example, the way we defined the Job attribute\non our User model as a simple, single related object means that our Users table\nwill have a \"job\" column that stores the ID of that user's job.\n\n\n\n\nIn the case of Bob as seen in the image of his Users table entry above, grabbing\nhis whole user object and doing a var_dump as seen in this code:\n\n\npublic function profile($id)\n{\n    $user = $this->repo->find($id);\n    var_dump($user);\n}\n\n\n\n\nHas the following applicable output:\n\n\nprotected 'model_data' =>\n    array (size=5)\n      'name' => string 'bob' (length=3)\n      'type' => string 'admin' (length=5)\n      'id' => string '1' (length=1)\n      'email' => string 'bob@fakeEmail.com' (length=17)\n      'job' => string '3' (length=1)\n\n\n\n\nAs you can see, the \"job\" attribute is NOT an object at this point, it's just\nan ID number that references a job object. However, through the power of AmBlend's\ndynamic loading, if you try and access Bob's job property, it will be fetched\nfrom the persistence layer and an object will replace the ID. To see this in\naction, let's echo out Bob's job title, and then do a var_dump afterwards to see\nthe difference:\n\n\npublic function profile($id)\n{\n    $user = $this->repo->find($id);\n    echo $user->job->title;\n    var_dump($user);\n}\n\n\n\n\nAnd the result of the var_dump now looks like:\n\n\nprotected 'model_data' =>\n    array (size=5)\n      'name' => string 'bob' (length=3)\n      'type' => string 'admin' (length=5)\n      'id' => string '1' (length=1)\n      'email' => string 'bob@fakeEmail.com' (length=17)\n      'job' =>\n        object(Job)[11]\n          public 'model_attributes' =>\n            array (size=3)\n              ...\n          protected 'model_data' =>\n            array (size=3)\n              ...\n\n\n\n\nAs you can see, the \"job\" attribute is no longer just an ID, it's been replaced\nby a full Job object!\n\n\n\n\nFor object collections or single objects that use a relation table:\n\n\nThis works similarly, but slightly different for related objects that use a\nrelation table or an \"owner\" type column on the related object's table. If Bob's\nUser table entry looked like this:\n\n\n\n\n(Notice the lack of a \"job\" column)\n\n\nAnd Jobs were getting related to Users by utilizing a separate relation table,\nthen the var_dump on User would look like this:\n\n\nprotected 'model_data' =>\n    array (size=5)\n      'name' => string 'bob' (length=3)\n      'type' => string 'admin' (length=5)\n      'id' => string '1' (length=1)\n      'email' => string 'bob@fakeEmail.com' (length=17)\n      'job' => int 1\n\n\n\n\nIn this scenario, the \"job\" attribute is NOT the ID of the related job object,\nbut rather just a boolean placeholder to let AmBlend's Dynamic Loading system know that\na related job exists, and that if Job is called for, it needs to use the reference\ntable to go fetch it!\n\n\nThis is obviously a slight difference, but one that could trip you up if you\ndon't realize how it's working.\n\n\n\n\nPerformance considerations of dynamic loading:\n\n\n\n    WARNING: So the info I'm about to talk about below is intended for experienced\n    enterprise-level developers! It's very \"nitty-gritty\", so don't say I didn't\n    warn you. If you get lost, don't worry, just skip this section.\n\n\n\n\nAlright, now that you should have an understanding of how AmBlend grabs related\nobjects (\"on-demand\" using dynamic loading), you can weigh the performance cost.\nOn one hand, the fact that AmBlend grabs only as little data as possible and grabs\nextra stuff as needed helps keep your objects lean. However, because a separate\nquery is run each time you need to fetch a related object, this has the potential\nto bombard your database with hundreds or even thousands of small queries for\nindividual objects. For example, let's pretend we have 1,000 users in our\nusers table and we execute the following code on a Users repository:\n\n\n// Fetches ALL users\n$users = $this->repo->findAll();\n\nforeach ($users as $user) {\n    echo $user->job->title;\n}\n\n\n\n\nThe loop will run 1,000 times, and since each Job will be fetched\nindividually using a separate query at the time it tries to get accessed, it will\nresult in the equivalent of 1,000 of these queries:\n\n\nSELECT * FROM jobs WHERE `id` = :id\n\n\n\n\nI'm not a database mega-expert, but I'm sure that doing\n1,000 small queries is less efficient than if you just did one larger query to\ngrab all the data you needed in one go. Maybe if you consider the fact that you'd\nthen have to loop through the results of the larger query to assign each row of\ndata to an object it might come out as a wash, but that's for you to decide and\nnot me. The point I want to communicate is that this is how it works when you\ntry and access related objects to whatever the primary object you're using is.\n\n\nIf you wanted to grab all the Jobs from the database and have AmBlend return\nthem for you as objects, but you DON'T want to go through that process of executing\n1,000 individual queries... you have a few options:\n\n\n\n\nAvoiding Lots of Mini-Queries - Option #0:\n\n\n(Yes, I did just call this option zero. On purpose.)\n\n\nThe fact of the matter is, looping through 1,000 users and accessing information\nabout each, is not a typical usage example. If you're building an object oriented\nreporting system, I could see this being the case, but in 95% of situations you're\nprobably iterating over a small collection. If you are making some sort of users\nlist, chances are you'll be using a pagination setup, and so you probably only\nneed to loop over a few dozen users at a time.\n\n\nIf you're building say a Forum post system, again you're probably only iterating\nover a few dozen users, and using a pagination system again if things get too long.\n\n\nIn my experience exploring things such as string matching algorithms,\nwhen dealing with small data sets, a simple brute-force solution\nusually performs as well or better than a fancy more eloquent one due to the\noverhead cost of setting up fancy solutions.\n\n\nSo if you're concerned about performance, do a little testing. You might find\nthe simplest option may be the best option.\n\n\n\n\nAvoiding Lots of Mini-Queries - Option #1:\n\n\nYou can just create a Jobs repository and ask for all the jobs. This will execute\na single query to fetch a collection of all the Jobs. The downside here is that\nunless you create a backwords reference from a Job to a User (our example from earlier on\nthis page didn't have one), you won't know what User(s) that Job is associated with.\nAlso worth noting, if you end up adding a backreference and using it, you might\nend up in the same individual queries situation.\n\n\nBut depending on what you're doing, just grabbing all the jobs this way and then\nmaybe doing some mapping between the collection of Jobs and the collection of Users\n(if necessary for the task) could be an option.\n\n\n\n\nAvoiding Lots of Mini-Queries - Option #2:\n\n\nIf you don't need the full related object, but just a piece of information from it,\nyou can add a join to the Repository query. For instance, let's say you don't need\nthe full Job object, but just need a user's job title. You can do the following:\n\n\npublic function joinDemo($id)\n{\n    $this->db->where('users.id', $id)\n             ->select(['users.id', 'users.name', 'jobs.title as job_title'])\n             ->join('ref_users_jobs', [['users.id', '=', 'ref_users_jobs.user']])\n             ->join('jobs', [['ref_users_jobs.job', '=', 'jobs.id']]);\n    $user = $this->repo->findOne($this->db);  \n    echo $user->job_title;\n}\n\n\n\n\n(NOTE: the above example is taken directly from the Cora demo project and Jobs are related\n    to Users via a relation table - which is different from our previous example on\n    this page where a Job ID was stored directly in the Users table)\n\n\nLooking at the select() method above, in addition to grabbing the user's ID and\nname, we are also doing some joins and then grabbing the user's job title.\nSince \"job_title\" is NOT defined in the User class attributes definition, AmBlend\nwill pass it into the object as a property, but it will not do anything further.\nWhat this means is that if you alter the title and then tell AmBlend to save\nthis user, the job title will NOT get saved since it's not technically part of the class\ndefinition. The job title is just merely extra data you asked AmBlend to grab, which it did.\n\n\nThis can be useful if you just need some simple read-only data about a user though!\nAs you can see in the code snippet above we were able to\necho out the title. I'm sure if you're an experienced developer and reading this\nyou can see how this could be useful as long as you're careful about when/how you\nuse it. It's just important to keep in mind that any object properties not defined\nin the model_attributes array are ignored when an object is saved.\n\n\nIt's also worth noting here that a (probably more convenient) way of doing the same\nthing is to utilize a model's lifecycle hooks to run some custom queries when a\nmodel is fetched or saved! By doing so you can fetch the extra data anytime you\nwould normally fetch an instance of the model, and you can save the extra data\nwhenever you tell a repository to save it. See the LifeCycle Hooks section for\nmore information.\n\n\n\n\nAvoiding Lots of Mini-Queries -  Option #3:\n\n\nYou can pass a custom built Gateway to a Repository that does whatever queries you\nwant and manipulates data in whatever way you want. AmBlend is great because it\nhandles the generic day-to-day fetching and persisting of objects for you, which is\nreally nice, BUT that doesn't mean you can't override its default behavior if you need\nto handle more complicated tasks. See the section below on how you can modify or\nreplace the default Gateway (the class in charge of fetching data from the persistence layer)\nwith a custom one of your own making.\n\n\nLimiting Resource Creation\n\n\nAnother optimization made in AmBlend is statically declared data when possible.\nSpecifically, since most apps are likely created using a single\ndatabase, the default database adaptor is stored statically. What this means is\nthat each time you trigger something like Dynamic Loading on an object that uses\nthe app's default database, AmBlend isn't creating a new database object each time,\nbut rather using the statically stored version if it exists. This means less\nwork to get setup.\n\n\nIt's a small thing, but every little improvement helps in the long run.\n\n\nOverriding Default Behavior\n\n\nSo one of the criticisms of the ActiveRecord pattern is it ties an object too\nclosely to a single table, and doesn't give the flexibility in how an object\nis fetched and saved that a developer might want. In most cases, this really isn't a problem (ActiveRecord\nis the most popular ORM pattern in use as of this writing to my knowledge after all).\nIn addition, as you've probably noticed if you've read this far down the page,\ngrabbing related objects from various different tables is an absolute BREEZE using\nAmBlend! However, there still may be situations that come up where a developer\nfeels the need for advanced models that are composed of direct data from multiple\ntables (\"direct data\" meaning numbers, strings, dates, etc).\n\n\nThe first thing I would caution a developer if they feel like they need to do this\nis to sleep on it, and re-examine what they're trying to accomplish. Does your\nobject REALLY need its data grabbed from multiple tables/sources? Can the data you\nwant to grab from a 2nd table be grabbed from a related object, rather than shoving it\ninto your current one? What about just doing a good old fashioned direct query\nusing Cora's database class? There are lifecycle hooks you can use when fetching\nor saving a model to run your custom query for fetching/saving this extra data.\nThe point I'm trying to make is that the option I'm going to share below,\nyou probably don't ever need to use... but I'll share it anyway because\nknowledge is power... or something like that.\n\n\nWriting Your Own Gateway:\n\n\nAlright, I'm not actually going to go into too much depth on this, as if you're\na developer who feels the need to write your own Gateway for fetching/persisting\nan object, you probably are pretty competent in your knowledge and skills. Instead\nI'll just gloss over the high-level process of doing this in Cora to save you\ntime having to dig as much into the code.\n\n\nThe steps I would take are as follows:\n\n\n\n\nEither extend Cora's Gateway class and override whatever method(s) you want,\n or copy+paste the existing class into a new file, delete the contents of the methods,\n and save it as whatever you want (something like \"UserGateway\" would make sense for\n a User class). Obviously don't forget to implement the methods with your own code.\n\n\nNow that you have your fancy custom Gateway ready to go, you just need to pass\n it into a Repository in place of the default one included in Cora. The way to\n go about doing this is to NOT use the RepositoryFactory like we've been using in\n our examples, and instead just go through the simple process of initializing a\n Repository for yourself like so:\n\n\n\n\n// Create the Factory and Gateway the repository will use.\n$factory = new Factory($class);\n$gateway = new UserGateway(...insert your parameters...);\n\n// Pass a gateway and factory to the repository.\n$repo    = new Repository($gateway, $factory);\n\n\n\n\nAs you can see, the process of replacing the gateway for an object repository is\ntrivial. The hard part is actually implementing the custom Gateway. Anyways, that's\nthe gist of it... happy coding!\n\n\nTesting\n\n\nAlright, the first important thing to realize about AmBlend when considering testing\nis the Data-Mapper pattern it follows. Because the logic to persist a model is\nseparate from the model itself, you can do any of the following as suits your needs\nfor testing:\n\n\n\n\nYou can use a test Gateway to return fixed dummy data (see the \"writing your\n own gateway\" description above for more info). If you plan on leaving Dynamic Loading\n on, you'll also need to pass in to the Factory a database object you want used\n for testing (Dynamic Loading will use that DAO).\n\n\nYou can pass in a database object to a Test database connection in order to grab\n your testing data. This would look like so, where you need to pass the database object\n to both the Factory and Gateway:\n\n\n\n\n$db = \\Cora\\Database::getDb('name_of_test_db_connection');\n$class = 'User';\n$factory = new Factory($class, $db);\n$gateway = new Gateway($db);\n$repo    = new Repository($gateway, $factory);\n\n\n\n\n\n\nAnd last but not least, you can just create classes of whatever model you need\n by hand (not using the Repository/Gateway/Factory) and populate them with whatever\n you want. This works because Cora models are just normal everyday classes that you\n can use just like any other class. The one thing you'll want to be sure to do in this\n situation though is to turn off Dynamic Loading (see below).\n\n\n\n\nTurning off Dynamic Loading:\n\n\nLet's quickly talk about Dynamic Loading and how to turn it off. You'll\nrecall from previous discussions that Dynamic Loading is a nifty little feature\nthat allows a model to request additional related objects from a Repository on-demand.\nIf you are expecting this behavior, and want the model to be able to request related\nmodels on-demand, you don't need to do anything and can just leave this feature on.\nHowever, if you want full control over the model, and would like to turn Dynamic Loading\noff, you just need to flip the following boolean on the model:\n\n\n$user = $this->repo->find($id);\n$user->model_dynamicOff = true;",
            "title": "AmBlend ORM"
        },
        {
            "location": "/documentation/amblend/overview/#what-is-amblend",
            "text": "TL;DR It makes grabbing objects from and saving objects to a database super easy.  In short, AmBlend is the ORM tool developed for, and included with Cora.\nAn ORM (Object Relational Mapping) tool is something that handles moving data to and\nfrom objects and the database. This is useful when doing OO (object oriented) programming\nas it allows developers to focus on the core functionality and features of their application\nand not on the nitty-gritty grunt work of how to fetch and persist (aka 'save') data. This generally results\nin less code that needs to be written, and faster development times.  As an added bonus, using AmBlend allows Cora to build your database for you automatically\nbased on the definitions of your models, if you so desire.",
            "title": "What is AmBlend?"
        },
        {
            "location": "/documentation/amblend/overview/#how-does-amblend-differ-from-other-orms",
            "text": "ORM implementations basically boil down into two basic types: Active-Record or Data-Mapper.\nBoth have their pros and cons, but AmBlend was designed as a \"blend\" of both approaches ('AM'\nshort for Active-record and data-Mapper) with the goal of taking the best aspects of each and blending them\ninto a new paradigm. Below are the stereotypical strengths and weaknesses of each approach compared to AmBlend:  \n   \n     Property: \n     Active-Record \n     Data-Mapper \n     AmBlend \n   \n   \n     Easy to Setup \n     Yes \n     No \n     Yes \n   \n   \n     Easy to Use \n     Yes \n     No \n     Yes \n   \n   \n     Easy to Test \n     No \n     Yes \n     Yes \n   \n   \n   SRP  Compliant \n     No \n     Yes \n     Yes \n   \n   \n     Domain and Database Separation \n     No \n     Yes \n     Yes \n   \n   \n     Performance Optimization \n     Depends \n     Depends \n     Yes* \n     *  As much as possible, flexibility and optimization were kept in mind when building AmBlend. An explanation of the specific optimizations\nin place can be found in the optimizations section.  For more information about how AmBlend is implemented, see AmBlend's \"Implementation\" page.",
            "title": "How Does AmBlend Differ From Other ORMs?"
        },
        {
            "location": "/documentation/amblend/overview/#how-to-use-basics",
            "text": "First you need to have your models extend from Cora's Model class, and add an associative array\nwhich defines the attributes of that model. See below for an example User model\nwhich has an ID, a couple strings in Name and Email, and a Job attribute which\nis another model representing the job of this user.",
            "title": "How-to-Use Basics"
        },
        {
            "location": "/documentation/amblend/overview/#define-some-cora-models",
            "text": "class User extends \\Cora\\Model {\n\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar'\n        ],\n        'job' => [\n            'model' => 'job'\n        ]\n    ];\n\n    public function __construct($name = null, $email = null)\n    {\n        $this->name = $name;\n        $this->email = $email;\n    }\n}\n\nclass Job extends \\Cora\\Model {\n\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'title' => [\n            'type' => 'varchar'\n        ],\n        'description' => [\n            'type' => 'varchar'\n        ]\n    ];\n\n    public function __construct($title = null, $description = null)\n    {\n        $this->title = $title;\n        $this->description = $description;\n    }\n}  Notice you didn't have to use any special comments with @ symbols or anything else;\nyou inform Cora about what your model's attributes are using a normal array.\nFurthermore, there's nothing special about the constructors (you can write them\njust like you would any other class), AND there's nothing special about the\nproperties of a model either. If you want to add additional normal properties\nto the model that's all\nperfectly fine. All that's important to know is that unless a property is defined\nin the \"model_attributes\" array, AmBlend won't try to save it to a database.\nTo say that another way, you can add whatever properties you want\nto a model, AmBlend will just ignore them unless you also add that property to the\nmodel_attributes array. In that sense, you can use and create Cora models just\nlike you would any normal class. The only thing you need to be careful of is to not override\nthe _   get() and _   set() methods.  Next you need to create your database(s).",
            "title": "Define some Cora models:"
        },
        {
            "location": "/documentation/amblend/overview/#create-your-database",
            "text": "The easiest way to create your database is to use AmBlend's automated database\ncreation tool! In order to take advantage of this feature, you need to make sure\nyou've setup your database configuration. If you haven't done that yet, Click Here  to view\ninstructions on doing so. The other thing you'll need (as of me writing this),\nis command line access. In the future, an in-browser\nvisual interface to the database creation tool may be added, but for now it's just\na command line tool.   If on a shared hosting environment:   \n\nBecause the database creation feature is a command line tool...\nwhat this means for people who will be hosting their app in\na shared hosting environment without command line access is that you'll need to\ngenerate your database on your local machine and then use a tool (such as PhpMyAdmin)\nto export your generated database into an SQL file you can upload.  To automatically generate a database based on your model definitions you need\nto do the following:   Open a Terminal.  If on a Mac, open your Applications, click the Utilities folder, and then\nselect the \"Terminal\" application.  If on a PC, hit your Windows Key + R to open the \"Run\" window, then type\nin \"cmd\" and hit enter.  If on Linux you don't need me to tell you how to do this, but since I can't\nhelp myself I'll mention that Ubuntu and Mint both map the terminal to\nCtrl+Alt+T.    Navigate to your project's directory.  If you are XAMPP, MAMP, etc, that will likely be wherever you installed\nthat and then in the \"htdocs\" folder within.    Once at the root of your project, type \"php Amblend.php dbBuild\" to have\nAmBlend build your database for you.  If you get an error about PHP not being a recognized command, that means\nPHP is not a part of your operating system's PATH. Google \"add php to path\"\nor something similar if you aren't sure how to do this.     If all went well, you should see a flurry of output to the console and your database\nshould be ready to go!  Of course, if you want to read through the documentation\nin the Models page to fully understand how the mappings work for the purpose of\nsetting your database(s) up manually, you can, although that takes more expertise\nand effort.",
            "title": "Create Your Database:"
        },
        {
            "location": "/documentation/amblend/overview/#start-using-amblend",
            "text": "And ... wait for it ... congratulations! You're now ready to start using AmBlend.\nSo we're all good to go, but how do we actually fetch models from and save models\nto the database? The answer is we need to use a Repository.\nSee below for an example Users controller where we use AmBlend to interact with\nour database. This Users controller will be very simple, we'll just have a method\nfor registering a new user, and an ultra simple Profile method that just echoes\nout the user's job title.  Using AmBlend in a Controller:  class Users extends \\MyApp\n{\n    protected $repo;\n    protected $db;\n\n    public function __construct()\n    {\n        parent::__construct();\n        $this->repo = \\Cora\\RepositoryFactory::make('User');\n    }\n\n    /**\n     *  Create a new user.\n     */\n    public function register()\n    {\n        // Grab our inputs. We'll just use fake data instead of\n        // actually capturing it from a form.\n        $name = 'Bob';                // $this->input->post('name');\n        $email = 'Bob@fakeEmail.com'; // $this->input->post('email');\n\n        // Create a new User.\n        $user = new User($name, $email);\n\n        // Assign the user a job.\n        $user->job = new Job('Athlete', 'Track and Field');\n\n        // Save the user to the database.\n        $this->repo->save($user);\n\n        // When the user was saved to the database, AmBlend\n        // assigned the object the unique ID the database provided it.\n        // Let's echo this user's ID.\n        echo $user->id;\n    }\n\n    /**\n     *  Display a user's profile.\n     *  In this case, just echo their job title.\n     */\n    public function profile($id)\n    {\n        $user = $this->repo->find($id);\n        echo $user->job->title;\n    }\n}  If you have the Cora demo project installed, you can run this code and see it\nworking in action. First you'll want to go to:  http://localhost/{myProjectName}/users/register  ^ Replace \"{myProjectName}\" with the name of the folder your Cora demo project\nis in. This should create our user \"Bob\" and then echo out to the browser\nthe ID number assigned to him. If you use that ID, you can then go to the profile\npage at:  http://localhost/{myProjectName}/users/profile/{id}  ^ Where {id} is the ID of Bob. If Bob's ID is \"2\":  http://localhost/{myProjectName}/users/profile/2  And just like that, AmBlend saved our user Bob to the database as represented\nby the User object, saved a separate Job object to the database that represents\nthe job Bob does, and automatically handled setting up the associations for you\nbetween the objects. This is why you can do:  echo $user->job->title;  on the profile page and have it work so effortlessly. Behind-the-scenes\nAmBlend is doing all the heavy-lifting busy work for you to make saving and\nretrieving objects along with any other objects associated with them a breeze.   Explanation Pitstop:   \nSo the one thing I didn't talk about in the code above is what's happening\nin the constructor for our Users controller where we are creating our Repository object.  In programming lingo a \"factory\" is a class that handles creating objects for you.\nThe easiest way to get a Repository of a certain type is to use Cora's RepositoryFactory\nclass' Make method and telling it what type of repository you want to create.\nSo the code as seen below is just the simplest way of creating a User class repository:  $this->repo = \\Cora\\RepositoryFactory::make('User');  For more information about the Repository, Gateway, Factory pattern I recommend\nreading the documentation page for each under the AmBlend ORM section.",
            "title": "Start Using AmBlend:"
        },
        {
            "location": "/documentation/amblend/overview/#optimizing-performance",
            "text": "Ok, now that's we've seen the bare basics of how AmBlend works, let's talk for a minute\nabout how it tries to make your app lean and fast. In general, ORMs get a bad rap\nfor being inefficient, and rightfully so. I've read the horror stories of engineers\ncalled in to speed up programs only to find out the ORM used by the program is spitting\nout super ugly and inefficient queries that are like trying to kill a fly with a\nheavy machine gun! In terms of AmBlend, my goal here is to describe\nexactly how it works so you can make your own judgements about when or when not to use it.",
            "title": "Optimizing Performance"
        },
        {
            "location": "/documentation/amblend/overview/#light-classes",
            "text": "First up, when grabbing data from a row in the database for the purpose of populating\nan object, by default, AmBlend will grab all the data in that row. That is to say:  $user = $this->repo->find($id);  Is the SQL equivalent to doing:  SELECT * FROM users WHERE id = :id  One of the optimizations in AmBlend is the ability to dynamically create \"light\"\nversions of a class by not grabbing all the class data, and instead only grabbing\nthe data you need. This is possible because AmBlend uses Cora's Database class\nto interact with the persistence layer, and allows you to pass a partial query\nalong to the repository when asking for models. See below for example. You can\nadd the following method to the Users controller we previously used to see this in\naction:  public function lightClassDemo($id)\n{\n    $this->db->where('id', $id);\n    $this->db->select(['id', 'name']);\n    $user = $this->repo->findOne($this->db);  \n    var_dump($user);\n}  Is equivalent to doing:  SELECT id, name FROM users WHERE id = :id  What we're leaving out here is the user's email and their job, maybe because whatever we're\ndoing with the object doesn't require that info. It's a general rule when optimizing\nperformance to only grab what you need, and with this functionality, AmBlend\ngives you that capability.  (Note that you can use findAll() to similarly fetch\na collection of \"light\" objects.)",
            "title": "\"Light\" Classes:"
        },
        {
            "location": "/documentation/amblend/overview/#collection-subsets",
            "text": "Alright, say you want to print out a list of users, but you don't want to list all\nusers, just the ones that are Admins. Using the same methodology we\nused in the previous section to create a \"light\" version of a class, we can also\nlimit the objects we are grabbing to a subset of a whole collection. (Note: this\nexample assumes there's some sort of \"type\" attribute on the user model):  public function subsetDemo()\n{\n    $this->db->where('type', 'Admin');\n    $users = $this->repo->findAll($this->db);\n\n    foreach ($users as $user) {\n        echo $user->name.'<br>';\n    }\n}  This is yet another example of how AmBlend let's you only fetch the data you need,\nso you aren't wasting system resources.",
            "title": "Collection Subsets:"
        },
        {
            "location": "/documentation/amblend/overview/#dynamic-loading",
            "text": "AKA - How related objects are fetched:  Alright, now that we've talked about how data on the class' main table can be limited\n(\"light\" classes) and how repositories can be asked to return only a subset of\nobjects in a collection... let's continue our discussion of performance by going\nover HOW AmBlend grabs related objects.  By \"related objects\" what I'm referring to is say the Job object associated with\na user from one of our previous examples on this page. Another example would be\nif you were creating a blogging site and each user had a collection of \"articles\"\nthey've written where each article is its own object. If you are an experienced\ndeveloper who's concerned about performance, how AmBlend grabs these related objects\nfrom a database is something you should know.  The answer to that question is that AmBlend only grabs related objects \"on-demand\"\nutilizing what I call Dynamic Loading. The way in which this is done varies a little\nbit depending on how the data is stored, but all follows the same concept.\nGoing back to the \"User has a Job\" example, the way we defined the Job attribute\non our User model as a simple, single related object means that our Users table\nwill have a \"job\" column that stores the ID of that user's job.   In the case of Bob as seen in the image of his Users table entry above, grabbing\nhis whole user object and doing a var_dump as seen in this code:  public function profile($id)\n{\n    $user = $this->repo->find($id);\n    var_dump($user);\n}  Has the following applicable output:  protected 'model_data' =>\n    array (size=5)\n      'name' => string 'bob' (length=3)\n      'type' => string 'admin' (length=5)\n      'id' => string '1' (length=1)\n      'email' => string 'bob@fakeEmail.com' (length=17)\n      'job' => string '3' (length=1)  As you can see, the \"job\" attribute is NOT an object at this point, it's just\nan ID number that references a job object. However, through the power of AmBlend's\ndynamic loading, if you try and access Bob's job property, it will be fetched\nfrom the persistence layer and an object will replace the ID. To see this in\naction, let's echo out Bob's job title, and then do a var_dump afterwards to see\nthe difference:  public function profile($id)\n{\n    $user = $this->repo->find($id);\n    echo $user->job->title;\n    var_dump($user);\n}  And the result of the var_dump now looks like:  protected 'model_data' =>\n    array (size=5)\n      'name' => string 'bob' (length=3)\n      'type' => string 'admin' (length=5)\n      'id' => string '1' (length=1)\n      'email' => string 'bob@fakeEmail.com' (length=17)\n      'job' =>\n        object(Job)[11]\n          public 'model_attributes' =>\n            array (size=3)\n              ...\n          protected 'model_data' =>\n            array (size=3)\n              ...  As you can see, the \"job\" attribute is no longer just an ID, it's been replaced\nby a full Job object!",
            "title": "Dynamic Loading"
        },
        {
            "location": "/documentation/amblend/overview/#for-object-collections-or-single-objects-that-use-a-relation-table",
            "text": "This works similarly, but slightly different for related objects that use a\nrelation table or an \"owner\" type column on the related object's table. If Bob's\nUser table entry looked like this:   (Notice the lack of a \"job\" column)  And Jobs were getting related to Users by utilizing a separate relation table,\nthen the var_dump on User would look like this:  protected 'model_data' =>\n    array (size=5)\n      'name' => string 'bob' (length=3)\n      'type' => string 'admin' (length=5)\n      'id' => string '1' (length=1)\n      'email' => string 'bob@fakeEmail.com' (length=17)\n      'job' => int 1  In this scenario, the \"job\" attribute is NOT the ID of the related job object,\nbut rather just a boolean placeholder to let AmBlend's Dynamic Loading system know that\na related job exists, and that if Job is called for, it needs to use the reference\ntable to go fetch it!  This is obviously a slight difference, but one that could trip you up if you\ndon't realize how it's working.",
            "title": "For object collections or single objects that use a relation table:"
        },
        {
            "location": "/documentation/amblend/overview/#performance-considerations-of-dynamic-loading",
            "text": "WARNING: So the info I'm about to talk about below is intended for experienced\n    enterprise-level developers! It's very \"nitty-gritty\", so don't say I didn't\n    warn you. If you get lost, don't worry, just skip this section.  Alright, now that you should have an understanding of how AmBlend grabs related\nobjects (\"on-demand\" using dynamic loading), you can weigh the performance cost.\nOn one hand, the fact that AmBlend grabs only as little data as possible and grabs\nextra stuff as needed helps keep your objects lean. However, because a separate\nquery is run each time you need to fetch a related object, this has the potential\nto bombard your database with hundreds or even thousands of small queries for\nindividual objects. For example, let's pretend we have 1,000 users in our\nusers table and we execute the following code on a Users repository:  // Fetches ALL users\n$users = $this->repo->findAll();\n\nforeach ($users as $user) {\n    echo $user->job->title;\n}  The loop will run 1,000 times, and since each Job will be fetched\nindividually using a separate query at the time it tries to get accessed, it will\nresult in the equivalent of 1,000 of these queries:  SELECT * FROM jobs WHERE `id` = :id  I'm not a database mega-expert, but I'm sure that doing\n1,000 small queries is less efficient than if you just did one larger query to\ngrab all the data you needed in one go. Maybe if you consider the fact that you'd\nthen have to loop through the results of the larger query to assign each row of\ndata to an object it might come out as a wash, but that's for you to decide and\nnot me. The point I want to communicate is that this is how it works when you\ntry and access related objects to whatever the primary object you're using is.  If you wanted to grab all the Jobs from the database and have AmBlend return\nthem for you as objects, but you DON'T want to go through that process of executing\n1,000 individual queries... you have a few options:   Avoiding Lots of Mini-Queries - Option #0:  (Yes, I did just call this option zero. On purpose.)  The fact of the matter is, looping through 1,000 users and accessing information\nabout each, is not a typical usage example. If you're building an object oriented\nreporting system, I could see this being the case, but in 95% of situations you're\nprobably iterating over a small collection. If you are making some sort of users\nlist, chances are you'll be using a pagination setup, and so you probably only\nneed to loop over a few dozen users at a time.  If you're building say a Forum post system, again you're probably only iterating\nover a few dozen users, and using a pagination system again if things get too long.  In my experience exploring things such as string matching algorithms,\nwhen dealing with small data sets, a simple brute-force solution\nusually performs as well or better than a fancy more eloquent one due to the\noverhead cost of setting up fancy solutions.  So if you're concerned about performance, do a little testing. You might find\nthe simplest option may be the best option.   Avoiding Lots of Mini-Queries - Option #1:  You can just create a Jobs repository and ask for all the jobs. This will execute\na single query to fetch a collection of all the Jobs. The downside here is that\nunless you create a backwords reference from a Job to a User (our example from earlier on\nthis page didn't have one), you won't know what User(s) that Job is associated with.\nAlso worth noting, if you end up adding a backreference and using it, you might\nend up in the same individual queries situation.  But depending on what you're doing, just grabbing all the jobs this way and then\nmaybe doing some mapping between the collection of Jobs and the collection of Users\n(if necessary for the task) could be an option.   Avoiding Lots of Mini-Queries - Option #2:  If you don't need the full related object, but just a piece of information from it,\nyou can add a join to the Repository query. For instance, let's say you don't need\nthe full Job object, but just need a user's job title. You can do the following:  public function joinDemo($id)\n{\n    $this->db->where('users.id', $id)\n             ->select(['users.id', 'users.name', 'jobs.title as job_title'])\n             ->join('ref_users_jobs', [['users.id', '=', 'ref_users_jobs.user']])\n             ->join('jobs', [['ref_users_jobs.job', '=', 'jobs.id']]);\n    $user = $this->repo->findOne($this->db);  \n    echo $user->job_title;\n}  (NOTE: the above example is taken directly from the Cora demo project and Jobs are related\n    to Users via a relation table - which is different from our previous example on\n    this page where a Job ID was stored directly in the Users table)  Looking at the select() method above, in addition to grabbing the user's ID and\nname, we are also doing some joins and then grabbing the user's job title.\nSince \"job_title\" is NOT defined in the User class attributes definition, AmBlend\nwill pass it into the object as a property, but it will not do anything further.\nWhat this means is that if you alter the title and then tell AmBlend to save\nthis user, the job title will NOT get saved since it's not technically part of the class\ndefinition. The job title is just merely extra data you asked AmBlend to grab, which it did.  This can be useful if you just need some simple read-only data about a user though!\nAs you can see in the code snippet above we were able to\necho out the title. I'm sure if you're an experienced developer and reading this\nyou can see how this could be useful as long as you're careful about when/how you\nuse it. It's just important to keep in mind that any object properties not defined\nin the model_attributes array are ignored when an object is saved.  It's also worth noting here that a (probably more convenient) way of doing the same\nthing is to utilize a model's lifecycle hooks to run some custom queries when a\nmodel is fetched or saved! By doing so you can fetch the extra data anytime you\nwould normally fetch an instance of the model, and you can save the extra data\nwhenever you tell a repository to save it. See the LifeCycle Hooks section for\nmore information.   Avoiding Lots of Mini-Queries -  Option #3:  You can pass a custom built Gateway to a Repository that does whatever queries you\nwant and manipulates data in whatever way you want. AmBlend is great because it\nhandles the generic day-to-day fetching and persisting of objects for you, which is\nreally nice, BUT that doesn't mean you can't override its default behavior if you need\nto handle more complicated tasks. See the section below on how you can modify or\nreplace the default Gateway (the class in charge of fetching data from the persistence layer)\nwith a custom one of your own making.",
            "title": "Performance considerations of dynamic loading:"
        },
        {
            "location": "/documentation/amblend/overview/#limiting-resource-creation",
            "text": "Another optimization made in AmBlend is statically declared data when possible.\nSpecifically, since most apps are likely created using a single\ndatabase, the default database adaptor is stored statically. What this means is\nthat each time you trigger something like Dynamic Loading on an object that uses\nthe app's default database, AmBlend isn't creating a new database object each time,\nbut rather using the statically stored version if it exists. This means less\nwork to get setup.  It's a small thing, but every little improvement helps in the long run.",
            "title": "Limiting Resource Creation"
        },
        {
            "location": "/documentation/amblend/overview/#overriding-default-behavior",
            "text": "So one of the criticisms of the ActiveRecord pattern is it ties an object too\nclosely to a single table, and doesn't give the flexibility in how an object\nis fetched and saved that a developer might want. In most cases, this really isn't a problem (ActiveRecord\nis the most popular ORM pattern in use as of this writing to my knowledge after all).\nIn addition, as you've probably noticed if you've read this far down the page,\ngrabbing related objects from various different tables is an absolute BREEZE using\nAmBlend! However, there still may be situations that come up where a developer\nfeels the need for advanced models that are composed of direct data from multiple\ntables (\"direct data\" meaning numbers, strings, dates, etc).  The first thing I would caution a developer if they feel like they need to do this\nis to sleep on it, and re-examine what they're trying to accomplish. Does your\nobject REALLY need its data grabbed from multiple tables/sources? Can the data you\nwant to grab from a 2nd table be grabbed from a related object, rather than shoving it\ninto your current one? What about just doing a good old fashioned direct query\nusing Cora's database class? There are lifecycle hooks you can use when fetching\nor saving a model to run your custom query for fetching/saving this extra data.\nThe point I'm trying to make is that the option I'm going to share below,\nyou probably don't ever need to use... but I'll share it anyway because\nknowledge is power... or something like that.",
            "title": "Overriding Default Behavior"
        },
        {
            "location": "/documentation/amblend/overview/#writing-your-own-gateway",
            "text": "Alright, I'm not actually going to go into too much depth on this, as if you're\na developer who feels the need to write your own Gateway for fetching/persisting\nan object, you probably are pretty competent in your knowledge and skills. Instead\nI'll just gloss over the high-level process of doing this in Cora to save you\ntime having to dig as much into the code.  The steps I would take are as follows:   Either extend Cora's Gateway class and override whatever method(s) you want,\n or copy+paste the existing class into a new file, delete the contents of the methods,\n and save it as whatever you want (something like \"UserGateway\" would make sense for\n a User class). Obviously don't forget to implement the methods with your own code.  Now that you have your fancy custom Gateway ready to go, you just need to pass\n it into a Repository in place of the default one included in Cora. The way to\n go about doing this is to NOT use the RepositoryFactory like we've been using in\n our examples, and instead just go through the simple process of initializing a\n Repository for yourself like so:   // Create the Factory and Gateway the repository will use.\n$factory = new Factory($class);\n$gateway = new UserGateway(...insert your parameters...);\n\n// Pass a gateway and factory to the repository.\n$repo    = new Repository($gateway, $factory);  As you can see, the process of replacing the gateway for an object repository is\ntrivial. The hard part is actually implementing the custom Gateway. Anyways, that's\nthe gist of it... happy coding!",
            "title": "Writing Your Own Gateway:"
        },
        {
            "location": "/documentation/amblend/overview/#testing",
            "text": "Alright, the first important thing to realize about AmBlend when considering testing\nis the Data-Mapper pattern it follows. Because the logic to persist a model is\nseparate from the model itself, you can do any of the following as suits your needs\nfor testing:   You can use a test Gateway to return fixed dummy data (see the \"writing your\n own gateway\" description above for more info). If you plan on leaving Dynamic Loading\n on, you'll also need to pass in to the Factory a database object you want used\n for testing (Dynamic Loading will use that DAO).  You can pass in a database object to a Test database connection in order to grab\n your testing data. This would look like so, where you need to pass the database object\n to both the Factory and Gateway:   $db = \\Cora\\Database::getDb('name_of_test_db_connection');\n$class = 'User';\n$factory = new Factory($class, $db);\n$gateway = new Gateway($db);\n$repo    = new Repository($gateway, $factory);   And last but not least, you can just create classes of whatever model you need\n by hand (not using the Repository/Gateway/Factory) and populate them with whatever\n you want. This works because Cora models are just normal everyday classes that you\n can use just like any other class. The one thing you'll want to be sure to do in this\n situation though is to turn off Dynamic Loading (see below).",
            "title": "Testing"
        },
        {
            "location": "/documentation/amblend/overview/#turning-off-dynamic-loading",
            "text": "Let's quickly talk about Dynamic Loading and how to turn it off. You'll\nrecall from previous discussions that Dynamic Loading is a nifty little feature\nthat allows a model to request additional related objects from a Repository on-demand.\nIf you are expecting this behavior, and want the model to be able to request related\nmodels on-demand, you don't need to do anything and can just leave this feature on.\nHowever, if you want full control over the model, and would like to turn Dynamic Loading\noff, you just need to flip the following boolean on the model:  $user = $this->repo->find($id);\n$user->model_dynamicOff = true;",
            "title": "Turning off Dynamic Loading:"
        },
        {
            "location": "/documentation/databaseclass/overview/",
            "text": "Cora's Database class\n\n\nNOTE: IF YOU ARE GOING TO BE GRABBING CLASS RECORDS FROM A DATABASE, YOU SHOULD CONSIDER USING THE\nAMBLEND ORM, NOT THIS LOWER LEVEL DATABASE CLASS.\n\n\nIn a nutshell, Cora's Database class acts as a \nData Access Object\n. It\noffers you a simple way to interact with a database, without having to worry about implementation specific details for different database types.\nThe ELI5 explanation goes like this: \n\nSay you build an application that uses Database-A, and Database-A uses commands that look like the following:\n\n\nSELECT first_name FROM users WHERE id=12;\n\n\n\n\nHowever, one day your boss says to you that he wants you to switch over to using Database-B. Database-B however uses a different\ncommand syntax though that looks something like this:\n\n\ndb.users.find( { id: 12 }, { first_name: 1 } );\n\n\n\n\nWHOA NELLY! If you haven't been using a Data Access Object, then the fact that this new database uses a different syntax could be devastating.\nYou might literally have to rewrite HUGE portions of your application to make everything work with this new format. NOT GOOD! This is where\na DAO comes in handy. Let's say you've written all your database queries in your application using a DAO and it has its own format that looks something like so:\n\n\n$db ->select('first_name')\n    ->from('users')\n    ->where('id', 12)\n    ->exec();\n\n\n\n\nIf your app is using this DAO, now when your boss tells you to start using database-B, all that you need to do is write translation instructions (aka an 'adaptor') for your DAO\nso it knows how to turn the above into the instuction format database-B uses (or more likely, someone else has already written an adaptor, can you just have to download it).\nIn this way, Cora's Database class acts as an abstraction layer that helps separate your application from any one specific database implementation.\n\n\nHow it's Implemented\n\n\nWhen you construct an SQL statement using the Database class' query building methods, the resulting query parameters are stored as\nraw data within the Database class (mostly stored in arrays). In order to take that raw data and then execute a query, you have to\nutilize an adaptor that extends the Database class and implements the exec() method. The adaptor is responsible for taking that raw\ndata and translating it into the format required by its associated Database in order to execute the query.\n\n\nCurrently Supported Databases\n\n\nCora currently has adaptor classes for:\n\n\n\n\nMySQL (Db_MySQL.php)\n\n\n\n\nIntroduction\n\n\nBelow is a basic example that grabs and echoes the name of all the users in a users table who's type is 'admin'.\n\n\n// Create Database object with adaptor\n$db = new \\Cora\\Db_MySQL();\n\n// Create query\n$db ->select('name')\n    ->from('users')\n    ->where('type', 'admin');\n\n// Execute query and get returned result.\n$query = $db->exec();\n\n// Print all the names\nforeach($query->fetchAll() as $user) {\n    echo $user['name'];\n}\n\n\n\n\nAs you probably see, the basic formula is you create an instance of a database adaptor (Db_MySQL extends Database), construct\nsome query using the Database class' methods, then call the exec() function to execute the query and return any expected result.\nQuery methods can be chained together as you see above too.\n\n\nSecurity\n\n\nThe Database class and its query building methods are extremely powerful, and as such, there are dangerous scenarios of which you need\nto be aware! Column VALUES are sanitized to protect your app from SQL Injection attacks. However, COLUMN name parameters and OPERATOR parameters (=, >, <, IN, etc)\nare NOT sanitized!!! For this reason you should never under any circumstance pass in a value you receive from a user into one of those fields!\nDoing so will leave a huge security hole in your app that an attacker could take advantage of to destroy or compromise everything.\n\n\nBelow is a \nSAFE\n query:\n\n\n// Create and execute query\n$db ->select('name')\n    ->from('users')\n    ->where('name', $_POST['userName']);\n$query = $db->exec();\n\n\n\n\nBelow is an \nEXTREMELY UNSAFE\n query:\n\n\n// Create and execute query\n$db ->select('name')\n    ->from('users')\n    ->where($_POST['column'], $_POST['value']);\n$query = $db->exec();\n\n\n\n\nMethods\n\n\nUtility Methods\n\n\nThe following methods are available when creating any type of query:\n\n\n\n\ngetQuery()\n (returns the compiled query)\n\n\nexec()\n (executes the query that's been constructed and calls Reset)\n\n\nreset()\n (resets the Database class so it's ready for a new query)\n\n\n\n\nSELECT Statements\n\n\nThe methods available when creating a select statement are:\n\n\n\n\nselect()\n\n\ndistinct()\n\n\nfrom()\n\n\njoin()\n\n\nwhere()\n\n\norWhere()\n\n\nin()\n\n\ngroupBy()\n\n\nhaving()\n\n\norHaving()\n\n\norderBy()\n\n\nlimit()\n\n\noffset()\n\n\n\n\nUPDATE Statements\n\n\nThe methods available when creating an update statement are:\n\n\n\n\nupdate()\n\n\nset()\n\n\nwhere()\n\n\n\n\nINSERT Statements\n\n\nThe methods available when creating an insert statement are:\n\n\n\n\ninsert()\n\n\ninto()\n\n\nvalues()\n\n\n\n\nDELETE Statements\n\n\nThe methods available when creating an delete statement are:\n\n\n\n\ndelete()\n\n\nfrom()\n\n\nwhere()\n\n\n\n\nCREATE Statements\n\n\nThe methods available when creating an create statement are:\n\n\n\n\ncreate()\n\n\nfield()\n\n\nprimaryKey()\n\n\nforeignKey()\n\n\n\n\nAdvanced Examples\n\n\nCreating a table:\n\n\n$db ->create('locations')\n            ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n            ->field('name', 'varchar(255)')\n            ->field('address', 'varchar(255)')\n            ->field('user_id', 'int')\n            ->primaryKey('id')\n            ->foreignKey('user_id', 'users', 'id');\n$db->exec();\n\n\n\n\nInserting data:\n\n\n$db ->insert('name, email, type')\n    ->into('users')\n    ->values([\n        ['bob', \"bob's@gmail.com\", 'admin'],\n        ['john', 'john@gmail.com', 'admin'],\n        ['john', 'john@gmail.com', 'scrub'],\n        ['sally', 'sally@yahoo.com', 'user'],\n        ['susan', 'susan@aol.com', 'user']\n    ])\n    ->exec();\n\n\n\n\nMore advanced Where statement:\n\n\n$db ->select('id')\n    ->distinct()\n    ->from('users')\n    ->from('profile')\n    ->where([\n        ['created_time', '>=', '2016-01-01', 'OR'],\n        ['name', 'LIKE', 's%']\n    ])\n    ->where([\n        ['type', '=', 'admin', 'OR'],\n        ['type', '=', 'moderator']\n    ])\n    ->exec();\n\n\n\n\nMega Query:\n\n\n$tables = array('table1', 'table2', 'table3');\n$fields = array('id', 'name', 'email');\n$conditions = array(\n    ['id', '>', '100', 'OR'],\n    ['name', 'LIKE', '%s']\n);\n\n$groupBys = ['field1', 'field2', 'field3'];\n\n$havings = array(\n    ['amount', '>', '1000'],\n    ['savings', '>', '100']\n);\n\n$orHavings = array(\n    ['amount2', '>', '1000'],\n    ['savings2', '>', '100']\n);\n\n$joinConditions = array(\n    ['Orders.customerID', '=', 'Customers.customerID'],\n    ['User.type', '=', 'Customer.type']\n);\n\n\n$db = new Cora\\Db_MySQL();\n\necho $db->select($fields)\n        ->from($tables)\n        ->join('customers', $joinConditions, 'OUTER')\n        ->where($conditions)\n        ->orWhere($conditions)\n        ->in('name', 'value1, value2, value3')\n        ->in('name', 'SELECT * FROM users')\n        ->in('type', $groupBys)\n        ->groupBy($groupBys)\n        ->having($havings)\n        ->orHaving($orHavings)\n        ->having($orHavings)\n        ->orderBy('name', 'DESC')\n        ->orderBy('type', 'ASC')\n        ->limit(10)\n        ->offset(20)\n        ->getQuery();",
            "title": "Database Class"
        },
        {
            "location": "/documentation/databaseclass/overview/#coras-database-class",
            "text": "NOTE: IF YOU ARE GOING TO BE GRABBING CLASS RECORDS FROM A DATABASE, YOU SHOULD CONSIDER USING THE\nAMBLEND ORM, NOT THIS LOWER LEVEL DATABASE CLASS.  In a nutshell, Cora's Database class acts as a  Data Access Object . It\noffers you a simple way to interact with a database, without having to worry about implementation specific details for different database types.\nThe ELI5 explanation goes like this:  \nSay you build an application that uses Database-A, and Database-A uses commands that look like the following:  SELECT first_name FROM users WHERE id=12;  However, one day your boss says to you that he wants you to switch over to using Database-B. Database-B however uses a different\ncommand syntax though that looks something like this:  db.users.find( { id: 12 }, { first_name: 1 } );  WHOA NELLY! If you haven't been using a Data Access Object, then the fact that this new database uses a different syntax could be devastating.\nYou might literally have to rewrite HUGE portions of your application to make everything work with this new format. NOT GOOD! This is where\na DAO comes in handy. Let's say you've written all your database queries in your application using a DAO and it has its own format that looks something like so:  $db ->select('first_name')\n    ->from('users')\n    ->where('id', 12)\n    ->exec();  If your app is using this DAO, now when your boss tells you to start using database-B, all that you need to do is write translation instructions (aka an 'adaptor') for your DAO\nso it knows how to turn the above into the instuction format database-B uses (or more likely, someone else has already written an adaptor, can you just have to download it).\nIn this way, Cora's Database class acts as an abstraction layer that helps separate your application from any one specific database implementation.",
            "title": "Cora's Database class"
        },
        {
            "location": "/documentation/databaseclass/overview/#how-its-implemented",
            "text": "When you construct an SQL statement using the Database class' query building methods, the resulting query parameters are stored as\nraw data within the Database class (mostly stored in arrays). In order to take that raw data and then execute a query, you have to\nutilize an adaptor that extends the Database class and implements the exec() method. The adaptor is responsible for taking that raw\ndata and translating it into the format required by its associated Database in order to execute the query.",
            "title": "How it's Implemented"
        },
        {
            "location": "/documentation/databaseclass/overview/#currently-supported-databases",
            "text": "Cora currently has adaptor classes for:   MySQL (Db_MySQL.php)",
            "title": "Currently Supported Databases"
        },
        {
            "location": "/documentation/databaseclass/overview/#introduction",
            "text": "Below is a basic example that grabs and echoes the name of all the users in a users table who's type is 'admin'.  // Create Database object with adaptor\n$db = new \\Cora\\Db_MySQL();\n\n// Create query\n$db ->select('name')\n    ->from('users')\n    ->where('type', 'admin');\n\n// Execute query and get returned result.\n$query = $db->exec();\n\n// Print all the names\nforeach($query->fetchAll() as $user) {\n    echo $user['name'];\n}  As you probably see, the basic formula is you create an instance of a database adaptor (Db_MySQL extends Database), construct\nsome query using the Database class' methods, then call the exec() function to execute the query and return any expected result.\nQuery methods can be chained together as you see above too.",
            "title": "Introduction"
        },
        {
            "location": "/documentation/databaseclass/overview/#security",
            "text": "The Database class and its query building methods are extremely powerful, and as such, there are dangerous scenarios of which you need\nto be aware! Column VALUES are sanitized to protect your app from SQL Injection attacks. However, COLUMN name parameters and OPERATOR parameters (=, >, <, IN, etc)\nare NOT sanitized!!! For this reason you should never under any circumstance pass in a value you receive from a user into one of those fields!\nDoing so will leave a huge security hole in your app that an attacker could take advantage of to destroy or compromise everything.  Below is a  SAFE  query:  // Create and execute query\n$db ->select('name')\n    ->from('users')\n    ->where('name', $_POST['userName']);\n$query = $db->exec();  Below is an  EXTREMELY UNSAFE  query:  // Create and execute query\n$db ->select('name')\n    ->from('users')\n    ->where($_POST['column'], $_POST['value']);\n$query = $db->exec();",
            "title": "Security"
        },
        {
            "location": "/documentation/databaseclass/overview/#methods",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/documentation/databaseclass/overview/#utility-methods",
            "text": "The following methods are available when creating any type of query:   getQuery()  (returns the compiled query)  exec()  (executes the query that's been constructed and calls Reset)  reset()  (resets the Database class so it's ready for a new query)",
            "title": "Utility Methods"
        },
        {
            "location": "/documentation/databaseclass/overview/#select-statements",
            "text": "The methods available when creating a select statement are:   select()  distinct()  from()  join()  where()  orWhere()  in()  groupBy()  having()  orHaving()  orderBy()  limit()  offset()",
            "title": "SELECT Statements"
        },
        {
            "location": "/documentation/databaseclass/overview/#update-statements",
            "text": "The methods available when creating an update statement are:   update()  set()  where()",
            "title": "UPDATE Statements"
        },
        {
            "location": "/documentation/databaseclass/overview/#insert-statements",
            "text": "The methods available when creating an insert statement are:   insert()  into()  values()",
            "title": "INSERT Statements"
        },
        {
            "location": "/documentation/databaseclass/overview/#delete-statements",
            "text": "The methods available when creating an delete statement are:   delete()  from()  where()",
            "title": "DELETE Statements"
        },
        {
            "location": "/documentation/databaseclass/overview/#create-statements",
            "text": "The methods available when creating an create statement are:   create()  field()  primaryKey()  foreignKey()",
            "title": "CREATE Statements"
        },
        {
            "location": "/documentation/databaseclass/overview/#advanced-examples",
            "text": "Creating a table:  $db ->create('locations')\n            ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n            ->field('name', 'varchar(255)')\n            ->field('address', 'varchar(255)')\n            ->field('user_id', 'int')\n            ->primaryKey('id')\n            ->foreignKey('user_id', 'users', 'id');\n$db->exec();  Inserting data:  $db ->insert('name, email, type')\n    ->into('users')\n    ->values([\n        ['bob', \"bob's@gmail.com\", 'admin'],\n        ['john', 'john@gmail.com', 'admin'],\n        ['john', 'john@gmail.com', 'scrub'],\n        ['sally', 'sally@yahoo.com', 'user'],\n        ['susan', 'susan@aol.com', 'user']\n    ])\n    ->exec();  More advanced Where statement:  $db ->select('id')\n    ->distinct()\n    ->from('users')\n    ->from('profile')\n    ->where([\n        ['created_time', '>=', '2016-01-01', 'OR'],\n        ['name', 'LIKE', 's%']\n    ])\n    ->where([\n        ['type', '=', 'admin', 'OR'],\n        ['type', '=', 'moderator']\n    ])\n    ->exec();  Mega Query:  $tables = array('table1', 'table2', 'table3');\n$fields = array('id', 'name', 'email');\n$conditions = array(\n    ['id', '>', '100', 'OR'],\n    ['name', 'LIKE', '%s']\n);\n\n$groupBys = ['field1', 'field2', 'field3'];\n\n$havings = array(\n    ['amount', '>', '1000'],\n    ['savings', '>', '100']\n);\n\n$orHavings = array(\n    ['amount2', '>', '1000'],\n    ['savings2', '>', '100']\n);\n\n$joinConditions = array(\n    ['Orders.customerID', '=', 'Customers.customerID'],\n    ['User.type', '=', 'Customer.type']\n);\n\n\n$db = new Cora\\Db_MySQL();\n\necho $db->select($fields)\n        ->from($tables)\n        ->join('customers', $joinConditions, 'OUTER')\n        ->where($conditions)\n        ->orWhere($conditions)\n        ->in('name', 'value1, value2, value3')\n        ->in('name', 'SELECT * FROM users')\n        ->in('type', $groupBys)\n        ->groupBy($groupBys)\n        ->having($havings)\n        ->orHaving($orHavings)\n        ->having($orHavings)\n        ->orderBy('name', 'DESC')\n        ->orderBy('type', 'ASC')\n        ->limit(10)\n        ->offset(20)\n        ->getQuery();",
            "title": "Advanced Examples"
        },
        {
            "location": "/documentation/mvc/overview/",
            "text": "",
            "title": "Overview"
        },
        {
            "location": "/documentation/mvc/models/",
            "text": "Description of models in the generic MVC sense.",
            "title": "Models"
        },
        {
            "location": "/documentation/mvc/views/",
            "text": "",
            "title": "Views"
        },
        {
            "location": "/documentation/mvc/controllers/",
            "text": "",
            "title": "Controllers"
        },
        {
            "location": "/documentation/mvc/libraries/",
            "text": "$lib = new \\Library\\TestLib();\n\n\n\n\n$this->load->library('Validate', $this, true);",
            "title": "Libraries"
        },
        {
            "location": "/documentation/routing/overview/",
            "text": "",
            "title": "Routing"
        },
        {
            "location": "/documentation/amblend/overview/",
            "text": "What is AmBlend?\n\n\nTL;DR It makes grabbing objects from and saving objects to a database super easy.\n\n\nIn short, AmBlend is the ORM tool developed for, and included with Cora.\nAn ORM (Object Relational Mapping) tool is something that handles moving data to and\nfrom objects and the database. This is useful when doing OO (object oriented) programming\nas it allows developers to focus on the core functionality and features of their application\nand not on the nitty-gritty grunt work of how to fetch and persist (aka 'save') data. This generally results\nin less code that needs to be written, and faster development times.\n\n\nAs an added bonus, using AmBlend allows Cora to build your database for you automatically\nbased on the definitions of your models, if you so desire.\n\n\nHow Does AmBlend Differ From Other ORMs?\n\n\nORM implementations basically boil down into two basic types: Active-Record or Data-Mapper.\nBoth have their pros and cons, but AmBlend was designed as a \"blend\" of both approaches ('AM'\nshort for Active-record and data-Mapper) with the goal of taking the best aspects of each and blending them\ninto a new paradigm. Below are the stereotypical strengths and weaknesses of each approach compared to AmBlend:\n\n\n\n  \n\n    \nProperty:\n\n    \nActive-Record\n\n    \nData-Mapper\n\n    \nAmBlend\n\n  \n\n  \n\n    \nEasy to Setup\n\n    \nYes\n\n    \nNo\n\n    \nYes\n\n  \n\n  \n\n    \nEasy to Use\n\n    \nYes\n\n    \nNo\n\n    \nYes\n\n  \n\n  \n\n    \nEasy to Test\n\n    \nNo\n\n    \nYes\n\n    \nYes\n\n  \n\n  \n\n  \nSRP\n Compliant\n\n    \nNo\n\n    \nYes\n\n    \nYes\n\n  \n\n  \n\n    \nDomain and Database Separation\n\n    \nNo\n\n    \nYes\n\n    \nYes\n\n  \n\n  \n\n    \nPerformance Optimization\n\n    \nDepends\n\n    \nDepends\n\n    \nYes*\n\n  \n\n\n\n\n\n*\n As much as possible, flexibility and optimization were kept in mind when building AmBlend. An explanation of the specific optimizations\nin place can be found in the optimizations section.\n\n\nFor more information about how AmBlend is implemented, see AmBlend's \"Implementation\" page.\n\n\nHow-to-Use Basics\n\n\nFirst you need to have your models extend from Cora's Model class, and add an associative array\nwhich defines the attributes of that model. See below for an example User model\nwhich has an ID, a couple strings in Name and Email, and a Job attribute which\nis another model representing the job of this user.\n\n\n\n\nDefine some Cora models:\n\n\nclass User extends \\Cora\\Model {\n\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar'\n        ],\n        'job' => [\n            'model' => 'job'\n        ]\n    ];\n\n    public function __construct($name = null, $email = null)\n    {\n        $this->name = $name;\n        $this->email = $email;\n    }\n}\n\nclass Job extends \\Cora\\Model {\n\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'title' => [\n            'type' => 'varchar'\n        ],\n        'description' => [\n            'type' => 'varchar'\n        ]\n    ];\n\n    public function __construct($title = null, $description = null)\n    {\n        $this->title = $title;\n        $this->description = $description;\n    }\n}\n\n\n\n\nNotice you didn't have to use any special comments with @ symbols or anything else;\nyou inform Cora about what your model's attributes are using a normal array.\nFurthermore, there's nothing special about the constructors (you can write them\njust like you would any other class), AND there's nothing special about the\nproperties of a model either. If you want to add additional normal properties\nto the model that's all\nperfectly fine. All that's important to know is that unless a property is defined\nin the \"model_attributes\" array, AmBlend won't try to save it to a database.\nTo say that another way, you can add whatever properties you want\nto a model, AmBlend will just ignore them unless you also add that property to the\nmodel_attributes array. In that sense, you can use and create Cora models just\nlike you would any normal class. The only thing you need to be careful of is to not override\nthe _ \n get() and _ \n set() methods.\n\n\nNext you need to create your database(s).\n\n\n\n\nCreate Your Database:\n\n\nThe easiest way to create your database is to use AmBlend's automated database\ncreation tool! In order to take advantage of this feature, you need to make sure\nyou've setup your database configuration. If you haven't done that yet,\n\nClick Here\n to view\ninstructions on doing so. The other thing you'll need (as of me writing this),\nis command line access. In the future, an in-browser\nvisual interface to the database creation tool may be added, but for now it's just\na command line tool.\n\n\n\n\n\nIf on a shared hosting environment:\n  \n\nBecause the database creation feature is a command line tool...\nwhat this means for people who will be hosting their app in\na shared hosting environment without command line access is that you'll need to\ngenerate your database on your local machine and then use a tool (such as PhpMyAdmin)\nto export your generated database into an SQL file you can upload.\n\n\n\n\nTo automatically generate a database based on your model definitions you need\nto do the following:\n\n\n\n\nOpen a Terminal.\n\n\nIf on a Mac, open your Applications, click the Utilities folder, and then\nselect the \"Terminal\" application.\n\n\nIf on a PC, hit your Windows Key + R to open the \"Run\" window, then type\nin \"cmd\" and hit enter.\n\n\nIf on Linux you don't need me to tell you how to do this, but since I can't\nhelp myself I'll mention that Ubuntu and Mint both map the terminal to\nCtrl+Alt+T.\n\n\n\n\n\n\nNavigate to your project's directory.\n\n\nIf you are XAMPP, MAMP, etc, that will likely be wherever you installed\nthat and then in the \"htdocs\" folder within.\n\n\n\n\n\n\nOnce at the root of your project, type \"php Amblend.php dbBuild\" to have\nAmBlend build your database for you.\n\n\nIf you get an error about PHP not being a recognized command, that means\nPHP is not a part of your operating system's PATH. Google \"add php to path\"\nor something similar if you aren't sure how to do this.\n\n\n\n\n\n\n\n\nIf all went well, you should see a flurry of output to the console and your database\nshould be ready to go!\n\n\nOf course, if you want to read through the documentation\nin the Models page to fully understand how the mappings work for the purpose of\nsetting your database(s) up manually, you can, although that takes more expertise\nand effort.\n\n\n\n\nStart Using AmBlend:\n\n\nAnd ... wait for it ... congratulations! You're now ready to start using AmBlend.\nSo we're all good to go, but how do we actually fetch models from and save models\nto the database? The answer is we need to use a Repository.\nSee below for an example Users controller where we use AmBlend to interact with\nour database. This Users controller will be very simple, we'll just have a method\nfor registering a new user, and an ultra simple Profile method that just echoes\nout the user's job title.\n\n\nUsing AmBlend in a Controller:\n\n\nclass Users extends \\MyApp\n{\n    protected $repo;\n    protected $db;\n\n    public function __construct()\n    {\n        parent::__construct();\n        $this->repo = \\Cora\\RepositoryFactory::make('User');\n    }\n\n    /**\n     *  Create a new user.\n     */\n    public function register()\n    {\n        // Grab our inputs. We'll just use fake data instead of\n        // actually capturing it from a form.\n        $name = 'Bob';                // $this->input->post('name');\n        $email = 'Bob@fakeEmail.com'; // $this->input->post('email');\n\n        // Create a new User.\n        $user = new User($name, $email);\n\n        // Assign the user a job.\n        $user->job = new Job('Athlete', 'Track and Field');\n\n        // Save the user to the database.\n        $this->repo->save($user);\n\n        // When the user was saved to the database, AmBlend\n        // assigned the object the unique ID the database provided it.\n        // Let's echo this user's ID.\n        echo $user->id;\n    }\n\n    /**\n     *  Display a user's profile.\n     *  In this case, just echo their job title.\n     */\n    public function profile($id)\n    {\n        $user = $this->repo->find($id);\n        echo $user->job->title;\n    }\n}\n\n\n\n\nIf you have the Cora demo project installed, you can run this code and see it\nworking in action. First you'll want to go to:\n\n\nhttp://localhost/{myProjectName}/users/register\n\n\n\n\n^ Replace \"{myProjectName}\" with the name of the folder your Cora demo project\nis in. This should create our user \"Bob\" and then echo out to the browser\nthe ID number assigned to him. If you use that ID, you can then go to the profile\npage at:\n\n\nhttp://localhost/{myProjectName}/users/profile/{id}\n\n\n\n\n^ Where {id} is the ID of Bob. If Bob's ID is \"2\":\n\n\nhttp://localhost/{myProjectName}/users/profile/2\n\n\n\n\nAnd just like that, AmBlend saved our user Bob to the database as represented\nby the User object, saved a separate Job object to the database that represents\nthe job Bob does, and automatically handled setting up the associations for you\nbetween the objects. This is why you can do:\n\n\necho $user->job->title;\n\n\n\n\non the profile page and have it work so effortlessly. Behind-the-scenes\nAmBlend is doing all the heavy-lifting busy work for you to make saving and\nretrieving objects along with any other objects associated with them a breeze.\n\n\n\n\nExplanation Pitstop:\n \n\nSo the one thing I didn't talk about in the code above is what's happening\nin the constructor for our Users controller where we are creating our Repository object.\n\n\nIn programming lingo a \"factory\" is a class that handles creating objects for you.\nThe easiest way to get a Repository of a certain type is to use Cora's RepositoryFactory\nclass' Make method and telling it what type of repository you want to create.\nSo the code as seen below is just the simplest way of creating a User class repository:\n\n\n$this->repo = \\Cora\\RepositoryFactory::make('User');\n\n\n\n\nFor more information about the Repository, Gateway, Factory pattern I recommend\nreading the documentation page for each under the AmBlend ORM section.\n\n\n\n\nOptimizing Performance\n\n\nOk, now that's we've seen the bare basics of how AmBlend works, let's talk for a minute\nabout how it tries to make your app lean and fast. In general, ORMs get a bad rap\nfor being inefficient, and rightfully so. I've read the horror stories of engineers\ncalled in to speed up programs only to find out the ORM used by the program is spitting\nout super ugly and inefficient queries that are like trying to kill a fly with a\nheavy machine gun! In terms of AmBlend, my goal here is to describe\nexactly how it works so you can make your own judgements about when or when not to use it.\n\n\n\"Light\" Classes:\n\n\nFirst up, when grabbing data from a row in the database for the purpose of populating\nan object, by default, AmBlend will grab all the data in that row. That is to say:\n\n\n$user = $this->repo->find($id);\n\n\n\n\nIs the SQL equivalent to doing:\n\n\nSELECT * FROM users WHERE id = :id\n\n\n\n\nOne of the optimizations in AmBlend is the ability to dynamically create \"light\"\nversions of a class by not grabbing all the class data, and instead only grabbing\nthe data you need. This is possible because AmBlend uses Cora's Database class\nto interact with the persistence layer, and allows you to pass a partial query\nalong to the repository when asking for models. See below for example. You can\nadd the following method to the Users controller we previously used to see this in\naction:\n\n\npublic function lightClassDemo($id)\n{\n    $this->db->where('id', $id);\n    $this->db->select(['id', 'name']);\n    $user = $this->repo->findOne($this->db);  \n    var_dump($user);\n}\n\n\n\n\nIs equivalent to doing:\n\n\nSELECT id, name FROM users WHERE id = :id\n\n\n\n\nWhat we're leaving out here is the user's email and their job, maybe because whatever we're\ndoing with the object doesn't require that info. It's a general rule when optimizing\nperformance to only grab what you need, and with this functionality, AmBlend\ngives you that capability.\n\n\n(Note that you can use findAll() to similarly fetch\na collection of \"light\" objects.)\n\n\nCollection Subsets:\n\n\nAlright, say you want to print out a list of users, but you don't want to list all\nusers, just the ones that are Admins. Using the same methodology we\nused in the previous section to create a \"light\" version of a class, we can also\nlimit the objects we are grabbing to a subset of a whole collection. (Note: this\nexample assumes there's some sort of \"type\" attribute on the user model):\n\n\npublic function subsetDemo()\n{\n    $this->db->where('type', 'Admin');\n    $users = $this->repo->findAll($this->db);\n\n    foreach ($users as $user) {\n        echo $user->name.'<br>';\n    }\n}\n\n\n\n\nThis is yet another example of how AmBlend let's you only fetch the data you need,\nso you aren't wasting system resources.\n\n\nDynamic Loading\n\n\nAKA - How related objects are fetched:\n\n\nAlright, now that we've talked about how data on the class' main table can be limited\n(\"light\" classes) and how repositories can be asked to return only a subset of\nobjects in a collection... let's continue our discussion of performance by going\nover HOW AmBlend grabs related objects.\n\n\nBy \"related objects\" what I'm referring to is say the Job object associated with\na user from one of our previous examples on this page. Another example would be\nif you were creating a blogging site and each user had a collection of \"articles\"\nthey've written where each article is its own object. If you are an experienced\ndeveloper who's concerned about performance, how AmBlend grabs these related objects\nfrom a database is something you should know.\n\n\nThe answer to that question is that AmBlend only grabs related objects \"on-demand\"\nutilizing what I call Dynamic Loading. The way in which this is done varies a little\nbit depending on how the data is stored, but all follows the same concept.\nGoing back to the \"User has a Job\" example, the way we defined the Job attribute\non our User model as a simple, single related object means that our Users table\nwill have a \"job\" column that stores the ID of that user's job.\n\n\n\n\nIn the case of Bob as seen in the image of his Users table entry above, grabbing\nhis whole user object and doing a var_dump as seen in this code:\n\n\npublic function profile($id)\n{\n    $user = $this->repo->find($id);\n    var_dump($user);\n}\n\n\n\n\nHas the following applicable output:\n\n\nprotected 'model_data' =>\n    array (size=5)\n      'name' => string 'bob' (length=3)\n      'type' => string 'admin' (length=5)\n      'id' => string '1' (length=1)\n      'email' => string 'bob@fakeEmail.com' (length=17)\n      'job' => string '3' (length=1)\n\n\n\n\nAs you can see, the \"job\" attribute is NOT an object at this point, it's just\nan ID number that references a job object. However, through the power of AmBlend's\ndynamic loading, if you try and access Bob's job property, it will be fetched\nfrom the persistence layer and an object will replace the ID. To see this in\naction, let's echo out Bob's job title, and then do a var_dump afterwards to see\nthe difference:\n\n\npublic function profile($id)\n{\n    $user = $this->repo->find($id);\n    echo $user->job->title;\n    var_dump($user);\n}\n\n\n\n\nAnd the result of the var_dump now looks like:\n\n\nprotected 'model_data' =>\n    array (size=5)\n      'name' => string 'bob' (length=3)\n      'type' => string 'admin' (length=5)\n      'id' => string '1' (length=1)\n      'email' => string 'bob@fakeEmail.com' (length=17)\n      'job' =>\n        object(Job)[11]\n          public 'model_attributes' =>\n            array (size=3)\n              ...\n          protected 'model_data' =>\n            array (size=3)\n              ...\n\n\n\n\nAs you can see, the \"job\" attribute is no longer just an ID, it's been replaced\nby a full Job object!\n\n\n\n\nFor object collections or single objects that use a relation table:\n\n\nThis works similarly, but slightly different for related objects that use a\nrelation table or an \"owner\" type column on the related object's table. If Bob's\nUser table entry looked like this:\n\n\n\n\n(Notice the lack of a \"job\" column)\n\n\nAnd Jobs were getting related to Users by utilizing a separate relation table,\nthen the var_dump on User would look like this:\n\n\nprotected 'model_data' =>\n    array (size=5)\n      'name' => string 'bob' (length=3)\n      'type' => string 'admin' (length=5)\n      'id' => string '1' (length=1)\n      'email' => string 'bob@fakeEmail.com' (length=17)\n      'job' => int 1\n\n\n\n\nIn this scenario, the \"job\" attribute is NOT the ID of the related job object,\nbut rather just a boolean placeholder to let AmBlend's Dynamic Loading system know that\na related job exists, and that if Job is called for, it needs to use the reference\ntable to go fetch it!\n\n\nThis is obviously a slight difference, but one that could trip you up if you\ndon't realize how it's working.\n\n\n\n\nPerformance considerations of dynamic loading:\n\n\n\n    WARNING: So the info I'm about to talk about below is intended for experienced\n    enterprise-level developers! It's very \"nitty-gritty\", so don't say I didn't\n    warn you. If you get lost, don't worry, just skip this section.\n\n\n\n\nAlright, now that you should have an understanding of how AmBlend grabs related\nobjects (\"on-demand\" using dynamic loading), you can weigh the performance cost.\nOn one hand, the fact that AmBlend grabs only as little data as possible and grabs\nextra stuff as needed helps keep your objects lean. However, because a separate\nquery is run each time you need to fetch a related object, this has the potential\nto bombard your database with hundreds or even thousands of small queries for\nindividual objects. For example, let's pretend we have 1,000 users in our\nusers table and we execute the following code on a Users repository:\n\n\n// Fetches ALL users\n$users = $this->repo->findAll();\n\nforeach ($users as $user) {\n    echo $user->job->title;\n}\n\n\n\n\nThe loop will run 1,000 times, and since each Job will be fetched\nindividually using a separate query at the time it tries to get accessed, it will\nresult in the equivalent of 1,000 of these queries:\n\n\nSELECT * FROM jobs WHERE `id` = :id\n\n\n\n\nI'm not a database mega-expert, but I'm sure that doing\n1,000 small queries is less efficient than if you just did one larger query to\ngrab all the data you needed in one go. Maybe if you consider the fact that you'd\nthen have to loop through the results of the larger query to assign each row of\ndata to an object it might come out as a wash, but that's for you to decide and\nnot me. The point I want to communicate is that this is how it works when you\ntry and access related objects to whatever the primary object you're using is.\n\n\nIf you wanted to grab all the Jobs from the database and have AmBlend return\nthem for you as objects, but you DON'T want to go through that process of executing\n1,000 individual queries... you have a few options:\n\n\n\n\nAvoiding Lots of Mini-Queries - Option #0:\n\n\n(Yes, I did just call this option zero. On purpose.)\n\n\nThe fact of the matter is, looping through 1,000 users and accessing information\nabout each, is not a typical usage example. If you're building an object oriented\nreporting system, I could see this being the case, but in 95% of situations you're\nprobably iterating over a small collection. If you are making some sort of users\nlist, chances are you'll be using a pagination setup, and so you probably only\nneed to loop over a few dozen users at a time.\n\n\nIf you're building say a Forum post system, again you're probably only iterating\nover a few dozen users, and using a pagination system again if things get too long.\n\n\nIn my experience exploring things such as string matching algorithms,\nwhen dealing with small data sets, a simple brute-force solution\nusually performs as well or better than a fancy more eloquent one due to the\noverhead cost of setting up fancy solutions.\n\n\nSo if you're concerned about performance, do a little testing. You might find\nthe simplest option may be the best option.\n\n\n\n\nAvoiding Lots of Mini-Queries - Option #1:\n\n\nYou can just create a Jobs repository and ask for all the jobs. This will execute\na single query to fetch a collection of all the Jobs. The downside here is that\nunless you create a backwords reference from a Job to a User (our example from earlier on\nthis page didn't have one), you won't know what User(s) that Job is associated with.\nAlso worth noting, if you end up adding a backreference and using it, you might\nend up in the same individual queries situation.\n\n\nBut depending on what you're doing, just grabbing all the jobs this way and then\nmaybe doing some mapping between the collection of Jobs and the collection of Users\n(if necessary for the task) could be an option.\n\n\n\n\nAvoiding Lots of Mini-Queries - Option #2:\n\n\nIf you don't need the full related object, but just a piece of information from it,\nyou can add a join to the Repository query. For instance, let's say you don't need\nthe full Job object, but just need a user's job title. You can do the following:\n\n\npublic function joinDemo($id)\n{\n    $this->db->where('users.id', $id)\n             ->select(['users.id', 'users.name', 'jobs.title as job_title'])\n             ->join('ref_users_jobs', [['users.id', '=', 'ref_users_jobs.user']])\n             ->join('jobs', [['ref_users_jobs.job', '=', 'jobs.id']]);\n    $user = $this->repo->findOne($this->db);  \n    echo $user->job_title;\n}\n\n\n\n\n(NOTE: the above example is taken directly from the Cora demo project and Jobs are related\n    to Users via a relation table - which is different from our previous example on\n    this page where a Job ID was stored directly in the Users table)\n\n\nLooking at the select() method above, in addition to grabbing the user's ID and\nname, we are also doing some joins and then grabbing the user's job title.\nSince \"job_title\" is NOT defined in the User class attributes definition, AmBlend\nwill pass it into the object as a property, but it will not do anything further.\nWhat this means is that if you alter the title and then tell AmBlend to save\nthis user, the job title will NOT get saved since it's not technically part of the class\ndefinition. The job title is just merely extra data you asked AmBlend to grab, which it did.\n\n\nThis can be useful if you just need some simple read-only data about a user though!\nAs you can see in the code snippet above we were able to\necho out the title. I'm sure if you're an experienced developer and reading this\nyou can see how this could be useful as long as you're careful about when/how you\nuse it. It's just important to keep in mind that any object properties not defined\nin the model_attributes array are ignored when an object is saved.\n\n\nIt's also worth noting here that a (probably more convenient) way of doing the same\nthing is to utilize a model's lifecycle hooks to run some custom queries when a\nmodel is fetched or saved! By doing so you can fetch the extra data anytime you\nwould normally fetch an instance of the model, and you can save the extra data\nwhenever you tell a repository to save it. See the LifeCycle Hooks section for\nmore information.\n\n\n\n\nAvoiding Lots of Mini-Queries -  Option #3:\n\n\nYou can pass a custom built Gateway to a Repository that does whatever queries you\nwant and manipulates data in whatever way you want. AmBlend is great because it\nhandles the generic day-to-day fetching and persisting of objects for you, which is\nreally nice, BUT that doesn't mean you can't override its default behavior if you need\nto handle more complicated tasks. See the section below on how you can modify or\nreplace the default Gateway (the class in charge of fetching data from the persistence layer)\nwith a custom one of your own making.\n\n\nLimiting Resource Creation\n\n\nAnother optimization made in AmBlend is statically declared data when possible.\nSpecifically, since most apps are likely created using a single\ndatabase, the default database adaptor is stored statically. What this means is\nthat each time you trigger something like Dynamic Loading on an object that uses\nthe app's default database, AmBlend isn't creating a new database object each time,\nbut rather using the statically stored version if it exists. This means less\nwork to get setup.\n\n\nIt's a small thing, but every little improvement helps in the long run.\n\n\nOverriding Default Behavior\n\n\nSo one of the criticisms of the ActiveRecord pattern is it ties an object too\nclosely to a single table, and doesn't give the flexibility in how an object\nis fetched and saved that a developer might want. In most cases, this really isn't a problem (ActiveRecord\nis the most popular ORM pattern in use as of this writing to my knowledge after all).\nIn addition, as you've probably noticed if you've read this far down the page,\ngrabbing related objects from various different tables is an absolute BREEZE using\nAmBlend! However, there still may be situations that come up where a developer\nfeels the need for advanced models that are composed of direct data from multiple\ntables (\"direct data\" meaning numbers, strings, dates, etc).\n\n\nThe first thing I would caution a developer if they feel like they need to do this\nis to sleep on it, and re-examine what they're trying to accomplish. Does your\nobject REALLY need its data grabbed from multiple tables/sources? Can the data you\nwant to grab from a 2nd table be grabbed from a related object, rather than shoving it\ninto your current one? What about just doing a good old fashioned direct query\nusing Cora's database class? There are lifecycle hooks you can use when fetching\nor saving a model to run your custom query for fetching/saving this extra data.\nThe point I'm trying to make is that the option I'm going to share below,\nyou probably don't ever need to use... but I'll share it anyway because\nknowledge is power... or something like that.\n\n\nWriting Your Own Gateway:\n\n\nAlright, I'm not actually going to go into too much depth on this, as if you're\na developer who feels the need to write your own Gateway for fetching/persisting\nan object, you probably are pretty competent in your knowledge and skills. Instead\nI'll just gloss over the high-level process of doing this in Cora to save you\ntime having to dig as much into the code.\n\n\nThe steps I would take are as follows:\n\n\n\n\nEither extend Cora's Gateway class and override whatever method(s) you want,\n or copy+paste the existing class into a new file, delete the contents of the methods,\n and save it as whatever you want (something like \"UserGateway\" would make sense for\n a User class). Obviously don't forget to implement the methods with your own code.\n\n\nNow that you have your fancy custom Gateway ready to go, you just need to pass\n it into a Repository in place of the default one included in Cora. The way to\n go about doing this is to NOT use the RepositoryFactory like we've been using in\n our examples, and instead just go through the simple process of initializing a\n Repository for yourself like so:\n\n\n\n\n// Create the Factory and Gateway the repository will use.\n$factory = new Factory($class);\n$gateway = new UserGateway(...insert your parameters...);\n\n// Pass a gateway and factory to the repository.\n$repo    = new Repository($gateway, $factory);\n\n\n\n\nAs you can see, the process of replacing the gateway for an object repository is\ntrivial. The hard part is actually implementing the custom Gateway. Anyways, that's\nthe gist of it... happy coding!\n\n\nTesting\n\n\nAlright, the first important thing to realize about AmBlend when considering testing\nis the Data-Mapper pattern it follows. Because the logic to persist a model is\nseparate from the model itself, you can do any of the following as suits your needs\nfor testing:\n\n\n\n\nYou can use a test Gateway to return fixed dummy data (see the \"writing your\n own gateway\" description above for more info). If you plan on leaving Dynamic Loading\n on, you'll also need to pass in to the Factory a database object you want used\n for testing (Dynamic Loading will use that DAO).\n\n\nYou can pass in a database object to a Test database connection in order to grab\n your testing data. This would look like so, where you need to pass the database object\n to both the Factory and Gateway:\n\n\n\n\n$db = \\Cora\\Database::getDb('name_of_test_db_connection');\n$class = 'User';\n$factory = new Factory($class, $db);\n$gateway = new Gateway($db);\n$repo    = new Repository($gateway, $factory);\n\n\n\n\n\n\nAnd last but not least, you can just create classes of whatever model you need\n by hand (not using the Repository/Gateway/Factory) and populate them with whatever\n you want. This works because Cora models are just normal everyday classes that you\n can use just like any other class. The one thing you'll want to be sure to do in this\n situation though is to turn off Dynamic Loading (see below).\n\n\n\n\nTurning off Dynamic Loading:\n\n\nLet's quickly talk about Dynamic Loading and how to turn it off. You'll\nrecall from previous discussions that Dynamic Loading is a nifty little feature\nthat allows a model to request additional related objects from a Repository on-demand.\nIf you are expecting this behavior, and want the model to be able to request related\nmodels on-demand, you don't need to do anything and can just leave this feature on.\nHowever, if you want full control over the model, and would like to turn Dynamic Loading\noff, you just need to flip the following boolean on the model:\n\n\n$user = $this->repo->find($id);\n$user->model_dynamicOff = true;",
            "title": "Overview"
        },
        {
            "location": "/documentation/amblend/overview/#what-is-amblend",
            "text": "TL;DR It makes grabbing objects from and saving objects to a database super easy.  In short, AmBlend is the ORM tool developed for, and included with Cora.\nAn ORM (Object Relational Mapping) tool is something that handles moving data to and\nfrom objects and the database. This is useful when doing OO (object oriented) programming\nas it allows developers to focus on the core functionality and features of their application\nand not on the nitty-gritty grunt work of how to fetch and persist (aka 'save') data. This generally results\nin less code that needs to be written, and faster development times.  As an added bonus, using AmBlend allows Cora to build your database for you automatically\nbased on the definitions of your models, if you so desire.",
            "title": "What is AmBlend?"
        },
        {
            "location": "/documentation/amblend/overview/#how-does-amblend-differ-from-other-orms",
            "text": "ORM implementations basically boil down into two basic types: Active-Record or Data-Mapper.\nBoth have their pros and cons, but AmBlend was designed as a \"blend\" of both approaches ('AM'\nshort for Active-record and data-Mapper) with the goal of taking the best aspects of each and blending them\ninto a new paradigm. Below are the stereotypical strengths and weaknesses of each approach compared to AmBlend:  \n   \n     Property: \n     Active-Record \n     Data-Mapper \n     AmBlend \n   \n   \n     Easy to Setup \n     Yes \n     No \n     Yes \n   \n   \n     Easy to Use \n     Yes \n     No \n     Yes \n   \n   \n     Easy to Test \n     No \n     Yes \n     Yes \n   \n   \n   SRP  Compliant \n     No \n     Yes \n     Yes \n   \n   \n     Domain and Database Separation \n     No \n     Yes \n     Yes \n   \n   \n     Performance Optimization \n     Depends \n     Depends \n     Yes* \n     *  As much as possible, flexibility and optimization were kept in mind when building AmBlend. An explanation of the specific optimizations\nin place can be found in the optimizations section.  For more information about how AmBlend is implemented, see AmBlend's \"Implementation\" page.",
            "title": "How Does AmBlend Differ From Other ORMs?"
        },
        {
            "location": "/documentation/amblend/overview/#how-to-use-basics",
            "text": "First you need to have your models extend from Cora's Model class, and add an associative array\nwhich defines the attributes of that model. See below for an example User model\nwhich has an ID, a couple strings in Name and Email, and a Job attribute which\nis another model representing the job of this user.",
            "title": "How-to-Use Basics"
        },
        {
            "location": "/documentation/amblend/overview/#define-some-cora-models",
            "text": "class User extends \\Cora\\Model {\n\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar'\n        ],\n        'job' => [\n            'model' => 'job'\n        ]\n    ];\n\n    public function __construct($name = null, $email = null)\n    {\n        $this->name = $name;\n        $this->email = $email;\n    }\n}\n\nclass Job extends \\Cora\\Model {\n\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'title' => [\n            'type' => 'varchar'\n        ],\n        'description' => [\n            'type' => 'varchar'\n        ]\n    ];\n\n    public function __construct($title = null, $description = null)\n    {\n        $this->title = $title;\n        $this->description = $description;\n    }\n}  Notice you didn't have to use any special comments with @ symbols or anything else;\nyou inform Cora about what your model's attributes are using a normal array.\nFurthermore, there's nothing special about the constructors (you can write them\njust like you would any other class), AND there's nothing special about the\nproperties of a model either. If you want to add additional normal properties\nto the model that's all\nperfectly fine. All that's important to know is that unless a property is defined\nin the \"model_attributes\" array, AmBlend won't try to save it to a database.\nTo say that another way, you can add whatever properties you want\nto a model, AmBlend will just ignore them unless you also add that property to the\nmodel_attributes array. In that sense, you can use and create Cora models just\nlike you would any normal class. The only thing you need to be careful of is to not override\nthe _   get() and _   set() methods.  Next you need to create your database(s).",
            "title": "Define some Cora models:"
        },
        {
            "location": "/documentation/amblend/overview/#create-your-database",
            "text": "The easiest way to create your database is to use AmBlend's automated database\ncreation tool! In order to take advantage of this feature, you need to make sure\nyou've setup your database configuration. If you haven't done that yet, Click Here  to view\ninstructions on doing so. The other thing you'll need (as of me writing this),\nis command line access. In the future, an in-browser\nvisual interface to the database creation tool may be added, but for now it's just\na command line tool.   If on a shared hosting environment:   \n\nBecause the database creation feature is a command line tool...\nwhat this means for people who will be hosting their app in\na shared hosting environment without command line access is that you'll need to\ngenerate your database on your local machine and then use a tool (such as PhpMyAdmin)\nto export your generated database into an SQL file you can upload.  To automatically generate a database based on your model definitions you need\nto do the following:   Open a Terminal.  If on a Mac, open your Applications, click the Utilities folder, and then\nselect the \"Terminal\" application.  If on a PC, hit your Windows Key + R to open the \"Run\" window, then type\nin \"cmd\" and hit enter.  If on Linux you don't need me to tell you how to do this, but since I can't\nhelp myself I'll mention that Ubuntu and Mint both map the terminal to\nCtrl+Alt+T.    Navigate to your project's directory.  If you are XAMPP, MAMP, etc, that will likely be wherever you installed\nthat and then in the \"htdocs\" folder within.    Once at the root of your project, type \"php Amblend.php dbBuild\" to have\nAmBlend build your database for you.  If you get an error about PHP not being a recognized command, that means\nPHP is not a part of your operating system's PATH. Google \"add php to path\"\nor something similar if you aren't sure how to do this.     If all went well, you should see a flurry of output to the console and your database\nshould be ready to go!  Of course, if you want to read through the documentation\nin the Models page to fully understand how the mappings work for the purpose of\nsetting your database(s) up manually, you can, although that takes more expertise\nand effort.",
            "title": "Create Your Database:"
        },
        {
            "location": "/documentation/amblend/overview/#start-using-amblend",
            "text": "And ... wait for it ... congratulations! You're now ready to start using AmBlend.\nSo we're all good to go, but how do we actually fetch models from and save models\nto the database? The answer is we need to use a Repository.\nSee below for an example Users controller where we use AmBlend to interact with\nour database. This Users controller will be very simple, we'll just have a method\nfor registering a new user, and an ultra simple Profile method that just echoes\nout the user's job title.  Using AmBlend in a Controller:  class Users extends \\MyApp\n{\n    protected $repo;\n    protected $db;\n\n    public function __construct()\n    {\n        parent::__construct();\n        $this->repo = \\Cora\\RepositoryFactory::make('User');\n    }\n\n    /**\n     *  Create a new user.\n     */\n    public function register()\n    {\n        // Grab our inputs. We'll just use fake data instead of\n        // actually capturing it from a form.\n        $name = 'Bob';                // $this->input->post('name');\n        $email = 'Bob@fakeEmail.com'; // $this->input->post('email');\n\n        // Create a new User.\n        $user = new User($name, $email);\n\n        // Assign the user a job.\n        $user->job = new Job('Athlete', 'Track and Field');\n\n        // Save the user to the database.\n        $this->repo->save($user);\n\n        // When the user was saved to the database, AmBlend\n        // assigned the object the unique ID the database provided it.\n        // Let's echo this user's ID.\n        echo $user->id;\n    }\n\n    /**\n     *  Display a user's profile.\n     *  In this case, just echo their job title.\n     */\n    public function profile($id)\n    {\n        $user = $this->repo->find($id);\n        echo $user->job->title;\n    }\n}  If you have the Cora demo project installed, you can run this code and see it\nworking in action. First you'll want to go to:  http://localhost/{myProjectName}/users/register  ^ Replace \"{myProjectName}\" with the name of the folder your Cora demo project\nis in. This should create our user \"Bob\" and then echo out to the browser\nthe ID number assigned to him. If you use that ID, you can then go to the profile\npage at:  http://localhost/{myProjectName}/users/profile/{id}  ^ Where {id} is the ID of Bob. If Bob's ID is \"2\":  http://localhost/{myProjectName}/users/profile/2  And just like that, AmBlend saved our user Bob to the database as represented\nby the User object, saved a separate Job object to the database that represents\nthe job Bob does, and automatically handled setting up the associations for you\nbetween the objects. This is why you can do:  echo $user->job->title;  on the profile page and have it work so effortlessly. Behind-the-scenes\nAmBlend is doing all the heavy-lifting busy work for you to make saving and\nretrieving objects along with any other objects associated with them a breeze.   Explanation Pitstop:   \nSo the one thing I didn't talk about in the code above is what's happening\nin the constructor for our Users controller where we are creating our Repository object.  In programming lingo a \"factory\" is a class that handles creating objects for you.\nThe easiest way to get a Repository of a certain type is to use Cora's RepositoryFactory\nclass' Make method and telling it what type of repository you want to create.\nSo the code as seen below is just the simplest way of creating a User class repository:  $this->repo = \\Cora\\RepositoryFactory::make('User');  For more information about the Repository, Gateway, Factory pattern I recommend\nreading the documentation page for each under the AmBlend ORM section.",
            "title": "Start Using AmBlend:"
        },
        {
            "location": "/documentation/amblend/overview/#optimizing-performance",
            "text": "Ok, now that's we've seen the bare basics of how AmBlend works, let's talk for a minute\nabout how it tries to make your app lean and fast. In general, ORMs get a bad rap\nfor being inefficient, and rightfully so. I've read the horror stories of engineers\ncalled in to speed up programs only to find out the ORM used by the program is spitting\nout super ugly and inefficient queries that are like trying to kill a fly with a\nheavy machine gun! In terms of AmBlend, my goal here is to describe\nexactly how it works so you can make your own judgements about when or when not to use it.",
            "title": "Optimizing Performance"
        },
        {
            "location": "/documentation/amblend/overview/#light-classes",
            "text": "First up, when grabbing data from a row in the database for the purpose of populating\nan object, by default, AmBlend will grab all the data in that row. That is to say:  $user = $this->repo->find($id);  Is the SQL equivalent to doing:  SELECT * FROM users WHERE id = :id  One of the optimizations in AmBlend is the ability to dynamically create \"light\"\nversions of a class by not grabbing all the class data, and instead only grabbing\nthe data you need. This is possible because AmBlend uses Cora's Database class\nto interact with the persistence layer, and allows you to pass a partial query\nalong to the repository when asking for models. See below for example. You can\nadd the following method to the Users controller we previously used to see this in\naction:  public function lightClassDemo($id)\n{\n    $this->db->where('id', $id);\n    $this->db->select(['id', 'name']);\n    $user = $this->repo->findOne($this->db);  \n    var_dump($user);\n}  Is equivalent to doing:  SELECT id, name FROM users WHERE id = :id  What we're leaving out here is the user's email and their job, maybe because whatever we're\ndoing with the object doesn't require that info. It's a general rule when optimizing\nperformance to only grab what you need, and with this functionality, AmBlend\ngives you that capability.  (Note that you can use findAll() to similarly fetch\na collection of \"light\" objects.)",
            "title": "\"Light\" Classes:"
        },
        {
            "location": "/documentation/amblend/overview/#collection-subsets",
            "text": "Alright, say you want to print out a list of users, but you don't want to list all\nusers, just the ones that are Admins. Using the same methodology we\nused in the previous section to create a \"light\" version of a class, we can also\nlimit the objects we are grabbing to a subset of a whole collection. (Note: this\nexample assumes there's some sort of \"type\" attribute on the user model):  public function subsetDemo()\n{\n    $this->db->where('type', 'Admin');\n    $users = $this->repo->findAll($this->db);\n\n    foreach ($users as $user) {\n        echo $user->name.'<br>';\n    }\n}  This is yet another example of how AmBlend let's you only fetch the data you need,\nso you aren't wasting system resources.",
            "title": "Collection Subsets:"
        },
        {
            "location": "/documentation/amblend/overview/#dynamic-loading",
            "text": "AKA - How related objects are fetched:  Alright, now that we've talked about how data on the class' main table can be limited\n(\"light\" classes) and how repositories can be asked to return only a subset of\nobjects in a collection... let's continue our discussion of performance by going\nover HOW AmBlend grabs related objects.  By \"related objects\" what I'm referring to is say the Job object associated with\na user from one of our previous examples on this page. Another example would be\nif you were creating a blogging site and each user had a collection of \"articles\"\nthey've written where each article is its own object. If you are an experienced\ndeveloper who's concerned about performance, how AmBlend grabs these related objects\nfrom a database is something you should know.  The answer to that question is that AmBlend only grabs related objects \"on-demand\"\nutilizing what I call Dynamic Loading. The way in which this is done varies a little\nbit depending on how the data is stored, but all follows the same concept.\nGoing back to the \"User has a Job\" example, the way we defined the Job attribute\non our User model as a simple, single related object means that our Users table\nwill have a \"job\" column that stores the ID of that user's job.   In the case of Bob as seen in the image of his Users table entry above, grabbing\nhis whole user object and doing a var_dump as seen in this code:  public function profile($id)\n{\n    $user = $this->repo->find($id);\n    var_dump($user);\n}  Has the following applicable output:  protected 'model_data' =>\n    array (size=5)\n      'name' => string 'bob' (length=3)\n      'type' => string 'admin' (length=5)\n      'id' => string '1' (length=1)\n      'email' => string 'bob@fakeEmail.com' (length=17)\n      'job' => string '3' (length=1)  As you can see, the \"job\" attribute is NOT an object at this point, it's just\nan ID number that references a job object. However, through the power of AmBlend's\ndynamic loading, if you try and access Bob's job property, it will be fetched\nfrom the persistence layer and an object will replace the ID. To see this in\naction, let's echo out Bob's job title, and then do a var_dump afterwards to see\nthe difference:  public function profile($id)\n{\n    $user = $this->repo->find($id);\n    echo $user->job->title;\n    var_dump($user);\n}  And the result of the var_dump now looks like:  protected 'model_data' =>\n    array (size=5)\n      'name' => string 'bob' (length=3)\n      'type' => string 'admin' (length=5)\n      'id' => string '1' (length=1)\n      'email' => string 'bob@fakeEmail.com' (length=17)\n      'job' =>\n        object(Job)[11]\n          public 'model_attributes' =>\n            array (size=3)\n              ...\n          protected 'model_data' =>\n            array (size=3)\n              ...  As you can see, the \"job\" attribute is no longer just an ID, it's been replaced\nby a full Job object!",
            "title": "Dynamic Loading"
        },
        {
            "location": "/documentation/amblend/overview/#for-object-collections-or-single-objects-that-use-a-relation-table",
            "text": "This works similarly, but slightly different for related objects that use a\nrelation table or an \"owner\" type column on the related object's table. If Bob's\nUser table entry looked like this:   (Notice the lack of a \"job\" column)  And Jobs were getting related to Users by utilizing a separate relation table,\nthen the var_dump on User would look like this:  protected 'model_data' =>\n    array (size=5)\n      'name' => string 'bob' (length=3)\n      'type' => string 'admin' (length=5)\n      'id' => string '1' (length=1)\n      'email' => string 'bob@fakeEmail.com' (length=17)\n      'job' => int 1  In this scenario, the \"job\" attribute is NOT the ID of the related job object,\nbut rather just a boolean placeholder to let AmBlend's Dynamic Loading system know that\na related job exists, and that if Job is called for, it needs to use the reference\ntable to go fetch it!  This is obviously a slight difference, but one that could trip you up if you\ndon't realize how it's working.",
            "title": "For object collections or single objects that use a relation table:"
        },
        {
            "location": "/documentation/amblend/overview/#performance-considerations-of-dynamic-loading",
            "text": "WARNING: So the info I'm about to talk about below is intended for experienced\n    enterprise-level developers! It's very \"nitty-gritty\", so don't say I didn't\n    warn you. If you get lost, don't worry, just skip this section.  Alright, now that you should have an understanding of how AmBlend grabs related\nobjects (\"on-demand\" using dynamic loading), you can weigh the performance cost.\nOn one hand, the fact that AmBlend grabs only as little data as possible and grabs\nextra stuff as needed helps keep your objects lean. However, because a separate\nquery is run each time you need to fetch a related object, this has the potential\nto bombard your database with hundreds or even thousands of small queries for\nindividual objects. For example, let's pretend we have 1,000 users in our\nusers table and we execute the following code on a Users repository:  // Fetches ALL users\n$users = $this->repo->findAll();\n\nforeach ($users as $user) {\n    echo $user->job->title;\n}  The loop will run 1,000 times, and since each Job will be fetched\nindividually using a separate query at the time it tries to get accessed, it will\nresult in the equivalent of 1,000 of these queries:  SELECT * FROM jobs WHERE `id` = :id  I'm not a database mega-expert, but I'm sure that doing\n1,000 small queries is less efficient than if you just did one larger query to\ngrab all the data you needed in one go. Maybe if you consider the fact that you'd\nthen have to loop through the results of the larger query to assign each row of\ndata to an object it might come out as a wash, but that's for you to decide and\nnot me. The point I want to communicate is that this is how it works when you\ntry and access related objects to whatever the primary object you're using is.  If you wanted to grab all the Jobs from the database and have AmBlend return\nthem for you as objects, but you DON'T want to go through that process of executing\n1,000 individual queries... you have a few options:   Avoiding Lots of Mini-Queries - Option #0:  (Yes, I did just call this option zero. On purpose.)  The fact of the matter is, looping through 1,000 users and accessing information\nabout each, is not a typical usage example. If you're building an object oriented\nreporting system, I could see this being the case, but in 95% of situations you're\nprobably iterating over a small collection. If you are making some sort of users\nlist, chances are you'll be using a pagination setup, and so you probably only\nneed to loop over a few dozen users at a time.  If you're building say a Forum post system, again you're probably only iterating\nover a few dozen users, and using a pagination system again if things get too long.  In my experience exploring things such as string matching algorithms,\nwhen dealing with small data sets, a simple brute-force solution\nusually performs as well or better than a fancy more eloquent one due to the\noverhead cost of setting up fancy solutions.  So if you're concerned about performance, do a little testing. You might find\nthe simplest option may be the best option.   Avoiding Lots of Mini-Queries - Option #1:  You can just create a Jobs repository and ask for all the jobs. This will execute\na single query to fetch a collection of all the Jobs. The downside here is that\nunless you create a backwords reference from a Job to a User (our example from earlier on\nthis page didn't have one), you won't know what User(s) that Job is associated with.\nAlso worth noting, if you end up adding a backreference and using it, you might\nend up in the same individual queries situation.  But depending on what you're doing, just grabbing all the jobs this way and then\nmaybe doing some mapping between the collection of Jobs and the collection of Users\n(if necessary for the task) could be an option.   Avoiding Lots of Mini-Queries - Option #2:  If you don't need the full related object, but just a piece of information from it,\nyou can add a join to the Repository query. For instance, let's say you don't need\nthe full Job object, but just need a user's job title. You can do the following:  public function joinDemo($id)\n{\n    $this->db->where('users.id', $id)\n             ->select(['users.id', 'users.name', 'jobs.title as job_title'])\n             ->join('ref_users_jobs', [['users.id', '=', 'ref_users_jobs.user']])\n             ->join('jobs', [['ref_users_jobs.job', '=', 'jobs.id']]);\n    $user = $this->repo->findOne($this->db);  \n    echo $user->job_title;\n}  (NOTE: the above example is taken directly from the Cora demo project and Jobs are related\n    to Users via a relation table - which is different from our previous example on\n    this page where a Job ID was stored directly in the Users table)  Looking at the select() method above, in addition to grabbing the user's ID and\nname, we are also doing some joins and then grabbing the user's job title.\nSince \"job_title\" is NOT defined in the User class attributes definition, AmBlend\nwill pass it into the object as a property, but it will not do anything further.\nWhat this means is that if you alter the title and then tell AmBlend to save\nthis user, the job title will NOT get saved since it's not technically part of the class\ndefinition. The job title is just merely extra data you asked AmBlend to grab, which it did.  This can be useful if you just need some simple read-only data about a user though!\nAs you can see in the code snippet above we were able to\necho out the title. I'm sure if you're an experienced developer and reading this\nyou can see how this could be useful as long as you're careful about when/how you\nuse it. It's just important to keep in mind that any object properties not defined\nin the model_attributes array are ignored when an object is saved.  It's also worth noting here that a (probably more convenient) way of doing the same\nthing is to utilize a model's lifecycle hooks to run some custom queries when a\nmodel is fetched or saved! By doing so you can fetch the extra data anytime you\nwould normally fetch an instance of the model, and you can save the extra data\nwhenever you tell a repository to save it. See the LifeCycle Hooks section for\nmore information.   Avoiding Lots of Mini-Queries -  Option #3:  You can pass a custom built Gateway to a Repository that does whatever queries you\nwant and manipulates data in whatever way you want. AmBlend is great because it\nhandles the generic day-to-day fetching and persisting of objects for you, which is\nreally nice, BUT that doesn't mean you can't override its default behavior if you need\nto handle more complicated tasks. See the section below on how you can modify or\nreplace the default Gateway (the class in charge of fetching data from the persistence layer)\nwith a custom one of your own making.",
            "title": "Performance considerations of dynamic loading:"
        },
        {
            "location": "/documentation/amblend/overview/#limiting-resource-creation",
            "text": "Another optimization made in AmBlend is statically declared data when possible.\nSpecifically, since most apps are likely created using a single\ndatabase, the default database adaptor is stored statically. What this means is\nthat each time you trigger something like Dynamic Loading on an object that uses\nthe app's default database, AmBlend isn't creating a new database object each time,\nbut rather using the statically stored version if it exists. This means less\nwork to get setup.  It's a small thing, but every little improvement helps in the long run.",
            "title": "Limiting Resource Creation"
        },
        {
            "location": "/documentation/amblend/overview/#overriding-default-behavior",
            "text": "So one of the criticisms of the ActiveRecord pattern is it ties an object too\nclosely to a single table, and doesn't give the flexibility in how an object\nis fetched and saved that a developer might want. In most cases, this really isn't a problem (ActiveRecord\nis the most popular ORM pattern in use as of this writing to my knowledge after all).\nIn addition, as you've probably noticed if you've read this far down the page,\ngrabbing related objects from various different tables is an absolute BREEZE using\nAmBlend! However, there still may be situations that come up where a developer\nfeels the need for advanced models that are composed of direct data from multiple\ntables (\"direct data\" meaning numbers, strings, dates, etc).  The first thing I would caution a developer if they feel like they need to do this\nis to sleep on it, and re-examine what they're trying to accomplish. Does your\nobject REALLY need its data grabbed from multiple tables/sources? Can the data you\nwant to grab from a 2nd table be grabbed from a related object, rather than shoving it\ninto your current one? What about just doing a good old fashioned direct query\nusing Cora's database class? There are lifecycle hooks you can use when fetching\nor saving a model to run your custom query for fetching/saving this extra data.\nThe point I'm trying to make is that the option I'm going to share below,\nyou probably don't ever need to use... but I'll share it anyway because\nknowledge is power... or something like that.",
            "title": "Overriding Default Behavior"
        },
        {
            "location": "/documentation/amblend/overview/#writing-your-own-gateway",
            "text": "Alright, I'm not actually going to go into too much depth on this, as if you're\na developer who feels the need to write your own Gateway for fetching/persisting\nan object, you probably are pretty competent in your knowledge and skills. Instead\nI'll just gloss over the high-level process of doing this in Cora to save you\ntime having to dig as much into the code.  The steps I would take are as follows:   Either extend Cora's Gateway class and override whatever method(s) you want,\n or copy+paste the existing class into a new file, delete the contents of the methods,\n and save it as whatever you want (something like \"UserGateway\" would make sense for\n a User class). Obviously don't forget to implement the methods with your own code.  Now that you have your fancy custom Gateway ready to go, you just need to pass\n it into a Repository in place of the default one included in Cora. The way to\n go about doing this is to NOT use the RepositoryFactory like we've been using in\n our examples, and instead just go through the simple process of initializing a\n Repository for yourself like so:   // Create the Factory and Gateway the repository will use.\n$factory = new Factory($class);\n$gateway = new UserGateway(...insert your parameters...);\n\n// Pass a gateway and factory to the repository.\n$repo    = new Repository($gateway, $factory);  As you can see, the process of replacing the gateway for an object repository is\ntrivial. The hard part is actually implementing the custom Gateway. Anyways, that's\nthe gist of it... happy coding!",
            "title": "Writing Your Own Gateway:"
        },
        {
            "location": "/documentation/amblend/overview/#testing",
            "text": "Alright, the first important thing to realize about AmBlend when considering testing\nis the Data-Mapper pattern it follows. Because the logic to persist a model is\nseparate from the model itself, you can do any of the following as suits your needs\nfor testing:   You can use a test Gateway to return fixed dummy data (see the \"writing your\n own gateway\" description above for more info). If you plan on leaving Dynamic Loading\n on, you'll also need to pass in to the Factory a database object you want used\n for testing (Dynamic Loading will use that DAO).  You can pass in a database object to a Test database connection in order to grab\n your testing data. This would look like so, where you need to pass the database object\n to both the Factory and Gateway:   $db = \\Cora\\Database::getDb('name_of_test_db_connection');\n$class = 'User';\n$factory = new Factory($class, $db);\n$gateway = new Gateway($db);\n$repo    = new Repository($gateway, $factory);   And last but not least, you can just create classes of whatever model you need\n by hand (not using the Repository/Gateway/Factory) and populate them with whatever\n you want. This works because Cora models are just normal everyday classes that you\n can use just like any other class. The one thing you'll want to be sure to do in this\n situation though is to turn off Dynamic Loading (see below).",
            "title": "Testing"
        },
        {
            "location": "/documentation/amblend/overview/#turning-off-dynamic-loading",
            "text": "Let's quickly talk about Dynamic Loading and how to turn it off. You'll\nrecall from previous discussions that Dynamic Loading is a nifty little feature\nthat allows a model to request additional related objects from a Repository on-demand.\nIf you are expecting this behavior, and want the model to be able to request related\nmodels on-demand, you don't need to do anything and can just leave this feature on.\nHowever, if you want full control over the model, and would like to turn Dynamic Loading\noff, you just need to flip the following boolean on the model:  $user = $this->repo->find($id);\n$user->model_dynamicOff = true;",
            "title": "Turning off Dynamic Loading:"
        },
        {
            "location": "/documentation/amblend/implementation/",
            "text": "Implementation Details\n\n\nObviously a developer can dig through the code to see exactly how things work, but as that's a more extreme measure most people probably\ndon't bother with (and honestly AmBlend is kinda complicated),\nhere's the general understanding of how AmBlend is implemented. We'll start by talking about the ActiveRecord and Data-Mapper\npatterns as those are an important segway into understanding the implementation of AmBlend.\n\n\nORM Basics\n\n\nAlright, so first off, Object Relational Mapping only makes sense to use when you are doing object oriented programming. If you aren't familiar with OO programming,\nI'd recommend you look into it, as it makes keeping your app well organized way easier. Assuming however that you have a basic understanding of what objects are,\nlet's discuss what an ORM does.\n\n\nSay you have a simple User object that looks like this:\n\n\nclass User\n{\n    public $name;\n    public $email;\n\n    public function __construct($name, $email)\n    {\n        $this->name = $name;\n        $this->email = $email;\n    }\n}\n\n\n\n\nBecause HTTP is a stateless protocol, each time someone makes a new request to your webapp, the application has to be reinitialized from scratch. This means any\ndata that's needed for your app to run must be fetched from various sources when setting up, and must be saved back to a permanent storage space after use (or\nelse the data will simply be thrown out and lost). Aside from data you only need to keep temporarily (Google 'php sessions tutorial'), anything you want\nto store permanently you'll probably be saving to a database. If you've worked with objects in the past outside of a framework, your solution to saving an object\nmight have been to add a \"save\" method that executes some SQL (structured query language):\n\n\nclass User\n{\n    public $id;\n    public $name;\n    public $email;\n\n    public function __construct($container, $name = null, $email = null)\n    {\n        $this->db = $container['db'];\n        $this->name = $name;\n        $this->email = $email;\n    }\n\n    public function save()\n    {\n        // If this user already exists in the DB, then just update it.\n        if (isset($this->id)) {\n            $this->db->query(\"UPDATE users SET name = :name, email = :email WHERE id = :user_id\");\n            $this->db->bind(':name', $this->name);\n            $this->db->bind(':email', $this->email);\n            $this->db->bind(':id', $this->id);\n            $this->db->execute()\n        }\n        // Otherwise create a new user record.\n        else {\n            $db->query(\"INSERT INTO users VALUES (NULL, :name, :email)\");\n            $this->db->bind(':name', $this->name);\n            $this->db->bind(':email', $this->email);\n            if ($this->db->execute()) {\n                $this->id = $db->lastInsertId();\n            }   \n        }\n    }\n}\n\n\n\n\nHere we've changed the code to allow us to pass in a container with a database adaptor, and we either insert or update\na user in the database when the save() method is called. Already you can see that this is quickly adding a lot of lines of code\nto our user model, and this is for a simple example which only contains a name and email. What's more, we haven't even added any code\nyet for fetching users from the database! We only added code to save a user.\n\n\nThe goal of an ORM like AmBlend is to free you from having to implement methods to save and grab the model data from the database.\nThis not only allows you to get rid of a lot of code clutter from your classes, it also saves you time by freeing you from having\nto implement error-prone, busy-work like writing all those SQL queries. Using AmBlend, your model and the controller code to create\na new user would look something like this:\n\n\nclass User extends \\Cora\\Model {\n\n    public $model_attributes = [\n        'id' => [],\n        'name' => [],\n        'email' => []\n    ];\n\n    public function __construct($name = null, $type = null)\n    {\n        $this->name = $name;\n        $this->type = $type;\n    }\n}\n\n\n///////////////////////////////////////////\n// Controller code to create a new user\n///////////////////////////////////////////\nclass Users extends \\MyApp {\n    public function register()\n    {\n        $repo = \\Cora\\RepositoryFactory::make('User');\n        $user = new User('testUser', 'testUser31@gmail.com');\n        $repo->save($user);\n    }\n}\n\n\n\n\nLet's quickly discuss ActiveRecord vs. Data-Mapper implementations\nwhich will then segway into how AmBlend is implemented in the next section.\n\n\nActiveRecord Pattern\n\n\nIn terms of functionality, ActiveRecord basically works just like the example from the above section where I showed what your code might look like if you implemented\nhandling database persistance on your own. The difference being that your model will extend from a base class that handles the database related logic for you.\nSo you won't have to write (typically) the SQL queries to save your objects, but the logic will still be a part of your model. ActiveRecord generally looks like this:\n\n\nclass User extends ActiveRecordModel\n{\n    public $name;\n    public $email;\n\n    public function __construct($name, $email)\n    {\n        $this->name = $name;\n        $this->email = $email;\n    }\n}\n\nclass ActiveRecordModel\n{\n    // Save record to database.\n    public function save()\n    {\n        // SAVING TO DB LOGIC\n    }\n\n    // Fetch record from database.\n    public function fetch($parameters)\n    {\n        // FETCHING FROM DB LOGIC\n    }\n}\n\n\n\n\nThere's a few different main complaints people have about the ActiveRecord pattern, and they're all kinda interrelated. Let's start\nby mentioning its lack of SRP adherance. SRP stands for Single Responsibility Principle, and basically means each class should only\nhandle a single part of a software's functionality. In doing so, you help your app stay logically sensible and readable, and make\ntesting easier. If software doesn't adhere to the SRP, then it runs the risk of becoming a confusing mess of spaghetti code that's hard\nto test, hard to understand, hard to upgrade and maintain, etc.\n\n\nThis of course leads into and overlaps the other two main complaints about AR, those being that it can be hard to test (depends on just how much \"magic\"\nhappens under the surface) and that there's generally a lack of separation between the domain (aka 'the app logic') and the storage medium (database).\nThe testing issues usually are the result of \"magic\" in the form of data being passively fetched from a database, which if you're trying to test\nyour app independent of the storage medium, can obviously be frustrating. Similarly, the lack of domain/database separation also stems from how closely tied\nto the database the ActiveRecord pattern is coupled by nature of how it works.\n\n\nWhy is important to keep the domain (app) logic decoupled from the database? Several reasons, the most important probably being:\n\n\n\n\n\n\nStorage mediums can and do change! You may be using the MySQL database today, but tomorrow you might need to use MongoDb, or save your data to\n XML files, or whatever. If you need to swap out the storage system your app uses, it shouldn't break all your code and force you to rewrite the app.\n\n\n\n\n\n\nYou want to be able to test and know that your code, your logic, works like you intend it to. Although most databases used nowadays aren't going\n to have a lot of obvious bugs, the fact of the matter remains that the storage layer is still powered by software, and as such, could have bugs\n in its implementation. That's why you need to be able to test YOUR code and know it's working, independent of any bugs related to the storage & retrieval of data.\n\n\n\n\n\n\nOn the flip side, ActiveRecord's strengths are that it's super easy to use and requires little to no setup (which are awesome positives!). For these reasons, it's an extremely popular ORM\npattern used by many frameworks.\n\n\nData-Mapper Pattern\n\n\nThe \nData-Mapper pattern\n utilizes a completely different approach from anything we've talked about so far.\nWhen using a data mapper, your models are COMPLETELY SEPARATED from the storage layer. They don't know how to save themselves, or fetch records, or anything else, because\nhandling persistence to a storage medium is outside their responsibility! Using this pattern, it's the Data Mapper's job to know how to save and fetch objects.\nIt 'maps' different kinds of data used in your app to some sort of storage point. This\nis obviously a complete 180 from the ActiveRecord pattern where objects have to know how to fetch and save from the storage layer themselves.\n\n\nAn ultra simplistic representation of the Data Mapper pattern might look like the below. Notice the User class doesn't extend anything, and a User object must\nbe passed in to the Data Mapper for it to save the user.\n\n\nclass User\n{\n    public $name;\n    public $email;\n\n    public function __construct($name, $email)\n    {\n        $this->name = $name;\n        $this->email = $email;\n    }\n}\n\nclass DataMapper\n{\n    // Save record to database.\n    public function save($objectToBeSaved)\n    {\n        // SAVING TO DB LOGIC\n    }\n\n    // Fetch record from database. Some options are passed in to determine what to fetch.\n    public function fetch($filterParameters)\n    {\n        // FETCHING FROM DB LOGIC\n    }\n}\n\n\n\n\nAs SRP purists will delight to tell you, the data mapper pattern adheres to the Single Responsibility Principle quite well. Furthermore, because an object\nis simply an object and has nothing magical or special about it, this makes testing way more straightforword. Need to save an object to a different storage medium?\nYou have the option of just passing the object to a different data mapper! Need to map parts of your object to one storage medium, and another part of the same\nobject to a different storage location? Using Data Mapper you can write the functionality to handle this without adding all sorts of unrelated logical clutter to your models!\nIn these and other ways, the Data Mapper pattern is much more flexible than ActiveRecord.\n\n\nThe downsides to this Data Mapper pattern are that it can be a little hard to understand and use, and it can require more setup time and thought because it doesn't necessarily have the 1-to-1 type of relationship with a database many AR implementations possess.\n\n\nUnderstanding AmBlend's Implementation\n\n\n\n    WARNING: The following two paragraphs are chock-full of\n    fancy terminology you may not understand. Don't freak out! Just keep reading\n    and all will be explained by the end of this section.\n\n\n\n\nAlright, with the understandings from the previous section in place, we're now\nready to talk about how AmBlend implements object relational mapping. In short,\nAmBlend uses a generalized Repository-Gateway-Factory design pattern where the\nGateway (which acts as the mapper between the domain and the persistence layer) asks\nthe model for various pieces of information about itself and the data it has ownership over.\nThe Gateway does this via the utility methods the Cora Model class provides. This\nseparation of concerns with the Gateway acting as the mapper between the persistence\nlayer and the domain, is in-line with using a Data Mapper and provides\nyou with all the benefits of that pattern.\n\n\nHowever, AmBlend, as discussed previously, is not just a pure Data-Mapper implementation,\nbut instead a blend of both ActiveRecord and Data-Mapper. The goal of AmBlend is\nto provide the ease of use ActiveRecord is famous for, but\nalso the separation of concerns and flexibility that Data Mapper excels at.\nThe way AmBlend accomplishes this is by using the repository-gateway-factory pattern\nAND by having its models inherit methods from Cora's\nModel class. This inheritance is obviously similar to ActiveRecord, however,\nunlike AR, those methods do not directly interact with the persistence\nlayer. Instead, they help other classes (particularly the Gateway) understand and\nuse the attributes defined in the model. They also provide the model with\nknowledge of the repository's existence, so the model can ask the repository to\nfetch data dynamically (\nClick Here\n\nto read about how that works).\n\n\nPHEWWW! Was that a mouthful or what? Hold on a sec, I think I need to cram a few\nmore buzzwords in those two paragraphs... Seriously though, now that's I've given\nthe highly compact description of how AmBlend works, let's slow down a bit and kinda\nwalk through it bit-by-bit.\n\n\nSo there's really two different logic flows that are important for understanding exactly\nwhat's going on, the regular logic flow of fetching objects from a repository,\nand the logic flow of fetching related objects dynamically. First let's look at\nwhat happens when we want to fetch from a repository.\n\n\n\n\nFetching from a Repository\n\n\n(typical Data-Mapper type implementation):\n\n\n\u00a0\n\n\n\nThe Code (an example of a User repository in use within a Controller):\n   \n\n\n// Repository Setup (if not using RepositoryFactory)\n$db = \\Cora\\Database::getDb('name_of_db_connection');\n$factory = new Factory('User');\n$gateway = new Gateway($db);\n$repo    = new Repository($gateway, $factory);\n\n// Grab a user from repository. This triggers the logic flow seen in the diagram below.\n$user = $repo->findBy('email', 'Bob@fakeEmail.com');\n\n\n\n\n\u00a0\n\n\n\nThe Logic Flow Chart - Diagram A:\n \n\n\n\u00a0\n\n\n\n\n\u00a0\n\n\n\nAs can be seen, there's nothing too fancy here. This is a normal looking Repository\npattern, where the Gateway is acting as our Data Mapper.\nIf you aren't familiar with it, here's a description of what the objects\nresponsibilities are:\n\n\n\n\nThe Repository:\n The Repository is the access point that parts of your application\ninteract with when they need to get objects out of, or save objects to, the persistence layer (usually a database).\nIf you create a \"User\" repository, it handles grabbing and saving Users, if you create an \"Orders\"\nrepository, it handles grabbing and saving Orders, and so forth.\n\n\nThe Gateway:\n The Gateway is the class who's responsibility it is to interact directly\nwith the persistence layer and grab data from whatever database, or text file, or API,\nit needs to interact with in order to get you the raw data you need. It also interacts\nwith the storage mediums to save objects when an object needs to be persisted.\n\n\nThe Factory:\n The Factory is a class that makes objects. If you have a \"User\" factory,\nthen it's going to create User objects for you. In AmBlend, the Factory is given\nthe raw data (an array) from the Gateway and returns back objects.\n\n\n\n\n\n\nNext let's look at the logic flow of fetching related objects dynamically. On the\nsurface this might seem like a small change (judging from the diagram), but really\nit's much different as in this scenario a model itself is the one creating and\nusing a Repository (via the methods built into its Cora Model class parent).\n\n\n\n\nDynamically Fetching a Related Object:\n\n\n(still Data-Mapping, but incorporates ActiveRecord type use of Cora Model class)\n\n\n\u00a0\n\n\n\nThe Code (accessing a related object to a User):\n   \n\n\n// Repository Setup (this time we're using RepositoryFactory)\n$repo = \\Cora\\RepositoryFactory::make(User::class);\n\n// Grab a user from repository. This triggers the logic flow seen in the diagram A.\n$user = $repo->findBy('email', 'Bob@fakeEmail.com');\n\n// Access a related object (Job is a class). This triggers the logic in diagram B below.\necho $user->job->title;\n\n\n\n\n\u00a0\n\n\n\nThe Logic Flow Chart - Diagram B:\n \n\n\n\u00a0\n\n\n\n\n\u00a0\n\n\n\nThe only difference between diagram A and diagram B above is how the repository\ngets invoked (steps 0 through 1). However, this is actually a pretty major change\nin the logic flow! When normally fetching from a repository, there's no interaction\nwith a model, a controller asks a repository for one or more objects and the\nrepository returns them. When a controller already has a Cora model and needs\nto grab a related object, that's when the logic built into the Cora model class\nkicks in to facilitate. The model looks at its own definition and any data passed\nin when it was created, and from those determines how to create a Repository to\ngrab the needed related object. This is how AmBlend implements ActiveRecord like\nsimplicity in fetching objects, while still maintaining separation of concerns.\nThe model doesn't directly interact with the persistence layer (knowing that's not\nits responsibility), but rather the Cora Model class gives it the necessary knowledge\non how to use the Repository system. And then, just to make sure testing doesn't get\ndifficult, options are included to disable Dynamic Fetching, or to pass in a\ndifferent database adaptor to override any defaults (I.E. force dynamic fetching to\nuse a test database). See \nHere\n\nfor more information on testing.\n\n\n\n\nOk, that's it! Hopefully you have a high level understanding of how AmBlend blends\ntogether the best of Data-Mapper and ActiveRecord into a new best-of-both worlds system.",
            "title": "Implementation"
        },
        {
            "location": "/documentation/amblend/implementation/#implementation-details",
            "text": "Obviously a developer can dig through the code to see exactly how things work, but as that's a more extreme measure most people probably\ndon't bother with (and honestly AmBlend is kinda complicated),\nhere's the general understanding of how AmBlend is implemented. We'll start by talking about the ActiveRecord and Data-Mapper\npatterns as those are an important segway into understanding the implementation of AmBlend.",
            "title": "Implementation Details"
        },
        {
            "location": "/documentation/amblend/implementation/#orm-basics",
            "text": "Alright, so first off, Object Relational Mapping only makes sense to use when you are doing object oriented programming. If you aren't familiar with OO programming,\nI'd recommend you look into it, as it makes keeping your app well organized way easier. Assuming however that you have a basic understanding of what objects are,\nlet's discuss what an ORM does.  Say you have a simple User object that looks like this:  class User\n{\n    public $name;\n    public $email;\n\n    public function __construct($name, $email)\n    {\n        $this->name = $name;\n        $this->email = $email;\n    }\n}  Because HTTP is a stateless protocol, each time someone makes a new request to your webapp, the application has to be reinitialized from scratch. This means any\ndata that's needed for your app to run must be fetched from various sources when setting up, and must be saved back to a permanent storage space after use (or\nelse the data will simply be thrown out and lost). Aside from data you only need to keep temporarily (Google 'php sessions tutorial'), anything you want\nto store permanently you'll probably be saving to a database. If you've worked with objects in the past outside of a framework, your solution to saving an object\nmight have been to add a \"save\" method that executes some SQL (structured query language):  class User\n{\n    public $id;\n    public $name;\n    public $email;\n\n    public function __construct($container, $name = null, $email = null)\n    {\n        $this->db = $container['db'];\n        $this->name = $name;\n        $this->email = $email;\n    }\n\n    public function save()\n    {\n        // If this user already exists in the DB, then just update it.\n        if (isset($this->id)) {\n            $this->db->query(\"UPDATE users SET name = :name, email = :email WHERE id = :user_id\");\n            $this->db->bind(':name', $this->name);\n            $this->db->bind(':email', $this->email);\n            $this->db->bind(':id', $this->id);\n            $this->db->execute()\n        }\n        // Otherwise create a new user record.\n        else {\n            $db->query(\"INSERT INTO users VALUES (NULL, :name, :email)\");\n            $this->db->bind(':name', $this->name);\n            $this->db->bind(':email', $this->email);\n            if ($this->db->execute()) {\n                $this->id = $db->lastInsertId();\n            }   \n        }\n    }\n}  Here we've changed the code to allow us to pass in a container with a database adaptor, and we either insert or update\na user in the database when the save() method is called. Already you can see that this is quickly adding a lot of lines of code\nto our user model, and this is for a simple example which only contains a name and email. What's more, we haven't even added any code\nyet for fetching users from the database! We only added code to save a user.  The goal of an ORM like AmBlend is to free you from having to implement methods to save and grab the model data from the database.\nThis not only allows you to get rid of a lot of code clutter from your classes, it also saves you time by freeing you from having\nto implement error-prone, busy-work like writing all those SQL queries. Using AmBlend, your model and the controller code to create\na new user would look something like this:  class User extends \\Cora\\Model {\n\n    public $model_attributes = [\n        'id' => [],\n        'name' => [],\n        'email' => []\n    ];\n\n    public function __construct($name = null, $type = null)\n    {\n        $this->name = $name;\n        $this->type = $type;\n    }\n}\n\n\n///////////////////////////////////////////\n// Controller code to create a new user\n///////////////////////////////////////////\nclass Users extends \\MyApp {\n    public function register()\n    {\n        $repo = \\Cora\\RepositoryFactory::make('User');\n        $user = new User('testUser', 'testUser31@gmail.com');\n        $repo->save($user);\n    }\n}  Let's quickly discuss ActiveRecord vs. Data-Mapper implementations\nwhich will then segway into how AmBlend is implemented in the next section.",
            "title": "ORM Basics"
        },
        {
            "location": "/documentation/amblend/implementation/#activerecord-pattern",
            "text": "In terms of functionality, ActiveRecord basically works just like the example from the above section where I showed what your code might look like if you implemented\nhandling database persistance on your own. The difference being that your model will extend from a base class that handles the database related logic for you.\nSo you won't have to write (typically) the SQL queries to save your objects, but the logic will still be a part of your model. ActiveRecord generally looks like this:  class User extends ActiveRecordModel\n{\n    public $name;\n    public $email;\n\n    public function __construct($name, $email)\n    {\n        $this->name = $name;\n        $this->email = $email;\n    }\n}\n\nclass ActiveRecordModel\n{\n    // Save record to database.\n    public function save()\n    {\n        // SAVING TO DB LOGIC\n    }\n\n    // Fetch record from database.\n    public function fetch($parameters)\n    {\n        // FETCHING FROM DB LOGIC\n    }\n}  There's a few different main complaints people have about the ActiveRecord pattern, and they're all kinda interrelated. Let's start\nby mentioning its lack of SRP adherance. SRP stands for Single Responsibility Principle, and basically means each class should only\nhandle a single part of a software's functionality. In doing so, you help your app stay logically sensible and readable, and make\ntesting easier. If software doesn't adhere to the SRP, then it runs the risk of becoming a confusing mess of spaghetti code that's hard\nto test, hard to understand, hard to upgrade and maintain, etc.  This of course leads into and overlaps the other two main complaints about AR, those being that it can be hard to test (depends on just how much \"magic\"\nhappens under the surface) and that there's generally a lack of separation between the domain (aka 'the app logic') and the storage medium (database).\nThe testing issues usually are the result of \"magic\" in the form of data being passively fetched from a database, which if you're trying to test\nyour app independent of the storage medium, can obviously be frustrating. Similarly, the lack of domain/database separation also stems from how closely tied\nto the database the ActiveRecord pattern is coupled by nature of how it works.  Why is important to keep the domain (app) logic decoupled from the database? Several reasons, the most important probably being:    Storage mediums can and do change! You may be using the MySQL database today, but tomorrow you might need to use MongoDb, or save your data to\n XML files, or whatever. If you need to swap out the storage system your app uses, it shouldn't break all your code and force you to rewrite the app.    You want to be able to test and know that your code, your logic, works like you intend it to. Although most databases used nowadays aren't going\n to have a lot of obvious bugs, the fact of the matter remains that the storage layer is still powered by software, and as such, could have bugs\n in its implementation. That's why you need to be able to test YOUR code and know it's working, independent of any bugs related to the storage & retrieval of data.    On the flip side, ActiveRecord's strengths are that it's super easy to use and requires little to no setup (which are awesome positives!). For these reasons, it's an extremely popular ORM\npattern used by many frameworks.",
            "title": "ActiveRecord Pattern"
        },
        {
            "location": "/documentation/amblend/implementation/#data-mapper-pattern",
            "text": "The  Data-Mapper pattern  utilizes a completely different approach from anything we've talked about so far.\nWhen using a data mapper, your models are COMPLETELY SEPARATED from the storage layer. They don't know how to save themselves, or fetch records, or anything else, because\nhandling persistence to a storage medium is outside their responsibility! Using this pattern, it's the Data Mapper's job to know how to save and fetch objects.\nIt 'maps' different kinds of data used in your app to some sort of storage point. This\nis obviously a complete 180 from the ActiveRecord pattern where objects have to know how to fetch and save from the storage layer themselves.  An ultra simplistic representation of the Data Mapper pattern might look like the below. Notice the User class doesn't extend anything, and a User object must\nbe passed in to the Data Mapper for it to save the user.  class User\n{\n    public $name;\n    public $email;\n\n    public function __construct($name, $email)\n    {\n        $this->name = $name;\n        $this->email = $email;\n    }\n}\n\nclass DataMapper\n{\n    // Save record to database.\n    public function save($objectToBeSaved)\n    {\n        // SAVING TO DB LOGIC\n    }\n\n    // Fetch record from database. Some options are passed in to determine what to fetch.\n    public function fetch($filterParameters)\n    {\n        // FETCHING FROM DB LOGIC\n    }\n}  As SRP purists will delight to tell you, the data mapper pattern adheres to the Single Responsibility Principle quite well. Furthermore, because an object\nis simply an object and has nothing magical or special about it, this makes testing way more straightforword. Need to save an object to a different storage medium?\nYou have the option of just passing the object to a different data mapper! Need to map parts of your object to one storage medium, and another part of the same\nobject to a different storage location? Using Data Mapper you can write the functionality to handle this without adding all sorts of unrelated logical clutter to your models!\nIn these and other ways, the Data Mapper pattern is much more flexible than ActiveRecord.  The downsides to this Data Mapper pattern are that it can be a little hard to understand and use, and it can require more setup time and thought because it doesn't necessarily have the 1-to-1 type of relationship with a database many AR implementations possess.",
            "title": "Data-Mapper Pattern"
        },
        {
            "location": "/documentation/amblend/implementation/#understanding-amblends-implementation",
            "text": "WARNING: The following two paragraphs are chock-full of\n    fancy terminology you may not understand. Don't freak out! Just keep reading\n    and all will be explained by the end of this section.  Alright, with the understandings from the previous section in place, we're now\nready to talk about how AmBlend implements object relational mapping. In short,\nAmBlend uses a generalized Repository-Gateway-Factory design pattern where the\nGateway (which acts as the mapper between the domain and the persistence layer) asks\nthe model for various pieces of information about itself and the data it has ownership over.\nThe Gateway does this via the utility methods the Cora Model class provides. This\nseparation of concerns with the Gateway acting as the mapper between the persistence\nlayer and the domain, is in-line with using a Data Mapper and provides\nyou with all the benefits of that pattern.  However, AmBlend, as discussed previously, is not just a pure Data-Mapper implementation,\nbut instead a blend of both ActiveRecord and Data-Mapper. The goal of AmBlend is\nto provide the ease of use ActiveRecord is famous for, but\nalso the separation of concerns and flexibility that Data Mapper excels at.\nThe way AmBlend accomplishes this is by using the repository-gateway-factory pattern\nAND by having its models inherit methods from Cora's\nModel class. This inheritance is obviously similar to ActiveRecord, however,\nunlike AR, those methods do not directly interact with the persistence\nlayer. Instead, they help other classes (particularly the Gateway) understand and\nuse the attributes defined in the model. They also provide the model with\nknowledge of the repository's existence, so the model can ask the repository to\nfetch data dynamically ( Click Here \nto read about how that works).  PHEWWW! Was that a mouthful or what? Hold on a sec, I think I need to cram a few\nmore buzzwords in those two paragraphs... Seriously though, now that's I've given\nthe highly compact description of how AmBlend works, let's slow down a bit and kinda\nwalk through it bit-by-bit.  So there's really two different logic flows that are important for understanding exactly\nwhat's going on, the regular logic flow of fetching objects from a repository,\nand the logic flow of fetching related objects dynamically. First let's look at\nwhat happens when we want to fetch from a repository.",
            "title": "Understanding AmBlend's Implementation"
        },
        {
            "location": "/documentation/amblend/implementation/#fetching-from-a-repository",
            "text": "(typical Data-Mapper type implementation):  \u00a0  The Code (an example of a User repository in use within a Controller):      // Repository Setup (if not using RepositoryFactory)\n$db = \\Cora\\Database::getDb('name_of_db_connection');\n$factory = new Factory('User');\n$gateway = new Gateway($db);\n$repo    = new Repository($gateway, $factory);\n\n// Grab a user from repository. This triggers the logic flow seen in the diagram below.\n$user = $repo->findBy('email', 'Bob@fakeEmail.com');  \u00a0  The Logic Flow Chart - Diagram A:    \u00a0   \u00a0  As can be seen, there's nothing too fancy here. This is a normal looking Repository\npattern, where the Gateway is acting as our Data Mapper.\nIf you aren't familiar with it, here's a description of what the objects\nresponsibilities are:   The Repository:  The Repository is the access point that parts of your application\ninteract with when they need to get objects out of, or save objects to, the persistence layer (usually a database).\nIf you create a \"User\" repository, it handles grabbing and saving Users, if you create an \"Orders\"\nrepository, it handles grabbing and saving Orders, and so forth.  The Gateway:  The Gateway is the class who's responsibility it is to interact directly\nwith the persistence layer and grab data from whatever database, or text file, or API,\nit needs to interact with in order to get you the raw data you need. It also interacts\nwith the storage mediums to save objects when an object needs to be persisted.  The Factory:  The Factory is a class that makes objects. If you have a \"User\" factory,\nthen it's going to create User objects for you. In AmBlend, the Factory is given\nthe raw data (an array) from the Gateway and returns back objects.    Next let's look at the logic flow of fetching related objects dynamically. On the\nsurface this might seem like a small change (judging from the diagram), but really\nit's much different as in this scenario a model itself is the one creating and\nusing a Repository (via the methods built into its Cora Model class parent).",
            "title": "Fetching from a Repository"
        },
        {
            "location": "/documentation/amblend/implementation/#dynamically-fetching-a-related-object",
            "text": "(still Data-Mapping, but incorporates ActiveRecord type use of Cora Model class)  \u00a0  The Code (accessing a related object to a User):      // Repository Setup (this time we're using RepositoryFactory)\n$repo = \\Cora\\RepositoryFactory::make(User::class);\n\n// Grab a user from repository. This triggers the logic flow seen in the diagram A.\n$user = $repo->findBy('email', 'Bob@fakeEmail.com');\n\n// Access a related object (Job is a class). This triggers the logic in diagram B below.\necho $user->job->title;  \u00a0  The Logic Flow Chart - Diagram B:    \u00a0   \u00a0  The only difference between diagram A and diagram B above is how the repository\ngets invoked (steps 0 through 1). However, this is actually a pretty major change\nin the logic flow! When normally fetching from a repository, there's no interaction\nwith a model, a controller asks a repository for one or more objects and the\nrepository returns them. When a controller already has a Cora model and needs\nto grab a related object, that's when the logic built into the Cora model class\nkicks in to facilitate. The model looks at its own definition and any data passed\nin when it was created, and from those determines how to create a Repository to\ngrab the needed related object. This is how AmBlend implements ActiveRecord like\nsimplicity in fetching objects, while still maintaining separation of concerns.\nThe model doesn't directly interact with the persistence layer (knowing that's not\nits responsibility), but rather the Cora Model class gives it the necessary knowledge\non how to use the Repository system. And then, just to make sure testing doesn't get\ndifficult, options are included to disable Dynamic Fetching, or to pass in a\ndifferent database adaptor to override any defaults (I.E. force dynamic fetching to\nuse a test database). See  Here \nfor more information on testing.   Ok, that's it! Hopefully you have a high level understanding of how AmBlend blends\ntogether the best of Data-Mapper and ActiveRecord into a new best-of-both worlds system.",
            "title": "Dynamically Fetching a Related Object:"
        },
        {
            "location": "/documentation/amblend/repository/",
            "text": "Repository Class\n\n\nThe purpose of the Repository is to separate the logic that retrieves data from\nthe persistence layer from the models themselves and the business logic that\nacts on those models. The Repository acts as a sort of controller that utilizes\na Gateway for direct access to data and a Factory for creating objects.\n\n\nCreating a Repository\n\n\nThere's a few different ways to get a Repository depending on the situation. The\nmost general purpose and easiest solution is usually to utilize the RepositoryFactory\nclass. However, for situations where you need to utilize a custom Gateway or Factory,\ncreating a Repository without using the factory may be desired. Finally, if you\nalready have an instance of a model, you can ask a model to give you a repository\nmatching its type.\n\n\nUsing RepositoryFactory\n\n\nFor simple class namespaces, it's easiest to just type the name in like so:\n\n\nclass MyController extends \\MyApp {\n    public function demo()\n    {\n        $repo = \\Cora\\RepositoryFactory::make('User');\n        $user = $repo->find($id);\n    }\n}\n\n\n\n\nFor more advanced namespaces, you can take advantage of Use statements by utilizing\nthe \"class\" keyword:\n\n\nuse \\System\\Blog\\Bug\\Task\\Note;\nclass MyController extends \\MyApp {\n    public function demo()\n    {\n        $repo = \\Cora\\RepositoryFactory::make(Note::class);\n        $user = $repo->find($id);\n\n        // OR you can still do\n\n        $repo = \\Cora\\RepositoryFactory::make('\\\\System\\\\Blog\\\\Bug\\\\Task\\\\Note');\n        $user = $repo->find($id);\n    }\n}\n\n\n\n\nRepositoryFactory Options\n\n\nWhile we're on the topic of using the RepositoryFactory, now is a good time to look\nat its make() method definition and the options it gives you.\n\n\nmake($class, $idField = false, $table = false, $freshAdaptor = false, $db = false)\n\n\n\n\n\n\nThe $class parameter is the object type you'll be using the repository for.\n\n\nThe optional $idField parameter is for setting the unique ID field which will be\nused to fetch objects from a database. You'll most likely want to set this if your\nID column is something other than 'id'.\n\n\nThe optional $table parameter is for overriding the defaults as defined in a model. If\nthis parameter is defined, it will be passed to the Gateway as the table/collection\nto fetch objects from.\n\n\nThe optional $freshAdaptor is a setting you'll most likely not ever need to use. See my explanation\nafter this list for more details.\n\n\nThe optional $db let's you pass in a custom Cora database connection for the Gateway to use.\nThis can be used to force the Repository and Dynamic Loading to use a connection to\na Test database for testing purposes.\n\n\n\n\nExplanation of $freshAdaptor:\n\n\n\n    WARNING: Please don't confuse yourself by reading this section unless you are\n    an advanced developer interested in writing your own Gateway implementations.\n\n\n\n\nAmBlend is\nbuilt using Cora's Database class, and since most apps probably only use a single\ndatabase, part of the database setup process is setting a \"default connection\".\nWhen fetching models, if no particular connection is specified in the model definition, AmBlend\nwill default to using the default connection. In order to make this typical use case more\nefficient, the Database class stores an instance of the default DB as a static data member.\nWhen a database operation involving the default database is performed, this statically stored\ndefault will be used rather than creating a new instance each time.\nIn most cases this is great! However, because Cora's Database\nclass can only handle building 1 query at a time, if you end up in a situation where\nin the middle of building a query, you need to pause and perform another query on\nthe default connection, this can cause problems. In this scenario, what you need is\na fresh version of the adaptor and not the statically stored one. Setting $freshAdaptor\nto true gives you a new database class.\n\n\nI realize that explanation is a little hard to follow, but the reason for the $freshAdaptor\nparameter's existence has to do with the inner optimization workings of Cora, and\nis inherently complicated for that reason. The good news is that unless you start building\nyour own custom gateway classes, I can't really think of a reason you'd need to use or\nunderstand it.\n\n\nThe backstory on this feature is that Cora's Gateway walks through a loop of a model's\nattributes and builds up the query to save the model to the database. However, when\na related object is encountered, it recursively calls the Save() method on that related\nobject at the time it encounters it. Because the default adaptor was already being used to build\nup a query, that recursive call to the Save() method on the related object was causing conflicts if the\nrelated object also used the default adaptor (due to the one query at a time restriction\non a Cora Database class and the default database being stored statically).\n\n\nUsing Custom Setup\n\n\nFor situations where you want to swap out components of the repository system\nwith your own custom classes, you'll need to bypass the RepositoryFactory and just\ndo the setup yourself. The general format is as follows:\n\n\n$db = \\Cora\\Database::getDb('name_of_db_connection_to_use');\n$class = 'User';\n$factory = new Factory($class, $db);\n$gateway = new Gateway($db);\n$repo    = new Repository($gateway, $factory);\n\n\n\n\nUsing Model Method\n\n\nIf you're in a situation where you created an instance of a Cora Model class,\nand now you need a repository for it to persist it or whatever, you can take advantage\nof Cora Model's knowledge on how to create repositories for themselves:\n\n\n$user = new \\User('Josiah', 'SuperAdmin');\n$user->location = new Location('JoesHouse', 'Portland');\n$user->job      = new Job('Librarian', 'Keeper of knowledge!');\n$repo = $user->getRepository();\n$repo->save($user);\n\n\n\n\nUsing a Repository\n\n\nfind() Method\n\n\nPurpose:\n \n\nThe find() method is for grabbing a single object from a database based on the\nobject's unique ID.\n\n\nFormat:\n\n\nfind(id)\n\n\n\n\nExamples:\n  \n\n\n// Create Repository\n$repo = \\Cora\\RepositoryFactory::make('User');\n\n// Grab a user Object\n$user = $repo->find($id);\n\n\n\n\nfindOne() Method\n\n\nPurpose:\n \n\nThe findOne() method is for grabbing a single object from a database based on\nthe passed in query parameters.\n\n\nFormat:\n\n\nfindOne(coraDbQuery)\n\n\n\n\nExamples:\n  \n\n\n// Create Repository\n$repo = \\Cora\\RepositoryFactory::make('User');\n\n// Grab an instance of database adaptor for this model.\n$db = $repo->getDb();\n\n// Define some db query parameters.\n$db->where('name', 'testUser');\n\n// Grab a user Object matching query.\n$user = $repo->findOne($db);\n\n\n\n\nfindAll() Method\n\n\nPurpose:\n \n\nThe findAll() method is for grabbing all objects from a database collection.\nThe results can be limited by optionally passing along query parameters.\n\n\nFormat:\n\n\nfindAll([coraDbQuery])\n\n\n\n\nExamples:\n  \n\n\n// Create Repository\n$repo = \\Cora\\RepositoryFactory::make('User');\n\n// Fetch ALL users.\n$allUsers = $repo->findAll();\n\n// Grab an instance of database adaptor for this model.\n$db = $repo->getDb();\n\n// Define some db query parameters.\n$db->where('type', 'Admin');\n\n// Grab a subset of users. In this case all users who are Admins.\n$admins = $repo->findAll($db);\n\n\n\n\nfindBy() Method\n\n\nPurpose:\n \n\nThe findBy() method is for grabbing a set of objects based on a simple restriction.\nThis has the same basic functionality as findAll(), but is simpler to use with\nthe tradeoff of being less flexible.\n\n\nFormat:\n\n\n// options = array(['order_by' => 'desc|asc'] [, 'limit' => number [, 'offset' => number]])\nfindBy(property, value [, options])\n\n\n\n\nBecause the \"options\" is kinda hard to read above let me just verbally describe it.\nYou can pass in an associative array with up to 3 keys, those being \"order_by\",\n\"limit\", and \"offset\". Order_by should be either \"desc\" or \"asc\", and limit and offset\nshould be numbers. Offset doesn't do anything unless you also pass in a Limit.\n\n\nExamples:\n  \n\n\n// Create Repository\n$repo = \\Cora\\RepositoryFactory::make('User');\n\n// Grab users who are Admins.\n$admins = $repo->findBy('type', 'Admin');\n\n// Grab users who are Moderators, but only return the first 10.\n$mods = $repo->findBy('type', 'Moderator', ['limit' => 10]);\n\n// Grab the next 10 Moderators\n$moreMods = $repo->findBy('type', 'Moderator', ['limit' => 10, 'offset' => 10]);\n\n\n\n\ndelete() Method\n\n\nPurpose:\n \n\nThe delete() method is for deleting a single object from a database based on the\nobject's unique ID. It will call the object's own \"delete\" method for cleanup\nbefore removing the record from the database.\n\n\nFormat:\n\n\ndelete(id)\n\n\n\n\nExamples:\n  \n\n\n// Create Repository\n$repo = \\Cora\\RepositoryFactory::make('User');\n\n// Delete a user.\n$repo->delete($id);\n\n\n\n\nsave() Method\n\n\nPurpose:\n \n\nThe save() method is for persisting one or more objects. Usually this means saving\nrecords in a database. If the object(s) already exists in the database, then\nany changes will be updated. If the object(s) does not exist, then it will be\ninserted.\n\n\nFormat:\n\n\nsave(Cora_Model | ResultSet_of_Cora_Models [, table] [, id_name])\n\n\n\n\nThe Table and Id_name optional parameters are for overriding default model behavior\nif necessary. The refer to the table/collection the object should be saved to,\nand the unique identifying column for the object. You probably don't need to use\nthese! Check out the RepositoryFactory options near the top of this page for a\nway you can set these options for all operations on a Repository.\n\n\nExamples:\n  \n\n\n// Create Repository\n$repo = \\Cora\\RepositoryFactory::make('User');\n\n/////////////////////////////////////////////\n// Modify a single existing user.\n/////////////////////////////////////////////\n\n// Grab a user Object\n$user = $repo->find($id);\n\n// Change something\n$user->email = 'BobsNewEmail@fakeEmail.com';\n\n// Save the changes.\n$repo->save($user);\n\n\n\n////////////////////////////////////////////\n// Save a completely new user.\n////////////////////////////////////////////\n\n// Create a user object.\n$user = new User('Bob', 'Bob@fakeEmail.com');\n\n// Save the user to the database.\n$repo->save($user);\n\n\n\n////////////////////////////////////////////\n// Modify a collection of users.\n// We'll pretend we're crediting our 'premium'\n// users some amount to their account.\n////////////////////////////////////////////\n\n// Grab a collection of users.\n$users = $repo->findBy('type', 'Premium');\n\n// Change something\nforeach ($users as $user) {\n    $user->accountCredit += 100;\n}\n\n// Save the changes.\n$repo->save($users);\n\n\n\n////////////////////////////////////////////\n// Assign a collection of objects to a user.\n////////////////////////////////////////////\n\n// Grab a user Object\n$user = $repo->find($id);\n\n// Assign a collection of articles to the user\n$user->articles =   new \\Cora\\ResultSet([\n                        new Article('How to Fly a Plane'),\n                        new Article('How to Make Money')\n                    ]);\n\n// Save the changes.\n$repo->save($user);\n\n\n\n////////////////////////////////////////////\n// Add to an existing collection of objects\n////////////////////////////////////////////\n\n// Grab a user Object\n$user = $repo->find($id);\n\n// Add a new article to the collection of articles this user has.\n$user->articles->add(new Article('How to Make Money Vol2'));\n\n// Save the changes.\n$repo->save($user);",
            "title": "Repository"
        },
        {
            "location": "/documentation/amblend/repository/#repository-class",
            "text": "The purpose of the Repository is to separate the logic that retrieves data from\nthe persistence layer from the models themselves and the business logic that\nacts on those models. The Repository acts as a sort of controller that utilizes\na Gateway for direct access to data and a Factory for creating objects.",
            "title": "Repository Class"
        },
        {
            "location": "/documentation/amblend/repository/#creating-a-repository",
            "text": "There's a few different ways to get a Repository depending on the situation. The\nmost general purpose and easiest solution is usually to utilize the RepositoryFactory\nclass. However, for situations where you need to utilize a custom Gateway or Factory,\ncreating a Repository without using the factory may be desired. Finally, if you\nalready have an instance of a model, you can ask a model to give you a repository\nmatching its type.",
            "title": "Creating a Repository"
        },
        {
            "location": "/documentation/amblend/repository/#using-repositoryfactory",
            "text": "For simple class namespaces, it's easiest to just type the name in like so:  class MyController extends \\MyApp {\n    public function demo()\n    {\n        $repo = \\Cora\\RepositoryFactory::make('User');\n        $user = $repo->find($id);\n    }\n}  For more advanced namespaces, you can take advantage of Use statements by utilizing\nthe \"class\" keyword:  use \\System\\Blog\\Bug\\Task\\Note;\nclass MyController extends \\MyApp {\n    public function demo()\n    {\n        $repo = \\Cora\\RepositoryFactory::make(Note::class);\n        $user = $repo->find($id);\n\n        // OR you can still do\n\n        $repo = \\Cora\\RepositoryFactory::make('\\\\System\\\\Blog\\\\Bug\\\\Task\\\\Note');\n        $user = $repo->find($id);\n    }\n}",
            "title": "Using RepositoryFactory"
        },
        {
            "location": "/documentation/amblend/repository/#repositoryfactory-options",
            "text": "While we're on the topic of using the RepositoryFactory, now is a good time to look\nat its make() method definition and the options it gives you.  make($class, $idField = false, $table = false, $freshAdaptor = false, $db = false)   The $class parameter is the object type you'll be using the repository for.  The optional $idField parameter is for setting the unique ID field which will be\nused to fetch objects from a database. You'll most likely want to set this if your\nID column is something other than 'id'.  The optional $table parameter is for overriding the defaults as defined in a model. If\nthis parameter is defined, it will be passed to the Gateway as the table/collection\nto fetch objects from.  The optional $freshAdaptor is a setting you'll most likely not ever need to use. See my explanation\nafter this list for more details.  The optional $db let's you pass in a custom Cora database connection for the Gateway to use.\nThis can be used to force the Repository and Dynamic Loading to use a connection to\na Test database for testing purposes.   Explanation of $freshAdaptor:  \n    WARNING: Please don't confuse yourself by reading this section unless you are\n    an advanced developer interested in writing your own Gateway implementations.  AmBlend is\nbuilt using Cora's Database class, and since most apps probably only use a single\ndatabase, part of the database setup process is setting a \"default connection\".\nWhen fetching models, if no particular connection is specified in the model definition, AmBlend\nwill default to using the default connection. In order to make this typical use case more\nefficient, the Database class stores an instance of the default DB as a static data member.\nWhen a database operation involving the default database is performed, this statically stored\ndefault will be used rather than creating a new instance each time.\nIn most cases this is great! However, because Cora's Database\nclass can only handle building 1 query at a time, if you end up in a situation where\nin the middle of building a query, you need to pause and perform another query on\nthe default connection, this can cause problems. In this scenario, what you need is\na fresh version of the adaptor and not the statically stored one. Setting $freshAdaptor\nto true gives you a new database class.  I realize that explanation is a little hard to follow, but the reason for the $freshAdaptor\nparameter's existence has to do with the inner optimization workings of Cora, and\nis inherently complicated for that reason. The good news is that unless you start building\nyour own custom gateway classes, I can't really think of a reason you'd need to use or\nunderstand it.  The backstory on this feature is that Cora's Gateway walks through a loop of a model's\nattributes and builds up the query to save the model to the database. However, when\na related object is encountered, it recursively calls the Save() method on that related\nobject at the time it encounters it. Because the default adaptor was already being used to build\nup a query, that recursive call to the Save() method on the related object was causing conflicts if the\nrelated object also used the default adaptor (due to the one query at a time restriction\non a Cora Database class and the default database being stored statically).",
            "title": "RepositoryFactory Options"
        },
        {
            "location": "/documentation/amblend/repository/#using-custom-setup",
            "text": "For situations where you want to swap out components of the repository system\nwith your own custom classes, you'll need to bypass the RepositoryFactory and just\ndo the setup yourself. The general format is as follows:  $db = \\Cora\\Database::getDb('name_of_db_connection_to_use');\n$class = 'User';\n$factory = new Factory($class, $db);\n$gateway = new Gateway($db);\n$repo    = new Repository($gateway, $factory);",
            "title": "Using Custom Setup"
        },
        {
            "location": "/documentation/amblend/repository/#using-model-method",
            "text": "If you're in a situation where you created an instance of a Cora Model class,\nand now you need a repository for it to persist it or whatever, you can take advantage\nof Cora Model's knowledge on how to create repositories for themselves:  $user = new \\User('Josiah', 'SuperAdmin');\n$user->location = new Location('JoesHouse', 'Portland');\n$user->job      = new Job('Librarian', 'Keeper of knowledge!');\n$repo = $user->getRepository();\n$repo->save($user);",
            "title": "Using Model Method"
        },
        {
            "location": "/documentation/amblend/repository/#using-a-repository",
            "text": "",
            "title": "Using a Repository"
        },
        {
            "location": "/documentation/amblend/repository/#find-method",
            "text": "Purpose:   \nThe find() method is for grabbing a single object from a database based on the\nobject's unique ID.  Format:  find(id)  Examples:     // Create Repository\n$repo = \\Cora\\RepositoryFactory::make('User');\n\n// Grab a user Object\n$user = $repo->find($id);",
            "title": "find() Method"
        },
        {
            "location": "/documentation/amblend/repository/#findone-method",
            "text": "Purpose:   \nThe findOne() method is for grabbing a single object from a database based on\nthe passed in query parameters.  Format:  findOne(coraDbQuery)  Examples:     // Create Repository\n$repo = \\Cora\\RepositoryFactory::make('User');\n\n// Grab an instance of database adaptor for this model.\n$db = $repo->getDb();\n\n// Define some db query parameters.\n$db->where('name', 'testUser');\n\n// Grab a user Object matching query.\n$user = $repo->findOne($db);",
            "title": "findOne() Method"
        },
        {
            "location": "/documentation/amblend/repository/#findall-method",
            "text": "Purpose:   \nThe findAll() method is for grabbing all objects from a database collection.\nThe results can be limited by optionally passing along query parameters.  Format:  findAll([coraDbQuery])  Examples:     // Create Repository\n$repo = \\Cora\\RepositoryFactory::make('User');\n\n// Fetch ALL users.\n$allUsers = $repo->findAll();\n\n// Grab an instance of database adaptor for this model.\n$db = $repo->getDb();\n\n// Define some db query parameters.\n$db->where('type', 'Admin');\n\n// Grab a subset of users. In this case all users who are Admins.\n$admins = $repo->findAll($db);",
            "title": "findAll() Method"
        },
        {
            "location": "/documentation/amblend/repository/#findby-method",
            "text": "Purpose:   \nThe findBy() method is for grabbing a set of objects based on a simple restriction.\nThis has the same basic functionality as findAll(), but is simpler to use with\nthe tradeoff of being less flexible.  Format:  // options = array(['order_by' => 'desc|asc'] [, 'limit' => number [, 'offset' => number]])\nfindBy(property, value [, options])  Because the \"options\" is kinda hard to read above let me just verbally describe it.\nYou can pass in an associative array with up to 3 keys, those being \"order_by\",\n\"limit\", and \"offset\". Order_by should be either \"desc\" or \"asc\", and limit and offset\nshould be numbers. Offset doesn't do anything unless you also pass in a Limit.  Examples:     // Create Repository\n$repo = \\Cora\\RepositoryFactory::make('User');\n\n// Grab users who are Admins.\n$admins = $repo->findBy('type', 'Admin');\n\n// Grab users who are Moderators, but only return the first 10.\n$mods = $repo->findBy('type', 'Moderator', ['limit' => 10]);\n\n// Grab the next 10 Moderators\n$moreMods = $repo->findBy('type', 'Moderator', ['limit' => 10, 'offset' => 10]);",
            "title": "findBy() Method"
        },
        {
            "location": "/documentation/amblend/repository/#delete-method",
            "text": "Purpose:   \nThe delete() method is for deleting a single object from a database based on the\nobject's unique ID. It will call the object's own \"delete\" method for cleanup\nbefore removing the record from the database.  Format:  delete(id)  Examples:     // Create Repository\n$repo = \\Cora\\RepositoryFactory::make('User');\n\n// Delete a user.\n$repo->delete($id);",
            "title": "delete() Method"
        },
        {
            "location": "/documentation/amblend/repository/#save-method",
            "text": "Purpose:   \nThe save() method is for persisting one or more objects. Usually this means saving\nrecords in a database. If the object(s) already exists in the database, then\nany changes will be updated. If the object(s) does not exist, then it will be\ninserted.  Format:  save(Cora_Model | ResultSet_of_Cora_Models [, table] [, id_name])  The Table and Id_name optional parameters are for overriding default model behavior\nif necessary. The refer to the table/collection the object should be saved to,\nand the unique identifying column for the object. You probably don't need to use\nthese! Check out the RepositoryFactory options near the top of this page for a\nway you can set these options for all operations on a Repository.  Examples:     // Create Repository\n$repo = \\Cora\\RepositoryFactory::make('User');\n\n/////////////////////////////////////////////\n// Modify a single existing user.\n/////////////////////////////////////////////\n\n// Grab a user Object\n$user = $repo->find($id);\n\n// Change something\n$user->email = 'BobsNewEmail@fakeEmail.com';\n\n// Save the changes.\n$repo->save($user);\n\n\n\n////////////////////////////////////////////\n// Save a completely new user.\n////////////////////////////////////////////\n\n// Create a user object.\n$user = new User('Bob', 'Bob@fakeEmail.com');\n\n// Save the user to the database.\n$repo->save($user);\n\n\n\n////////////////////////////////////////////\n// Modify a collection of users.\n// We'll pretend we're crediting our 'premium'\n// users some amount to their account.\n////////////////////////////////////////////\n\n// Grab a collection of users.\n$users = $repo->findBy('type', 'Premium');\n\n// Change something\nforeach ($users as $user) {\n    $user->accountCredit += 100;\n}\n\n// Save the changes.\n$repo->save($users);\n\n\n\n////////////////////////////////////////////\n// Assign a collection of objects to a user.\n////////////////////////////////////////////\n\n// Grab a user Object\n$user = $repo->find($id);\n\n// Assign a collection of articles to the user\n$user->articles =   new \\Cora\\ResultSet([\n                        new Article('How to Fly a Plane'),\n                        new Article('How to Make Money')\n                    ]);\n\n// Save the changes.\n$repo->save($user);\n\n\n\n////////////////////////////////////////////\n// Add to an existing collection of objects\n////////////////////////////////////////////\n\n// Grab a user Object\n$user = $repo->find($id);\n\n// Add a new article to the collection of articles this user has.\n$user->articles->add(new Article('How to Make Money Vol2'));\n\n// Save the changes.\n$repo->save($user);",
            "title": "save() Method"
        },
        {
            "location": "/documentation/amblend/model/",
            "text": "Model Class\n\n\nThe purpose of Cora's Model class is to provide methods that allow Gateways\nto examine the properties and relations of models, and to give models the knowledge\nof the Repository system's existence and the Repository's responsibility for grabbing and\npersisting models. This enables the ActiveRecord like features of AmBlend\nsuch as dynamic loading.\n\n\nCreating a Cora Model\n\n\nTo create a Cora Model, you just need to have your model extend \\Cora\\Model like\nsuch:\n\n\nclass SomeModel extends \\Cora\\Model {}\n\n\n\n\nHowever, to actually make your model do anything useful, you need to define your\nmodel using some data members so that AmBlend knows how to use it. The core of\nthis definition, is the \"model_attributes\" array.\n\n\nAttributes\n\n\ntl;dr - A Cora model's attributes define the data that composes the model.\n\n\nNormally when talking about data members for a class in PHP, the term \"properties\" is used.\nHowever, since it's possible to define properties on a Cora model just like you would any\nother class, \"attributes\" is the term I've coined to describe those model properties\nthat relate directly to AmBlend so that the two don't get confused.\n\n\nLet's jump right in to how it works, as it's easier to describe using examples.\n\n\nHow it Works\n\n\nLet's say you have a model definition that looks like the following:\n\n\nclass User extends \\Cora\\Model {\n\n    // Normal properties\n    // These WON'T be saved to the database.\n    protected $lastAction;\n\n    // Amblend properties\n    // aka the model's \"Attributes\"\n    // These WILL be saved in the database.\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar'\n        ],\n        'type'  => [\n            'type' => 'varchar'\n        ]\n    ];\n\n    public function __construct($name = null, $email = null, $type = null)\n    {\n        $this->name     = $name;\n        $this->email    = $email;\n        $this->type     = $type;\n    }\n\n    public function changeName($newName) {\n        $this->name = $newName;\n        $this->lastAction = 'Changed Name';\n    }\n\n    public function getName() {\n        return $this->name;\n    }\n\n    public function getLastAction() {\n        return $this->lastAction;\n    }\n}\n\n\n\n\nIn the example, we've defined a normal property called \"lastAction\" which we're\nusing to keep track of the last action that was performed by/on that user. However,\nsince we defined it as a normal property and not a model attribute, that means\nthe lastAction WILL NOT get saved to the database if we save the model. That's\nsuper important to understand! You can use normal class properties, but only those\nattributes defined in the $model_attributes property will be persisted (saved).\nThis makes the \"$model_attributes\" property the backbone that supports all of\nAmBlend's functionality.\n\n\nIn terms of implementation, as can be seen in the example above, $model_attributes\nis just an associative array where the key is the name of the attribute, and the\nvalue is another associative array for defining that attribute's details. The\nmost basic detail which I always recommend including is that attribute's \"type\".\nBy defining this, you can use AmBlend's automated database creation tool.\n\n\nDefinition\n\n\nBelow are the basic properties you can use to describe an attribute definition.\n\n\n\n    \n\n        \nAttribute Name\n\n        \nValid Values\n\n        \nDescription\n\n    \n\n    \n\n        \ntype\n\n        \n\n            \n\n            \ntinyint, smallint, mediumint, int, bigint\n\n            \nvarchar, char,\n\n            \nfloat,\n\n            \ndate, datetime,\n\n            \nboolean,\n\n            \nbinary,\n\n            \ntinytext, text, mediumtext, longtext\n\n            \ntinyblob, mediumblob, blob, longblob\n\n            \n\n        \n\n        \nFor setting the \"type\" field in a DB.\n\n    \n\n    \n\n        \nsize\n\n        \n{integer}\n\n        \nThe size of the field in the DB. If size is not set and the type is 'varchar', size will default to 255 when using MySQL adaptor.\n\n    \n\n    \n\n        \nprecision\n\n        \n{integer}\n\n        \nIf the type is a float, this sets the places after the decimal point.\n\n    \n\n    \n\n        \nprimaryKey\n\n        \ntrue\n\n        \nThis should only be set for ONE attribute per model.\n\n    \n\n    \n\n        \nautoIncrement\n\n        \ntrue\n\n        \nIs the field auto-incrementing in value?\n\n    \n\n    \n\n        \ndefaultValue\n\n        \n'Some String'\n\n        \n\n            Sets a default value for this attribute. If this value needs to be\n            an object, or dynamically generated, then use the beforeCreate() lifecycle\n            callback to assign a default value. See the lifecycle callbacks section\n            for more info.\n        \n\n    \n\n    \n\n        \nenum\n\n        \n'value1', 'value2', 'value3'\n\n        \nThe valid values if the field type is set to 'enum'.\n        I don't actually recommend you use ENUM if you're starting a new project\n        (it may be hard to support across various database types).\n        This feature is mostly present for integration with existing projects.\n\n    \n\n    \n\n        \nunique\n\n        \ntrue\n\n        \nTells the database that the values of this attribute should be unique.\n\n    \n\n    \n\n        \nindex\n\n        \ntrue\n\n        \nMake an index for this attribute.\n\n    \n\n\n\n\n\nFor a slightly more detailed example, let's modify our User definition from above\nfor the user 'type' attribute. Let's say we know we don't need 255 characters (the default)\nfor the type, and also we want the default user type to be just 'User'. Furthermore,\nlet's say we know we'll be searching a lot by email, so we want to index the email attribute:\n\n\npublic $model_attributes = [\n    'id' => [\n        'type'          => 'int',\n        'primaryKey'    => true\n    ],\n    'name' => [\n        'type' => 'varchar'\n    ],\n    'email' => [\n        'type' => 'varchar',\n        'index' => true\n    ],\n    'type'  => [\n        'type' => 'varchar',\n        'size' => 55,\n        'defaultValue' => 'User'\n    ]\n];\n\n\n\n\nNow if you generate a database using AmBlend's database generation tool, it will\nreflect these changes.\n\n\nObject Relations\n\n\nAlright, hopefully the general gist of how to define a model's attributes is becoming\nclearer. An important thing we haven't addressed yet is how to setup relationships\nwith other objects. This is where things get exciting and Cora's AmBlend really shines.\nGoing back to our User object example, let's say a user has a Location associated\nwith them as well as a number of articles they've written (maybe we're running a\nblogging site or something). We would setup this relationship like so:\n\n\npublic $model_attributes = [\n    'id' => [\n        'type'          => 'int',\n        'primaryKey'    => true\n    ],\n    'name' => [\n        'type' => 'varchar'\n    ],\n    'email' => [\n        'type' => 'varchar',\n        'index' => true\n    ],\n    'type'  => [\n        'type' => 'varchar',\n        'size' => 55,\n        'defaultValue' => 'User'\n    ],\n    'location' => [\n        'model' => 'location'\n    ],\n    'articles' => [\n        'models' => 'article'\n    ]\n];\n\n\n\n\nThat's it! Notice the plural 's' on 'models' for referring to articles the user\nhas written, and the singular 'model' for representing the user's location.\n\n\nOf course, now you may be wondering how to actually USE this, but that's equally\nas intuitive and easy. Going back to the non-relational attributes like 'Type',\nif you had an existing user and you wanted to change their user type from 'User'\nto 'Moderator', you would do that like this:\n\n\n// Grab user. 'repo' is a User repository.\n$user = $this->repo->find($id);\n\n// Change their type\n$user->type = 'Moderator';\n\n// Save the change\n$repo->save($user);\n\n\n\n\nWorking with related objects is the same concept! Let's associate a new Location\nand set of Articles with a user:\n\n\n// Grab user:\n$user = $this->repo->find($id);\n\n// Associate a location to this user:\n$user->location = new Location('Fuel Medical LLC', 'Camas', 'WA');\n\n// Associate a set of Articles to this user:\n$user->articles =   new \\Cora\\ResultSet([\n                        new Article('How to Write Good Code'),\n                        new Article('How to Unit Test')\n                    ]);\n\n// Save the changes\n$repo->save($user);\n\n\n\n\nFor basic usage with a single database, that's pretty much all you need to know.\nHowever, if you're an advanced user and will have your data spread across multiple\ndatabases and/or you want more control over the setup of the database\n(like maybe you're integrating Cora into an existing database), then read on.\n\n\nUsing Multiple Databases\n\n\nThe database config file for Cora holds an array that let's you define multiple\ndatabase connections. If you've gone through the setup process, you've undoubtably\nseen it, but here's a reminder of how this looks:\n\n\n$dbConfig['defaultConnection'] = 'mainDb';\n$dbConfig['connections'] = [\n    'mainDb' => [\n        'adaptor'   => 'MySQL',\n        'host'      => 'localhost:3306',\n        'dbName'    => 'cora',\n        'dbUser'    => 'root',\n        'dbPass'    => 'root'\n    ],\n    'secondaryDb' => [\n        'adaptor'   => 'MySQL',\n        'host'      => 'localhost:3306',\n        'dbName'    => 'cora2',\n        'dbUser'    => 'root',\n        'dbPass'    => 'root'\n    ],\n    'mongoDb' => [\n        'adaptor'   => 'MongoDb',\n        'host'      => 'localhost:3306',\n        'dbName'    => 'cora3',\n        'dbUser'    => 'root',\n        'dbPass'    => 'root'\n    ]\n];\n\n\n\n\nIn this config file you define the connection details for each database, tell\nit what Cora database adaptor to use with that connection, and give each connection\na name.\n\n\nIn order to make use of multiple connections, you have to specify that some of your\nmodels use a connection which is different from the default. Like so:\n\n\nclass Guide extends MyModel {\n\n    public $model_connection = 'secondaryDb';\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'title' => [\n            'type' => 'varchar'\n        ],\n        'authors' => [\n            'models' => 'user'\n        ]\n    ];\n\n    public function __construct($title = null)\n    {\n        $this->title = $title;\n    }\n\n}\n\n\n\n\nNow when you generate your database, the Guides table/collection will get created\nusing the 'secondaryDb' connection instead of the main one. Similarly, grabbing\nGuide object from the DB using a repository will use this secondaryDb connection\ntoo:\n\n\n$repo = \\Cora\\RepositoryFactory::make('Guide');\n$guide = $repo->find($id);\n\n\n\n\nThe spot where you could run into trouble is when you want a two-way reference between\nobjects in different databases. For example, looking at our Guide definition above\nyou can see we have a reference to one or more User models representing the authors\nof said guide. But what if our Users model also keeps a reference to Guides a user\nhas been an author of? Let's add a reference to Guides in our User model:\n\n\nNote: Because our User model was defined as using the default connection\n(we didn't tell it to use anything different) AmBlend will know to fetch the authors\nfrom the main database.\n\n\npublic $model_attributes = [\n    'id' => [\n        'type'          => 'int',\n        'primaryKey'    => true\n    ],\n    'name' => [\n        'type' => 'varchar'\n    ],\n    'email' => [\n        'type' => 'varchar',\n        'index' => true\n    ],\n    'type'  => [\n        'type' => 'varchar',\n        'size' => 55,\n        'defaultValue' => 'User'\n    ],\n    'location' => [\n        'model' => 'location'\n    ],\n    'articles' => [\n        'models' => 'article'\n    ],\n    'guides' => [\n        'models' => 'guide'\n    ]\n];\n\n\n\n\nSo now we have a reference to Users from a Guide, and a reference to Guides from\na User. The way these are related is by using a relation table. If you aren't\nfamiliar with relation tables, see the image below for the general idea. Basically\nit's a really simple table that holds relationships (shocking right!?). In this\nscreenshot, guides 9 and 10 are associated with a user who's ID is '1', and\nguide 11 is associated with whoever user '2' is:\n\n\n\n\nThe problem lies in the question of \"Which database is going to hold the relation\ntable?\" Having to maintain redundant tables on each database and then remembering\nto alter both anytime a relationship changes is just plain dumb, and assuming\nthat the relationship will be kept in the default database didn't feel like an\nassumption I could make for sure either. Thus, in order to solve this problem\nI've introduced the concept of 'passive' sides in a multi-database relationship.\n\n\nTo fix our User & Guide model definitions as we've defined them above, we need to\nmark one side of that relationship as the 'passive' side like so:\n\n\nclass User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'type'  => [\n            'type' => 'varchar',\n            'size' => 55,\n            'defaultValue' => 'User'\n        ],\n        'location' => [\n            'model' => 'location'\n        ],\n        'articles' => [\n            'models' => 'article'\n        ],\n        'guides' => [\n            'models' => 'guide',\n            'passive' => true\n        ]\n    ];\n}\n\n\n\n\nBy marking the User side of the relationship as the passive side, AmBlend will\nnow know to make the relationship table on the database represented by Guide's\nconnection.\n\n\nAdvanced Configuration\n\n\nAlright, using AmBlend's automated database creation feature and simply setting\nrelationships as singular \"model\" or plural \"models\" and letting AmBlend handle the\nrest is nice and all for new projects. But let's talk about configuration options\nfor incorporating AmBlend into a pre-existing database where you have to work within\nthe constraints of the existing setup.\n\n\nFirst off, let's talk table names.\n\n\nChange the table to which a model is mapped\n\n\nBy default, a table/collection name will be the plural version of the model. For\ninstance: our User model will be stored in a table called \"users\". Our Guide model\nwill be stored in a table called \"guides\" and so on and so forth. If this behavior\nwon't work with your existing database for a particular model, you have the option\nto specify a different name.\n\n\nLet's say you are building an internal app to be used\nby your company and you want the User model to map to a table named \"employees\".\nYou would specify that like so:\n\n\nclass User extends \\Cora\\Model {\n\n    public $model_table = 'employees';\n    public $model_attributes = [\n        ... stuff here ...\n    ];\n}\n\n\n\n\nChange the name of a relation table\n\n\nWhenever you specify a simple plural relationship from one model to another like\nso:\n\n\nclass User extends \\Cora\\Model {\n\n    public $model_attributes = [\n        'articles' => [\n            'models' => 'article'\n        ]\n    ];\n}\n\n\n\n\nA relation table is used that is named by making the models involved plural and\nappending them together with an underscore in reverse alphabetical order.\nIn the example above of a User associated with an Article the resulting relation\ntable name would be \"users_articles\".\n\n\nIf you're fine with the use of a relation table, but you need to change the name\nof it. You can do so by utilizing the 'relTable' setting like this:\n\n\nclass User extends \\Cora\\Model {\n\n    public $model_attributes = [\n        'articles' => [\n            'models' => 'article',\n            'relTable' => 'some_custom_relation_table_name'\n        ]\n    ];\n}\n\n\n\n\nThe one caveat here is that at the time of this writing, I do not support custom\ncolumn names within the relation table. The relation table column names must be\nthe name of the model who's ID they hold. For the above example with User and\nArticle, the relation table will need a 'user' column and an 'article' column. If\nyou have existing relation tables that don't follow this format, you'll have to change\nthem or else not use AmBlend.\n\n\nOne-to-Many via an \"owner\" column\n\n\nThe default setup for plural relationships in AmBlend is the use of relation tables\njust because they are the most flexible. However, if you want to force the use of\nan \"owner\" type column in a one-to-many relationship either because it's your\npersonal preference or it's necessary to integrate with an existing database, AmBlend\nmakes this possible.\n\n\nWhat you'll need to do is just throw a 'via' setting in with a plural model definition.\nFor instance, let's say we don't care about supporting multiple authors for an article\non our site, but rather just want an article to have a single owner and we want to\nstore a reference to this owner in the articles table via an \"owner\" column. We\ndo that like this:\n\n\nclass User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'type'  => [\n            'type' => 'varchar',\n            'size' => 55,\n            'defaultValue' => 'User'\n        ],\n        'location' => [\n            'model' => 'location'\n        ],\n        'articles' => [\n            'models' => 'article',\n            'via'    => 'owner'\n        ]\n    ];\n}\n\n\n\n\nOne-to-One using a relation table\n\n\nBy default, one-to-one relationships are stored as a column on the model's table.\nFor instance, the following definition for a related Job object would be stored\nas seen in the picture below:\n\n\nclass User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'type'  => [\n            'type' => 'varchar',\n            'size' => 55,\n            'defaultValue' => 'User'\n        ],\n        'job' => [\n            'model' => 'job'\n        ]\n    ];\n}\n\n\n\n\n\"users\" table:\n \n\n\n\n\nHowever, if for some reason you wanted to force a single reference to use a relation\ntable (maybe you felt it could change to a plural relationship in the future or something),\nyou could do so by specifying \"usesRefTable\" as true:\n\n\nclass User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'type'  => [\n            'type' => 'varchar',\n            'size' => 55,\n            'defaultValue' => 'User'\n        ],\n        'job' => [\n            'model' => 'job',\n            'usesRefTable' => true\n        ]\n    ];\n}\n\n\n\n\nOptionally you can of course combine this with the previously talked about\n\"relTable\" option to specify the name of the relation table if the default naming\ndoesn't work for you.\n\n\nNamespaces\n\n\nJust a quick explanation of namespaces in the model definition...\n\n\nWhen defining related models in your $model_attributes array, namespaces are\nalways absolute, never relative. See the namespaced Notes model below and the\nrelationship definition added to User for an example:\n\n\n<?php\nnamespace Task;\n\nclass Note extends \\Note {\n\n    public $model_table = 'notes_tasks';\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'title' => [\n            'type' => 'varchar'\n        ],\n        'note' => [\n            'type' => 'text'\n        ],\n        'owner' => [\n            'model' => 'user'\n        ]\n    ];\n}\n\n\n\n\nclass User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'type'  => [\n            'type' => 'varchar',\n            'size' => 55,\n            'defaultValue' => 'User'\n        ],\n        'notes' => [\n            'models' => 'task\\\\note',\n            'via'    => 'owner'\n        ]\n    ];\n}",
            "title": "Model"
        },
        {
            "location": "/documentation/amblend/model/#model-class",
            "text": "The purpose of Cora's Model class is to provide methods that allow Gateways\nto examine the properties and relations of models, and to give models the knowledge\nof the Repository system's existence and the Repository's responsibility for grabbing and\npersisting models. This enables the ActiveRecord like features of AmBlend\nsuch as dynamic loading.",
            "title": "Model Class"
        },
        {
            "location": "/documentation/amblend/model/#creating-a-cora-model",
            "text": "To create a Cora Model, you just need to have your model extend \\Cora\\Model like\nsuch:  class SomeModel extends \\Cora\\Model {}  However, to actually make your model do anything useful, you need to define your\nmodel using some data members so that AmBlend knows how to use it. The core of\nthis definition, is the \"model_attributes\" array.",
            "title": "Creating a Cora Model"
        },
        {
            "location": "/documentation/amblend/model/#attributes",
            "text": "tl;dr - A Cora model's attributes define the data that composes the model.  Normally when talking about data members for a class in PHP, the term \"properties\" is used.\nHowever, since it's possible to define properties on a Cora model just like you would any\nother class, \"attributes\" is the term I've coined to describe those model properties\nthat relate directly to AmBlend so that the two don't get confused.  Let's jump right in to how it works, as it's easier to describe using examples.",
            "title": "Attributes"
        },
        {
            "location": "/documentation/amblend/model/#how-it-works",
            "text": "Let's say you have a model definition that looks like the following:  class User extends \\Cora\\Model {\n\n    // Normal properties\n    // These WON'T be saved to the database.\n    protected $lastAction;\n\n    // Amblend properties\n    // aka the model's \"Attributes\"\n    // These WILL be saved in the database.\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar'\n        ],\n        'type'  => [\n            'type' => 'varchar'\n        ]\n    ];\n\n    public function __construct($name = null, $email = null, $type = null)\n    {\n        $this->name     = $name;\n        $this->email    = $email;\n        $this->type     = $type;\n    }\n\n    public function changeName($newName) {\n        $this->name = $newName;\n        $this->lastAction = 'Changed Name';\n    }\n\n    public function getName() {\n        return $this->name;\n    }\n\n    public function getLastAction() {\n        return $this->lastAction;\n    }\n}  In the example, we've defined a normal property called \"lastAction\" which we're\nusing to keep track of the last action that was performed by/on that user. However,\nsince we defined it as a normal property and not a model attribute, that means\nthe lastAction WILL NOT get saved to the database if we save the model. That's\nsuper important to understand! You can use normal class properties, but only those\nattributes defined in the $model_attributes property will be persisted (saved).\nThis makes the \"$model_attributes\" property the backbone that supports all of\nAmBlend's functionality.  In terms of implementation, as can be seen in the example above, $model_attributes\nis just an associative array where the key is the name of the attribute, and the\nvalue is another associative array for defining that attribute's details. The\nmost basic detail which I always recommend including is that attribute's \"type\".\nBy defining this, you can use AmBlend's automated database creation tool.",
            "title": "How it Works"
        },
        {
            "location": "/documentation/amblend/model/#definition",
            "text": "Below are the basic properties you can use to describe an attribute definition.  \n     \n         Attribute Name \n         Valid Values \n         Description \n     \n     \n         type \n         \n             \n             tinyint, smallint, mediumint, int, bigint \n             varchar, char, \n             float, \n             date, datetime, \n             boolean, \n             binary, \n             tinytext, text, mediumtext, longtext \n             tinyblob, mediumblob, blob, longblob \n             \n         \n         For setting the \"type\" field in a DB. \n     \n     \n         size \n         {integer} \n         The size of the field in the DB. If size is not set and the type is 'varchar', size will default to 255 when using MySQL adaptor. \n     \n     \n         precision \n         {integer} \n         If the type is a float, this sets the places after the decimal point. \n     \n     \n         primaryKey \n         true \n         This should only be set for ONE attribute per model. \n     \n     \n         autoIncrement \n         true \n         Is the field auto-incrementing in value? \n     \n     \n         defaultValue \n         'Some String' \n         \n            Sets a default value for this attribute. If this value needs to be\n            an object, or dynamically generated, then use the beforeCreate() lifecycle\n            callback to assign a default value. See the lifecycle callbacks section\n            for more info.\n         \n     \n     \n         enum \n         'value1', 'value2', 'value3' \n         The valid values if the field type is set to 'enum'.\n        I don't actually recommend you use ENUM if you're starting a new project\n        (it may be hard to support across various database types).\n        This feature is mostly present for integration with existing projects. \n     \n     \n         unique \n         true \n         Tells the database that the values of this attribute should be unique. \n     \n     \n         index \n         true \n         Make an index for this attribute. \n       For a slightly more detailed example, let's modify our User definition from above\nfor the user 'type' attribute. Let's say we know we don't need 255 characters (the default)\nfor the type, and also we want the default user type to be just 'User'. Furthermore,\nlet's say we know we'll be searching a lot by email, so we want to index the email attribute:  public $model_attributes = [\n    'id' => [\n        'type'          => 'int',\n        'primaryKey'    => true\n    ],\n    'name' => [\n        'type' => 'varchar'\n    ],\n    'email' => [\n        'type' => 'varchar',\n        'index' => true\n    ],\n    'type'  => [\n        'type' => 'varchar',\n        'size' => 55,\n        'defaultValue' => 'User'\n    ]\n];  Now if you generate a database using AmBlend's database generation tool, it will\nreflect these changes.",
            "title": "Definition"
        },
        {
            "location": "/documentation/amblend/model/#object-relations",
            "text": "Alright, hopefully the general gist of how to define a model's attributes is becoming\nclearer. An important thing we haven't addressed yet is how to setup relationships\nwith other objects. This is where things get exciting and Cora's AmBlend really shines.\nGoing back to our User object example, let's say a user has a Location associated\nwith them as well as a number of articles they've written (maybe we're running a\nblogging site or something). We would setup this relationship like so:  public $model_attributes = [\n    'id' => [\n        'type'          => 'int',\n        'primaryKey'    => true\n    ],\n    'name' => [\n        'type' => 'varchar'\n    ],\n    'email' => [\n        'type' => 'varchar',\n        'index' => true\n    ],\n    'type'  => [\n        'type' => 'varchar',\n        'size' => 55,\n        'defaultValue' => 'User'\n    ],\n    'location' => [\n        'model' => 'location'\n    ],\n    'articles' => [\n        'models' => 'article'\n    ]\n];  That's it! Notice the plural 's' on 'models' for referring to articles the user\nhas written, and the singular 'model' for representing the user's location.  Of course, now you may be wondering how to actually USE this, but that's equally\nas intuitive and easy. Going back to the non-relational attributes like 'Type',\nif you had an existing user and you wanted to change their user type from 'User'\nto 'Moderator', you would do that like this:  // Grab user. 'repo' is a User repository.\n$user = $this->repo->find($id);\n\n// Change their type\n$user->type = 'Moderator';\n\n// Save the change\n$repo->save($user);  Working with related objects is the same concept! Let's associate a new Location\nand set of Articles with a user:  // Grab user:\n$user = $this->repo->find($id);\n\n// Associate a location to this user:\n$user->location = new Location('Fuel Medical LLC', 'Camas', 'WA');\n\n// Associate a set of Articles to this user:\n$user->articles =   new \\Cora\\ResultSet([\n                        new Article('How to Write Good Code'),\n                        new Article('How to Unit Test')\n                    ]);\n\n// Save the changes\n$repo->save($user);  For basic usage with a single database, that's pretty much all you need to know.\nHowever, if you're an advanced user and will have your data spread across multiple\ndatabases and/or you want more control over the setup of the database\n(like maybe you're integrating Cora into an existing database), then read on.",
            "title": "Object Relations"
        },
        {
            "location": "/documentation/amblend/model/#using-multiple-databases",
            "text": "The database config file for Cora holds an array that let's you define multiple\ndatabase connections. If you've gone through the setup process, you've undoubtably\nseen it, but here's a reminder of how this looks:  $dbConfig['defaultConnection'] = 'mainDb';\n$dbConfig['connections'] = [\n    'mainDb' => [\n        'adaptor'   => 'MySQL',\n        'host'      => 'localhost:3306',\n        'dbName'    => 'cora',\n        'dbUser'    => 'root',\n        'dbPass'    => 'root'\n    ],\n    'secondaryDb' => [\n        'adaptor'   => 'MySQL',\n        'host'      => 'localhost:3306',\n        'dbName'    => 'cora2',\n        'dbUser'    => 'root',\n        'dbPass'    => 'root'\n    ],\n    'mongoDb' => [\n        'adaptor'   => 'MongoDb',\n        'host'      => 'localhost:3306',\n        'dbName'    => 'cora3',\n        'dbUser'    => 'root',\n        'dbPass'    => 'root'\n    ]\n];  In this config file you define the connection details for each database, tell\nit what Cora database adaptor to use with that connection, and give each connection\na name.  In order to make use of multiple connections, you have to specify that some of your\nmodels use a connection which is different from the default. Like so:  class Guide extends MyModel {\n\n    public $model_connection = 'secondaryDb';\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'title' => [\n            'type' => 'varchar'\n        ],\n        'authors' => [\n            'models' => 'user'\n        ]\n    ];\n\n    public function __construct($title = null)\n    {\n        $this->title = $title;\n    }\n\n}  Now when you generate your database, the Guides table/collection will get created\nusing the 'secondaryDb' connection instead of the main one. Similarly, grabbing\nGuide object from the DB using a repository will use this secondaryDb connection\ntoo:  $repo = \\Cora\\RepositoryFactory::make('Guide');\n$guide = $repo->find($id);  The spot where you could run into trouble is when you want a two-way reference between\nobjects in different databases. For example, looking at our Guide definition above\nyou can see we have a reference to one or more User models representing the authors\nof said guide. But what if our Users model also keeps a reference to Guides a user\nhas been an author of? Let's add a reference to Guides in our User model:  Note: Because our User model was defined as using the default connection\n(we didn't tell it to use anything different) AmBlend will know to fetch the authors\nfrom the main database.  public $model_attributes = [\n    'id' => [\n        'type'          => 'int',\n        'primaryKey'    => true\n    ],\n    'name' => [\n        'type' => 'varchar'\n    ],\n    'email' => [\n        'type' => 'varchar',\n        'index' => true\n    ],\n    'type'  => [\n        'type' => 'varchar',\n        'size' => 55,\n        'defaultValue' => 'User'\n    ],\n    'location' => [\n        'model' => 'location'\n    ],\n    'articles' => [\n        'models' => 'article'\n    ],\n    'guides' => [\n        'models' => 'guide'\n    ]\n];  So now we have a reference to Users from a Guide, and a reference to Guides from\na User. The way these are related is by using a relation table. If you aren't\nfamiliar with relation tables, see the image below for the general idea. Basically\nit's a really simple table that holds relationships (shocking right!?). In this\nscreenshot, guides 9 and 10 are associated with a user who's ID is '1', and\nguide 11 is associated with whoever user '2' is:   The problem lies in the question of \"Which database is going to hold the relation\ntable?\" Having to maintain redundant tables on each database and then remembering\nto alter both anytime a relationship changes is just plain dumb, and assuming\nthat the relationship will be kept in the default database didn't feel like an\nassumption I could make for sure either. Thus, in order to solve this problem\nI've introduced the concept of 'passive' sides in a multi-database relationship.  To fix our User & Guide model definitions as we've defined them above, we need to\nmark one side of that relationship as the 'passive' side like so:  class User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'type'  => [\n            'type' => 'varchar',\n            'size' => 55,\n            'defaultValue' => 'User'\n        ],\n        'location' => [\n            'model' => 'location'\n        ],\n        'articles' => [\n            'models' => 'article'\n        ],\n        'guides' => [\n            'models' => 'guide',\n            'passive' => true\n        ]\n    ];\n}  By marking the User side of the relationship as the passive side, AmBlend will\nnow know to make the relationship table on the database represented by Guide's\nconnection.",
            "title": "Using Multiple Databases"
        },
        {
            "location": "/documentation/amblend/model/#advanced-configuration",
            "text": "Alright, using AmBlend's automated database creation feature and simply setting\nrelationships as singular \"model\" or plural \"models\" and letting AmBlend handle the\nrest is nice and all for new projects. But let's talk about configuration options\nfor incorporating AmBlend into a pre-existing database where you have to work within\nthe constraints of the existing setup.  First off, let's talk table names.",
            "title": "Advanced Configuration"
        },
        {
            "location": "/documentation/amblend/model/#change-the-table-to-which-a-model-is-mapped",
            "text": "By default, a table/collection name will be the plural version of the model. For\ninstance: our User model will be stored in a table called \"users\". Our Guide model\nwill be stored in a table called \"guides\" and so on and so forth. If this behavior\nwon't work with your existing database for a particular model, you have the option\nto specify a different name.  Let's say you are building an internal app to be used\nby your company and you want the User model to map to a table named \"employees\".\nYou would specify that like so:  class User extends \\Cora\\Model {\n\n    public $model_table = 'employees';\n    public $model_attributes = [\n        ... stuff here ...\n    ];\n}",
            "title": "Change the table to which a model is mapped"
        },
        {
            "location": "/documentation/amblend/model/#change-the-name-of-a-relation-table",
            "text": "Whenever you specify a simple plural relationship from one model to another like\nso:  class User extends \\Cora\\Model {\n\n    public $model_attributes = [\n        'articles' => [\n            'models' => 'article'\n        ]\n    ];\n}  A relation table is used that is named by making the models involved plural and\nappending them together with an underscore in reverse alphabetical order.\nIn the example above of a User associated with an Article the resulting relation\ntable name would be \"users_articles\".  If you're fine with the use of a relation table, but you need to change the name\nof it. You can do so by utilizing the 'relTable' setting like this:  class User extends \\Cora\\Model {\n\n    public $model_attributes = [\n        'articles' => [\n            'models' => 'article',\n            'relTable' => 'some_custom_relation_table_name'\n        ]\n    ];\n}  The one caveat here is that at the time of this writing, I do not support custom\ncolumn names within the relation table. The relation table column names must be\nthe name of the model who's ID they hold. For the above example with User and\nArticle, the relation table will need a 'user' column and an 'article' column. If\nyou have existing relation tables that don't follow this format, you'll have to change\nthem or else not use AmBlend.",
            "title": "Change the name of a relation table"
        },
        {
            "location": "/documentation/amblend/model/#one-to-many-via-an-owner-column",
            "text": "The default setup for plural relationships in AmBlend is the use of relation tables\njust because they are the most flexible. However, if you want to force the use of\nan \"owner\" type column in a one-to-many relationship either because it's your\npersonal preference or it's necessary to integrate with an existing database, AmBlend\nmakes this possible.  What you'll need to do is just throw a 'via' setting in with a plural model definition.\nFor instance, let's say we don't care about supporting multiple authors for an article\non our site, but rather just want an article to have a single owner and we want to\nstore a reference to this owner in the articles table via an \"owner\" column. We\ndo that like this:  class User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'type'  => [\n            'type' => 'varchar',\n            'size' => 55,\n            'defaultValue' => 'User'\n        ],\n        'location' => [\n            'model' => 'location'\n        ],\n        'articles' => [\n            'models' => 'article',\n            'via'    => 'owner'\n        ]\n    ];\n}",
            "title": "One-to-Many via an \"owner\" column"
        },
        {
            "location": "/documentation/amblend/model/#one-to-one-using-a-relation-table",
            "text": "By default, one-to-one relationships are stored as a column on the model's table.\nFor instance, the following definition for a related Job object would be stored\nas seen in the picture below:  class User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'type'  => [\n            'type' => 'varchar',\n            'size' => 55,\n            'defaultValue' => 'User'\n        ],\n        'job' => [\n            'model' => 'job'\n        ]\n    ];\n}  \"users\" table:     However, if for some reason you wanted to force a single reference to use a relation\ntable (maybe you felt it could change to a plural relationship in the future or something),\nyou could do so by specifying \"usesRefTable\" as true:  class User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'type'  => [\n            'type' => 'varchar',\n            'size' => 55,\n            'defaultValue' => 'User'\n        ],\n        'job' => [\n            'model' => 'job',\n            'usesRefTable' => true\n        ]\n    ];\n}  Optionally you can of course combine this with the previously talked about\n\"relTable\" option to specify the name of the relation table if the default naming\ndoesn't work for you.",
            "title": "One-to-One using a relation table"
        },
        {
            "location": "/documentation/amblend/model/#namespaces",
            "text": "Just a quick explanation of namespaces in the model definition...  When defining related models in your $model_attributes array, namespaces are\nalways absolute, never relative. See the namespaced Notes model below and the\nrelationship definition added to User for an example:  <?php\nnamespace Task;\n\nclass Note extends \\Note {\n\n    public $model_table = 'notes_tasks';\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'title' => [\n            'type' => 'varchar'\n        ],\n        'note' => [\n            'type' => 'text'\n        ],\n        'owner' => [\n            'model' => 'user'\n        ]\n    ];\n}  class User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'type'  => [\n            'type' => 'varchar',\n            'size' => 55,\n            'defaultValue' => 'User'\n        ],\n        'notes' => [\n            'models' => 'task\\\\note',\n            'via'    => 'owner'\n        ]\n    ];\n}",
            "title": "Namespaces"
        },
        {
            "location": "/documentation/amblend/gateway/",
            "text": "Gateway Class\n\n\nThe Gateway directly interacts with the persistence layer (databases, files) to\ngrab and return data. It takes a request form a Repository, figures out how to\ngrab the needed info, and then returns that info to the Repository.\n\n\nCreating a Gateway\n\n\nNormally you shouldn't be creating Gateways yourself. If you refer to the\nRepository documentation and use the recommended Repository creation method of\nutilizing the RepositoryFactory class, then it will create a Gateway for you\nand handle passing it off to the Repository.\n\n\nIf for some reason you do need to create your own Gateway object and you're\nusing Cora's default Gateway, then do so like this:\n\n\n$db = \\Cora\\Database::getDb('name_of_db_connection_to_use');\n$gateway = new Gateway($db);\n\n\n\n\nOptionally you can include a couple extra arguments in the form of setting the\ntable to use and the unique identifying field of records in that table if it's\nsomething other than 'id':\n\n\n$db = \\Cora\\Database::getDb('name_of_db_connection_to_use');\n$gateway = new Gateway($db, 'users', 'email');",
            "title": "Gateway"
        },
        {
            "location": "/documentation/amblend/gateway/#gateway-class",
            "text": "The Gateway directly interacts with the persistence layer (databases, files) to\ngrab and return data. It takes a request form a Repository, figures out how to\ngrab the needed info, and then returns that info to the Repository.",
            "title": "Gateway Class"
        },
        {
            "location": "/documentation/amblend/gateway/#creating-a-gateway",
            "text": "Normally you shouldn't be creating Gateways yourself. If you refer to the\nRepository documentation and use the recommended Repository creation method of\nutilizing the RepositoryFactory class, then it will create a Gateway for you\nand handle passing it off to the Repository.  If for some reason you do need to create your own Gateway object and you're\nusing Cora's default Gateway, then do so like this:  $db = \\Cora\\Database::getDb('name_of_db_connection_to_use');\n$gateway = new Gateway($db);  Optionally you can include a couple extra arguments in the form of setting the\ntable to use and the unique identifying field of records in that table if it's\nsomething other than 'id':  $db = \\Cora\\Database::getDb('name_of_db_connection_to_use');\n$gateway = new Gateway($db, 'users', 'email');",
            "title": "Creating a Gateway"
        },
        {
            "location": "/documentation/amblend/factory/",
            "text": "Factory Class\n\n\nThe Factory takes an array of info and turns it into objects. It's use within\nAmBlend is to receive from the Repository some data grabbed from the persistence\nlayer via the Gateway. It then turns this data into one or more objects and\ngives these objects back to the Repository.\n\n\nCreating a Factory\n\n\nNormally you shouldn't be creating Factories yourself. If you refer to the\nRepository documentation and use the recommended Repository creation method of\nutilizing the RepositoryFactory class, then it will create a Factory for you\nand handle passing it off to the Repository.\n\n\nIf for some reason you do need to create your own Factory object and you're\nusing Cora's default Factory, then do so like this:\n\n\n// Create a User factory\n$factory = new Factory('User');\n\n\n\n\nOptionally you can include a 2nd argument in the form of a Cora database adaptor.\nIf you do this, the adaptor will get passed on to any objects created by the Factory.\nThe reason for this is when you want to override the default database for a model.\nIf for instance you have a model that normally is found in your main database, but\nfor unit testing you want to use a separate test database, you can pass in a connection\nto the test database this way so it gets used.\n\n\n$db = \\Cora\\Database::getDb('name_of_db_connection_to_use');\n$factory = new Factory('User', $db);",
            "title": "Factory"
        },
        {
            "location": "/documentation/amblend/factory/#factory-class",
            "text": "The Factory takes an array of info and turns it into objects. It's use within\nAmBlend is to receive from the Repository some data grabbed from the persistence\nlayer via the Gateway. It then turns this data into one or more objects and\ngives these objects back to the Repository.",
            "title": "Factory Class"
        },
        {
            "location": "/documentation/amblend/factory/#creating-a-factory",
            "text": "Normally you shouldn't be creating Factories yourself. If you refer to the\nRepository documentation and use the recommended Repository creation method of\nutilizing the RepositoryFactory class, then it will create a Factory for you\nand handle passing it off to the Repository.  If for some reason you do need to create your own Factory object and you're\nusing Cora's default Factory, then do so like this:  // Create a User factory\n$factory = new Factory('User');  Optionally you can include a 2nd argument in the form of a Cora database adaptor.\nIf you do this, the adaptor will get passed on to any objects created by the Factory.\nThe reason for this is when you want to override the default database for a model.\nIf for instance you have a model that normally is found in your main database, but\nfor unit testing you want to use a separate test database, you can pass in a connection\nto the test database this way so it gets used.  $db = \\Cora\\Database::getDb('name_of_db_connection_to_use');\n$factory = new Factory('User', $db);",
            "title": "Creating a Factory"
        },
        {
            "location": "/documentation/amblend/lifecycle/",
            "text": "Lifecycle Callbacks\n\n\nLifecycle callbacks are methods on a model that get called automatically when\ncertain actions are performed on that model. For instance, if you create a new\nUser and ask a Repository to save it, the model's \"beforeCreate()\" method will get called\nbefore the User gets saved to the database, and the \"afterCreate()\" method will\nget called after a record for that User gets inserted.\n\n\nThere are various uses where these Lifecycle Callbacks could come in handy, and\nI'll try to give an example or two.\n\n\nList of Callbacks\n\n\n\n    \n\n        \nCallback\n\n        \nDescription\n\n    \n\n    \n\n        \ndelete()\n\n        \n\n            Called before deletion happens when a Repository is asked to delete\n            an object.\n        \n\n    \n\n    \n\n        \nbeforeCreate()\n\n        \n\n            Called before insertion happens when a Repository is asked to save\n            a NEW object.\n        \n\n    \n\n    \n\n        \nafterCreate()\n\n        \n\n            Called after insertion happens when a Repository is asked to save\n            a NEW object.\n        \n\n    \n\n    \n\n        \nbeforeSave()\n\n        \n\n            Called before an update happens when a Repository is asked to save\n            an EXISTING object. Also called before an insertion happens when a repo\n            is asked to save a NEW object (called right AFTER afterCreate).\n        \n\n    \n\n    \n\n        \nafterSave()\n\n        \n\n            Called after an update happens when a Repository is asked to save\n            an EXISTING object. Also called after an insertion happens when a repo\n            is asked to save a NEW object (called right AFTER beforeCreate).\n        \n\n    \n\n    \n\n        \nbeforeSet($property, $value)\n\n        \n\n            Called before a model property gets set. I.E. If you set a name on\n            a User object like so: $user->name = 'Bob', the beforeSet method\n            will get called with \"name\" as the property and 'Bob' as the value\n            before the setting takes place.\n        \n\n    \n\n    \n\n        \nafterSet($property, $value)\n\n        \n\n            Called after a model property gets set.\n        \n\n    \n\n    \n\n        \nbeforeGet($property)\n\n        \n\n            Called before a model property gets grabbed.\n        \n\n    \n\n    \n\n        \nafterGet($property, $value)\n\n        \n\n            Called after a model property gets grabbed.\n        \n\n    \n\n\n\n\n\nUsage Examples\n\n\nIf you haven't used callbacks before, it may not be immediately clear how or\nwhy you might want to use them. The following are a few examples of common use\ncases where callbacks can make your life easier.\n\n\nSetting a Computed Default Value\n\n\nAlright, say you have a User model and you want to have a \"joinedDate\" property\nthat represents when that user first joined your site/app. The easiest way to\ndo this would be to use the beforeCreate() callback. This means adding a\nbeforeCreate() method to your User model that maybe looks something like this:\n\n\nclass User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'joinedDate' => [\n            'type' => 'date'\n        ]\n    ];\n\n    public function beforeCreate()\n    {\n        $this->joinedDate = date('Y-m-d');\n    }\n}\n\n\n\n\nSince beforeCreate() gets called BEFORE the saving of the object to the database\ntakes place, that means the 'joinedDate' property will have the current date and\nget saved to the database as such.\n\n\nDoing Cleanup Before Deleting\n\n\nAnother common use case might be doing some sort of database cleanup before deleting\nan object. Say you have some sort of \"Comment\" object representing comments users\ncan leave on content on your site. Let's also say for this example that Users can\nupload files as an attachment to a comment and those files are stored in a separate\ntable/collection with a reference back to the parent. When you tell AmBlend to delete\nthe parent comment like so:\n\n\n$repo = \\Cora\\RepositoryFactory::make('Comment');\n$comment = $repo->find($id);\n$comment->delete();\n\n\n\n\nAny related children WILL NOT get automatically deleted along with it (because\nAmBlend can't safely assume that deleting all related objects is desired behavior)!\nIn order to avoid leaving unwanted orphans in the database, you can\nutilize the delete() callback to manually delete or reassign any related data.\n\n\nclass Comment extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'user' => [\n            'model' => 'User'\n        ],\n        'text' => [\n            'type' => 'text'\n        ],\n        'files' => [\n            'models' => 'FileAttachment'\n        ]\n    ];\n\n    public function delete()\n    {\n        // Code to handle files related to this comment...\n    }\n}\n\n\n\n\nConvert a Date String from mm-dd-yyyy to yyyy-mm-dd when Saving\n\n\nAnother area where callbacks could be useful is if you have a date in your model\nthat is stored as a string in the \"mm-dd-yyyy\" format and you need to convert it\nto a \"yyyy-mm-dd\" string for insertion into a database.\n\n\nAnd before I give this example, let me just point out that AmBlend is meant to work\nwell with php DateTime objects. If you grab a model using a Repository that\nhas a \"date\" or \"datetime\" database field, that field will automatically get\nconverted into a DateTime object for you when it's populated into your model.\nSimilarly, when you go to save your model, the DateTime will be grabbed as a\n\"yyyy-mm-dd\" string for use with the database\nautomatically - no work needs to be done on your part as a developer.\n\n\nHowever, if for whatever reason your model has a date that is being stored as a plain\nstring, and you don't want to convert it into a DateTime object (see next example),\nthen the following example could be useful to you:\n\n\nclass User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'joinedDate' => [\n            'type' => 'varchar'\n        ]\n    ];\n\n    public function beforeSave()\n    {\n        // Save the real value of joinedDate to a temp variable\n        $this->joinedDateTemp = $this->joinedDate;\n\n        // Swap joinedDate from mm-dd-yyyy to yyyy-mm-dd\n        $timestamp = strtotime($this->joinedDate);\n        $this->joinedDate = date('Y-m-d', $timestamp);\n    }\n\n    public function afterSave()\n    {\n        // Swap joinedDate back to its mm-dd-yyyy value.\n        $this->joinedDate = $this->joinedDateTemp;\n\n        // You can optionally clear the temp variable we used.\n        $this->joinedDateTemp = null;\n    }\n}\n\n\n\n\nThe above code makes \"joinedDate\" a string of yyyy-mm-dd format right before the\nUser object is saved, and then swaps it back to its original mm-dd-yyyy format\nafter the save is finished.\n\n\nGrab Date in Particular Format\n\n\nWhen AmBlend fetches date fields from a database, it converts them into php\nDateTime objects. If you've used DateTime object before, then you probably know\nyou can get their value formatting in a certain way by doing:\n\n\necho $someDate->format('m-d-Y');\n\n\n\n\nHowever, if for some reason you didn't want to have to specify the format\nanytime you display a date, you could utilize the beforeGet() method to always\nhave it return in a particular way:\n\n\nclass User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'joinedDate' => [\n            'type' => 'date'\n        ]\n    ];\n\n    public function beforeGet($prop)\n    {\n        if ($prop == 'joinedDate') {\n            // Save the real value of joinedDate to a temp variable\n            $this->joinedDateTemp = $this->joinedDate;\n\n            // Change the value of joinedDate to a formatted string\n            $this->joinedDate = $this->joinedDate->format('m-d-Y');\n        }\n    }\n\n    public function afterGet($prop, $value)\n    {\n        if ($prop == 'joinedDate') {\n            // Restore joined date.\n            $this->joinedDate = $this->joinedDateTemp;\n        }\n    }\n}\n\n\n\n\nEnforcing Restrictions on a Data Member\n\n\nAnother possible use for callbacks could be enforcing some set of restrictions\non a particular data member within a model. For instance, let's say you have an\n\"age\" property on your User model and you want to ensure that only numbers get\nassigned to it. You can do this by utilizing the beforeSet() callback:\n\n\nclass User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'age' => [\n            'type' => 'int'\n        ]\n    ];\n\n    public function beforeSet($prop, $value)\n    {\n        if ($prop == 'age') {\n            if (is_numeric($value) == false) {\n                // Throw some exception or something...\n            }\n        }\n    }\n}",
            "title": "Lifecycle Callbacks"
        },
        {
            "location": "/documentation/amblend/lifecycle/#lifecycle-callbacks",
            "text": "Lifecycle callbacks are methods on a model that get called automatically when\ncertain actions are performed on that model. For instance, if you create a new\nUser and ask a Repository to save it, the model's \"beforeCreate()\" method will get called\nbefore the User gets saved to the database, and the \"afterCreate()\" method will\nget called after a record for that User gets inserted.  There are various uses where these Lifecycle Callbacks could come in handy, and\nI'll try to give an example or two.",
            "title": "Lifecycle Callbacks"
        },
        {
            "location": "/documentation/amblend/lifecycle/#list-of-callbacks",
            "text": "Callback \n         Description \n     \n     \n         delete() \n         \n            Called before deletion happens when a Repository is asked to delete\n            an object.\n         \n     \n     \n         beforeCreate() \n         \n            Called before insertion happens when a Repository is asked to save\n            a NEW object.\n         \n     \n     \n         afterCreate() \n         \n            Called after insertion happens when a Repository is asked to save\n            a NEW object.\n         \n     \n     \n         beforeSave() \n         \n            Called before an update happens when a Repository is asked to save\n            an EXISTING object. Also called before an insertion happens when a repo\n            is asked to save a NEW object (called right AFTER afterCreate).\n         \n     \n     \n         afterSave() \n         \n            Called after an update happens when a Repository is asked to save\n            an EXISTING object. Also called after an insertion happens when a repo\n            is asked to save a NEW object (called right AFTER beforeCreate).\n         \n     \n     \n         beforeSet($property, $value) \n         \n            Called before a model property gets set. I.E. If you set a name on\n            a User object like so: $user->name = 'Bob', the beforeSet method\n            will get called with \"name\" as the property and 'Bob' as the value\n            before the setting takes place.\n         \n     \n     \n         afterSet($property, $value) \n         \n            Called after a model property gets set.\n         \n     \n     \n         beforeGet($property) \n         \n            Called before a model property gets grabbed.\n         \n     \n     \n         afterGet($property, $value) \n         \n            Called after a model property gets grabbed.",
            "title": "List of Callbacks"
        },
        {
            "location": "/documentation/amblend/lifecycle/#usage-examples",
            "text": "If you haven't used callbacks before, it may not be immediately clear how or\nwhy you might want to use them. The following are a few examples of common use\ncases where callbacks can make your life easier.",
            "title": "Usage Examples"
        },
        {
            "location": "/documentation/amblend/lifecycle/#setting-a-computed-default-value",
            "text": "Alright, say you have a User model and you want to have a \"joinedDate\" property\nthat represents when that user first joined your site/app. The easiest way to\ndo this would be to use the beforeCreate() callback. This means adding a\nbeforeCreate() method to your User model that maybe looks something like this:  class User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'joinedDate' => [\n            'type' => 'date'\n        ]\n    ];\n\n    public function beforeCreate()\n    {\n        $this->joinedDate = date('Y-m-d');\n    }\n}  Since beforeCreate() gets called BEFORE the saving of the object to the database\ntakes place, that means the 'joinedDate' property will have the current date and\nget saved to the database as such.",
            "title": "Setting a Computed Default Value"
        },
        {
            "location": "/documentation/amblend/lifecycle/#doing-cleanup-before-deleting",
            "text": "Another common use case might be doing some sort of database cleanup before deleting\nan object. Say you have some sort of \"Comment\" object representing comments users\ncan leave on content on your site. Let's also say for this example that Users can\nupload files as an attachment to a comment and those files are stored in a separate\ntable/collection with a reference back to the parent. When you tell AmBlend to delete\nthe parent comment like so:  $repo = \\Cora\\RepositoryFactory::make('Comment');\n$comment = $repo->find($id);\n$comment->delete();  Any related children WILL NOT get automatically deleted along with it (because\nAmBlend can't safely assume that deleting all related objects is desired behavior)!\nIn order to avoid leaving unwanted orphans in the database, you can\nutilize the delete() callback to manually delete or reassign any related data.  class Comment extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'user' => [\n            'model' => 'User'\n        ],\n        'text' => [\n            'type' => 'text'\n        ],\n        'files' => [\n            'models' => 'FileAttachment'\n        ]\n    ];\n\n    public function delete()\n    {\n        // Code to handle files related to this comment...\n    }\n}",
            "title": "Doing Cleanup Before Deleting"
        },
        {
            "location": "/documentation/amblend/lifecycle/#convert-a-date-string-from-mm-dd-yyyy-to-yyyy-mm-dd-when-saving",
            "text": "Another area where callbacks could be useful is if you have a date in your model\nthat is stored as a string in the \"mm-dd-yyyy\" format and you need to convert it\nto a \"yyyy-mm-dd\" string for insertion into a database.  And before I give this example, let me just point out that AmBlend is meant to work\nwell with php DateTime objects. If you grab a model using a Repository that\nhas a \"date\" or \"datetime\" database field, that field will automatically get\nconverted into a DateTime object for you when it's populated into your model.\nSimilarly, when you go to save your model, the DateTime will be grabbed as a\n\"yyyy-mm-dd\" string for use with the database\nautomatically - no work needs to be done on your part as a developer.  However, if for whatever reason your model has a date that is being stored as a plain\nstring, and you don't want to convert it into a DateTime object (see next example),\nthen the following example could be useful to you:  class User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'joinedDate' => [\n            'type' => 'varchar'\n        ]\n    ];\n\n    public function beforeSave()\n    {\n        // Save the real value of joinedDate to a temp variable\n        $this->joinedDateTemp = $this->joinedDate;\n\n        // Swap joinedDate from mm-dd-yyyy to yyyy-mm-dd\n        $timestamp = strtotime($this->joinedDate);\n        $this->joinedDate = date('Y-m-d', $timestamp);\n    }\n\n    public function afterSave()\n    {\n        // Swap joinedDate back to its mm-dd-yyyy value.\n        $this->joinedDate = $this->joinedDateTemp;\n\n        // You can optionally clear the temp variable we used.\n        $this->joinedDateTemp = null;\n    }\n}  The above code makes \"joinedDate\" a string of yyyy-mm-dd format right before the\nUser object is saved, and then swaps it back to its original mm-dd-yyyy format\nafter the save is finished.",
            "title": "Convert a Date String from mm-dd-yyyy to yyyy-mm-dd when Saving"
        },
        {
            "location": "/documentation/amblend/lifecycle/#grab-date-in-particular-format",
            "text": "When AmBlend fetches date fields from a database, it converts them into php\nDateTime objects. If you've used DateTime object before, then you probably know\nyou can get their value formatting in a certain way by doing:  echo $someDate->format('m-d-Y');  However, if for some reason you didn't want to have to specify the format\nanytime you display a date, you could utilize the beforeGet() method to always\nhave it return in a particular way:  class User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'joinedDate' => [\n            'type' => 'date'\n        ]\n    ];\n\n    public function beforeGet($prop)\n    {\n        if ($prop == 'joinedDate') {\n            // Save the real value of joinedDate to a temp variable\n            $this->joinedDateTemp = $this->joinedDate;\n\n            // Change the value of joinedDate to a formatted string\n            $this->joinedDate = $this->joinedDate->format('m-d-Y');\n        }\n    }\n\n    public function afterGet($prop, $value)\n    {\n        if ($prop == 'joinedDate') {\n            // Restore joined date.\n            $this->joinedDate = $this->joinedDateTemp;\n        }\n    }\n}",
            "title": "Grab Date in Particular Format"
        },
        {
            "location": "/documentation/amblend/lifecycle/#enforcing-restrictions-on-a-data-member",
            "text": "Another possible use for callbacks could be enforcing some set of restrictions\non a particular data member within a model. For instance, let's say you have an\n\"age\" property on your User model and you want to ensure that only numbers get\nassigned to it. You can do this by utilizing the beforeSet() callback:  class User extends \\Cora\\Model {\n    public $model_attributes = [\n        'id' => [\n            'type'          => 'int',\n            'primaryKey'    => true\n        ],\n        'name' => [\n            'type' => 'varchar'\n        ],\n        'email' => [\n            'type' => 'varchar',\n            'index' => true\n        ],\n        'age' => [\n            'type' => 'int'\n        ]\n    ];\n\n    public function beforeSet($prop, $value)\n    {\n        if ($prop == 'age') {\n            if (is_numeric($value) == false) {\n                // Throw some exception or something...\n            }\n        }\n    }\n}",
            "title": "Enforcing Restrictions on a Data Member"
        },
        {
            "location": "/documentation/amblend/database_gen/",
            "text": "Database Generation\n\n\nOnce you have valid AmBlend models defined, you can automatically generate a database\nfor your project using AmBlend's database generation tool.\n\n\n\nPlease note that this tool is a part of the Cora demo project and not in the\nFramework core, so if you went the non-typical route and bypassed using the demo\nproject as a base to build on, you'll need to grab the Amblend.php file out of the\ndemo project's root.\n\n\n\n\nCreate Your Database:\n\n\nIn order to take advantage of automated database creation, you need to make sure\nyou've setup your database configuration. If you haven't done that yet,\n\nClick Here\n to view\ninstructions on doing so. The other thing you'll need (as of me writing this),\nis command line access. In the future, an in-browser\nvisual interface to the database creation tool may be added, but for now it's just\na command line tool.\n\n\n\n\n\nIf on a shared hosting environment:\n  \n\nBecause the database creation feature is a command line tool...\nwhat this means for people who will be hosting their app in\na shared hosting environment without command line access is that you'll need to\ngenerate your database on your local machine and then use a tool (such as PhpMyAdmin)\nto export your generated database into an SQL file you can upload.\n\n\n\n\nTo automatically generate a database based on your model definitions you need\nto do the following:\n\n\n\n\nOpen a Terminal.\n\n\nIf on a Mac, open your Applications, click the Utilities folder, and then\nselect the \"Terminal\" application.\n\n\nIf on a PC, hit your Windows Key + R to open the \"Run\" window, then type\nin \"cmd\" and hit enter.\n\n\nIf on Linux you don't need me to tell you how to do this, but since I can't\nhelp myself I'll mention that Ubuntu and Mint both map the terminal to\nCtrl+Alt+T.\n\n\n\n\n\n\nNavigate to your project's directory.\n\n\nIf you are XAMPP, MAMP, etc, that will likely be wherever you installed\nthat and then in the \"htdocs\" folder within.\n\n\n\n\n\n\nOnce at the root of your project, type \"php Amblend.php dbBuild\" to have\nAmBlend build your database for you.\n\n\n\n\nphp Amblend.php dbBuild\n\n\n\n\n\n    If you get an error about PHP not being a recognized command, that means\n    PHP is not a part of your operating system's PATH. Google \"add php to path\"\n    or something similar if you aren't sure how to do this.\n\n\n\n\nIf all went well, you should see a flurry of output to the console and your database\nshould be ready to go!\n\n\nOf course, if you want to read through the documentation\nin the Models page to fully understand how the mappings work for the purpose of\nsetting your database(s) up manually, you can, although that takes more expertise\nand effort.\n\n\nEmpty a Database\n\n\nSo chances are you'll be making changes to your models throughout development and\nwill need to rebuild your database each time. In order to make use of the automated\ncreation tool again, you'll need to empty out any database(s) you're using by deleting\nall the existing tables. To speed up this process, the database generation tool also\nincludes a command to delete all the existing tables.\n\n\n\n\nThis DELETES any data you have in the database. NEVER EVER use\nthis on a live app. Use this only during development and know you will have to\nre-insert your test data afterwards.\n  \n\n\n\n\nTo make this happen, you need to use the \"dbEmpty\" command and then specify a\ndatabase connection from your project's database config file:\n\n\nphp Amblend.php dbEmpty NameOfConnection",
            "title": "Automated DB Creation"
        },
        {
            "location": "/documentation/amblend/database_gen/#database-generation",
            "text": "Once you have valid AmBlend models defined, you can automatically generate a database\nfor your project using AmBlend's database generation tool.  \nPlease note that this tool is a part of the Cora demo project and not in the\nFramework core, so if you went the non-typical route and bypassed using the demo\nproject as a base to build on, you'll need to grab the Amblend.php file out of the\ndemo project's root.",
            "title": "Database Generation"
        },
        {
            "location": "/documentation/amblend/database_gen/#create-your-database",
            "text": "In order to take advantage of automated database creation, you need to make sure\nyou've setup your database configuration. If you haven't done that yet, Click Here  to view\ninstructions on doing so. The other thing you'll need (as of me writing this),\nis command line access. In the future, an in-browser\nvisual interface to the database creation tool may be added, but for now it's just\na command line tool.   If on a shared hosting environment:   \n\nBecause the database creation feature is a command line tool...\nwhat this means for people who will be hosting their app in\na shared hosting environment without command line access is that you'll need to\ngenerate your database on your local machine and then use a tool (such as PhpMyAdmin)\nto export your generated database into an SQL file you can upload.  To automatically generate a database based on your model definitions you need\nto do the following:   Open a Terminal.  If on a Mac, open your Applications, click the Utilities folder, and then\nselect the \"Terminal\" application.  If on a PC, hit your Windows Key + R to open the \"Run\" window, then type\nin \"cmd\" and hit enter.  If on Linux you don't need me to tell you how to do this, but since I can't\nhelp myself I'll mention that Ubuntu and Mint both map the terminal to\nCtrl+Alt+T.    Navigate to your project's directory.  If you are XAMPP, MAMP, etc, that will likely be wherever you installed\nthat and then in the \"htdocs\" folder within.    Once at the root of your project, type \"php Amblend.php dbBuild\" to have\nAmBlend build your database for you.   php Amblend.php dbBuild  \n    If you get an error about PHP not being a recognized command, that means\n    PHP is not a part of your operating system's PATH. Google \"add php to path\"\n    or something similar if you aren't sure how to do this.  If all went well, you should see a flurry of output to the console and your database\nshould be ready to go!  Of course, if you want to read through the documentation\nin the Models page to fully understand how the mappings work for the purpose of\nsetting your database(s) up manually, you can, although that takes more expertise\nand effort.",
            "title": "Create Your Database:"
        },
        {
            "location": "/documentation/amblend/database_gen/#empty-a-database",
            "text": "So chances are you'll be making changes to your models throughout development and\nwill need to rebuild your database each time. In order to make use of the automated\ncreation tool again, you'll need to empty out any database(s) you're using by deleting\nall the existing tables. To speed up this process, the database generation tool also\nincludes a command to delete all the existing tables.   This DELETES any data you have in the database. NEVER EVER use\nthis on a live app. Use this only during development and know you will have to\nre-insert your test data afterwards.     To make this happen, you need to use the \"dbEmpty\" command and then specify a\ndatabase connection from your project's database config file:  php Amblend.php dbEmpty NameOfConnection",
            "title": "Empty a Database"
        },
        {
            "location": "/documentation/databaseclass/overview/",
            "text": "Cora's Database class\n\n\nNOTE: IF YOU ARE GOING TO BE GRABBING CLASS RECORDS FROM A DATABASE, YOU SHOULD CONSIDER USING THE\nAMBLEND ORM, NOT THIS LOWER LEVEL DATABASE CLASS.\n\n\nIn a nutshell, Cora's Database class acts as a \nData Access Object\n. It\noffers you a simple way to interact with a database, without having to worry about implementation specific details for different database types.\nThe ELI5 explanation goes like this: \n\nSay you build an application that uses Database-A, and Database-A uses commands that look like the following:\n\n\nSELECT first_name FROM users WHERE id=12;\n\n\n\n\nHowever, one day your boss says to you that he wants you to switch over to using Database-B. Database-B however uses a different\ncommand syntax though that looks something like this:\n\n\ndb.users.find( { id: 12 }, { first_name: 1 } );\n\n\n\n\nWHOA NELLY! If you haven't been using a Data Access Object, then the fact that this new database uses a different syntax could be devastating.\nYou might literally have to rewrite HUGE portions of your application to make everything work with this new format. NOT GOOD! This is where\na DAO comes in handy. Let's say you've written all your database queries in your application using a DAO and it has its own format that looks something like so:\n\n\n$db ->select('first_name')\n    ->from('users')\n    ->where('id', 12)\n    ->exec();\n\n\n\n\nIf your app is using this DAO, now when your boss tells you to start using database-B, all that you need to do is write translation instructions (aka an 'adaptor') for your DAO\nso it knows how to turn the above into the instuction format database-B uses (or more likely, someone else has already written an adaptor, can you just have to download it).\nIn this way, Cora's Database class acts as an abstraction layer that helps separate your application from any one specific database implementation.\n\n\nHow it's Implemented\n\n\nWhen you construct an SQL statement using the Database class' query building methods, the resulting query parameters are stored as\nraw data within the Database class (mostly stored in arrays). In order to take that raw data and then execute a query, you have to\nutilize an adaptor that extends the Database class and implements the exec() method. The adaptor is responsible for taking that raw\ndata and translating it into the format required by its associated Database in order to execute the query.\n\n\nCurrently Supported Databases\n\n\nCora currently has adaptor classes for:\n\n\n\n\nMySQL (Db_MySQL.php)\n\n\n\n\nIntroduction\n\n\nBelow is a basic example that grabs and echoes the name of all the users in a users table who's type is 'admin'.\n\n\n// Create Database object with adaptor\n$db = new \\Cora\\Db_MySQL();\n\n// Create query\n$db ->select('name')\n    ->from('users')\n    ->where('type', 'admin');\n\n// Execute query and get returned result.\n$query = $db->exec();\n\n// Print all the names\nforeach($query->fetchAll() as $user) {\n    echo $user['name'];\n}\n\n\n\n\nAs you probably see, the basic formula is you create an instance of a database adaptor (Db_MySQL extends Database), construct\nsome query using the Database class' methods, then call the exec() function to execute the query and return any expected result.\nQuery methods can be chained together as you see above too.\n\n\nSecurity\n\n\nThe Database class and its query building methods are extremely powerful, and as such, there are dangerous scenarios of which you need\nto be aware! Column VALUES are sanitized to protect your app from SQL Injection attacks. However, COLUMN name parameters and OPERATOR parameters (=, >, <, IN, etc)\nare NOT sanitized!!! For this reason you should never under any circumstance pass in a value you receive from a user into one of those fields!\nDoing so will leave a huge security hole in your app that an attacker could take advantage of to destroy or compromise everything.\n\n\nBelow is a \nSAFE\n query:\n\n\n// Create and execute query\n$db ->select('name')\n    ->from('users')\n    ->where('name', $_POST['userName']);\n$query = $db->exec();\n\n\n\n\nBelow is an \nEXTREMELY UNSAFE\n query:\n\n\n// Create and execute query\n$db ->select('name')\n    ->from('users')\n    ->where($_POST['column'], $_POST['value']);\n$query = $db->exec();\n\n\n\n\nMethods\n\n\nUtility Methods\n\n\nThe following methods are available when creating any type of query:\n\n\n\n\ngetQuery()\n (returns the compiled query)\n\n\nexec()\n (executes the query that's been constructed and calls Reset)\n\n\nreset()\n (resets the Database class so it's ready for a new query)\n\n\n\n\nSELECT Statements\n\n\nThe methods available when creating a select statement are:\n\n\n\n\nselect()\n\n\ndistinct()\n\n\nfrom()\n\n\njoin()\n\n\nwhere()\n\n\norWhere()\n\n\nin()\n\n\ngroupBy()\n\n\nhaving()\n\n\norHaving()\n\n\norderBy()\n\n\nlimit()\n\n\noffset()\n\n\n\n\nUPDATE Statements\n\n\nThe methods available when creating an update statement are:\n\n\n\n\nupdate()\n\n\nset()\n\n\nwhere()\n\n\n\n\nINSERT Statements\n\n\nThe methods available when creating an insert statement are:\n\n\n\n\ninsert()\n\n\ninto()\n\n\nvalues()\n\n\n\n\nDELETE Statements\n\n\nThe methods available when creating an delete statement are:\n\n\n\n\ndelete()\n\n\nfrom()\n\n\nwhere()\n\n\n\n\nCREATE Statements\n\n\nThe methods available when creating an create statement are:\n\n\n\n\ncreate()\n\n\nfield()\n\n\nprimaryKey()\n\n\nforeignKey()\n\n\n\n\nAdvanced Examples\n\n\nCreating a table:\n\n\n$db ->create('locations')\n            ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n            ->field('name', 'varchar(255)')\n            ->field('address', 'varchar(255)')\n            ->field('user_id', 'int')\n            ->primaryKey('id')\n            ->foreignKey('user_id', 'users', 'id');\n$db->exec();\n\n\n\n\nInserting data:\n\n\n$db ->insert('name, email, type')\n    ->into('users')\n    ->values([\n        ['bob', \"bob's@gmail.com\", 'admin'],\n        ['john', 'john@gmail.com', 'admin'],\n        ['john', 'john@gmail.com', 'scrub'],\n        ['sally', 'sally@yahoo.com', 'user'],\n        ['susan', 'susan@aol.com', 'user']\n    ])\n    ->exec();\n\n\n\n\nMore advanced Where statement:\n\n\n$db ->select('id')\n    ->distinct()\n    ->from('users')\n    ->from('profile')\n    ->where([\n        ['created_time', '>=', '2016-01-01', 'OR'],\n        ['name', 'LIKE', 's%']\n    ])\n    ->where([\n        ['type', '=', 'admin', 'OR'],\n        ['type', '=', 'moderator']\n    ])\n    ->exec();\n\n\n\n\nMega Query:\n\n\n$tables = array('table1', 'table2', 'table3');\n$fields = array('id', 'name', 'email');\n$conditions = array(\n    ['id', '>', '100', 'OR'],\n    ['name', 'LIKE', '%s']\n);\n\n$groupBys = ['field1', 'field2', 'field3'];\n\n$havings = array(\n    ['amount', '>', '1000'],\n    ['savings', '>', '100']\n);\n\n$orHavings = array(\n    ['amount2', '>', '1000'],\n    ['savings2', '>', '100']\n);\n\n$joinConditions = array(\n    ['Orders.customerID', '=', 'Customers.customerID'],\n    ['User.type', '=', 'Customer.type']\n);\n\n\n$db = new Cora\\Db_MySQL();\n\necho $db->select($fields)\n        ->from($tables)\n        ->join('customers', $joinConditions, 'OUTER')\n        ->where($conditions)\n        ->orWhere($conditions)\n        ->in('name', 'value1, value2, value3')\n        ->in('name', 'SELECT * FROM users')\n        ->in('type', $groupBys)\n        ->groupBy($groupBys)\n        ->having($havings)\n        ->orHaving($orHavings)\n        ->having($orHavings)\n        ->orderBy('name', 'DESC')\n        ->orderBy('type', 'ASC')\n        ->limit(10)\n        ->offset(20)\n        ->getQuery();",
            "title": "Overview"
        },
        {
            "location": "/documentation/databaseclass/overview/#coras-database-class",
            "text": "NOTE: IF YOU ARE GOING TO BE GRABBING CLASS RECORDS FROM A DATABASE, YOU SHOULD CONSIDER USING THE\nAMBLEND ORM, NOT THIS LOWER LEVEL DATABASE CLASS.  In a nutshell, Cora's Database class acts as a  Data Access Object . It\noffers you a simple way to interact with a database, without having to worry about implementation specific details for different database types.\nThe ELI5 explanation goes like this:  \nSay you build an application that uses Database-A, and Database-A uses commands that look like the following:  SELECT first_name FROM users WHERE id=12;  However, one day your boss says to you that he wants you to switch over to using Database-B. Database-B however uses a different\ncommand syntax though that looks something like this:  db.users.find( { id: 12 }, { first_name: 1 } );  WHOA NELLY! If you haven't been using a Data Access Object, then the fact that this new database uses a different syntax could be devastating.\nYou might literally have to rewrite HUGE portions of your application to make everything work with this new format. NOT GOOD! This is where\na DAO comes in handy. Let's say you've written all your database queries in your application using a DAO and it has its own format that looks something like so:  $db ->select('first_name')\n    ->from('users')\n    ->where('id', 12)\n    ->exec();  If your app is using this DAO, now when your boss tells you to start using database-B, all that you need to do is write translation instructions (aka an 'adaptor') for your DAO\nso it knows how to turn the above into the instuction format database-B uses (or more likely, someone else has already written an adaptor, can you just have to download it).\nIn this way, Cora's Database class acts as an abstraction layer that helps separate your application from any one specific database implementation.",
            "title": "Cora's Database class"
        },
        {
            "location": "/documentation/databaseclass/overview/#how-its-implemented",
            "text": "When you construct an SQL statement using the Database class' query building methods, the resulting query parameters are stored as\nraw data within the Database class (mostly stored in arrays). In order to take that raw data and then execute a query, you have to\nutilize an adaptor that extends the Database class and implements the exec() method. The adaptor is responsible for taking that raw\ndata and translating it into the format required by its associated Database in order to execute the query.",
            "title": "How it's Implemented"
        },
        {
            "location": "/documentation/databaseclass/overview/#currently-supported-databases",
            "text": "Cora currently has adaptor classes for:   MySQL (Db_MySQL.php)",
            "title": "Currently Supported Databases"
        },
        {
            "location": "/documentation/databaseclass/overview/#introduction",
            "text": "Below is a basic example that grabs and echoes the name of all the users in a users table who's type is 'admin'.  // Create Database object with adaptor\n$db = new \\Cora\\Db_MySQL();\n\n// Create query\n$db ->select('name')\n    ->from('users')\n    ->where('type', 'admin');\n\n// Execute query and get returned result.\n$query = $db->exec();\n\n// Print all the names\nforeach($query->fetchAll() as $user) {\n    echo $user['name'];\n}  As you probably see, the basic formula is you create an instance of a database adaptor (Db_MySQL extends Database), construct\nsome query using the Database class' methods, then call the exec() function to execute the query and return any expected result.\nQuery methods can be chained together as you see above too.",
            "title": "Introduction"
        },
        {
            "location": "/documentation/databaseclass/overview/#security",
            "text": "The Database class and its query building methods are extremely powerful, and as such, there are dangerous scenarios of which you need\nto be aware! Column VALUES are sanitized to protect your app from SQL Injection attacks. However, COLUMN name parameters and OPERATOR parameters (=, >, <, IN, etc)\nare NOT sanitized!!! For this reason you should never under any circumstance pass in a value you receive from a user into one of those fields!\nDoing so will leave a huge security hole in your app that an attacker could take advantage of to destroy or compromise everything.  Below is a  SAFE  query:  // Create and execute query\n$db ->select('name')\n    ->from('users')\n    ->where('name', $_POST['userName']);\n$query = $db->exec();  Below is an  EXTREMELY UNSAFE  query:  // Create and execute query\n$db ->select('name')\n    ->from('users')\n    ->where($_POST['column'], $_POST['value']);\n$query = $db->exec();",
            "title": "Security"
        },
        {
            "location": "/documentation/databaseclass/overview/#methods",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/documentation/databaseclass/overview/#utility-methods",
            "text": "The following methods are available when creating any type of query:   getQuery()  (returns the compiled query)  exec()  (executes the query that's been constructed and calls Reset)  reset()  (resets the Database class so it's ready for a new query)",
            "title": "Utility Methods"
        },
        {
            "location": "/documentation/databaseclass/overview/#select-statements",
            "text": "The methods available when creating a select statement are:   select()  distinct()  from()  join()  where()  orWhere()  in()  groupBy()  having()  orHaving()  orderBy()  limit()  offset()",
            "title": "SELECT Statements"
        },
        {
            "location": "/documentation/databaseclass/overview/#update-statements",
            "text": "The methods available when creating an update statement are:   update()  set()  where()",
            "title": "UPDATE Statements"
        },
        {
            "location": "/documentation/databaseclass/overview/#insert-statements",
            "text": "The methods available when creating an insert statement are:   insert()  into()  values()",
            "title": "INSERT Statements"
        },
        {
            "location": "/documentation/databaseclass/overview/#delete-statements",
            "text": "The methods available when creating an delete statement are:   delete()  from()  where()",
            "title": "DELETE Statements"
        },
        {
            "location": "/documentation/databaseclass/overview/#create-statements",
            "text": "The methods available when creating an create statement are:   create()  field()  primaryKey()  foreignKey()",
            "title": "CREATE Statements"
        },
        {
            "location": "/documentation/databaseclass/overview/#advanced-examples",
            "text": "Creating a table:  $db ->create('locations')\n            ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n            ->field('name', 'varchar(255)')\n            ->field('address', 'varchar(255)')\n            ->field('user_id', 'int')\n            ->primaryKey('id')\n            ->foreignKey('user_id', 'users', 'id');\n$db->exec();  Inserting data:  $db ->insert('name, email, type')\n    ->into('users')\n    ->values([\n        ['bob', \"bob's@gmail.com\", 'admin'],\n        ['john', 'john@gmail.com', 'admin'],\n        ['john', 'john@gmail.com', 'scrub'],\n        ['sally', 'sally@yahoo.com', 'user'],\n        ['susan', 'susan@aol.com', 'user']\n    ])\n    ->exec();  More advanced Where statement:  $db ->select('id')\n    ->distinct()\n    ->from('users')\n    ->from('profile')\n    ->where([\n        ['created_time', '>=', '2016-01-01', 'OR'],\n        ['name', 'LIKE', 's%']\n    ])\n    ->where([\n        ['type', '=', 'admin', 'OR'],\n        ['type', '=', 'moderator']\n    ])\n    ->exec();  Mega Query:  $tables = array('table1', 'table2', 'table3');\n$fields = array('id', 'name', 'email');\n$conditions = array(\n    ['id', '>', '100', 'OR'],\n    ['name', 'LIKE', '%s']\n);\n\n$groupBys = ['field1', 'field2', 'field3'];\n\n$havings = array(\n    ['amount', '>', '1000'],\n    ['savings', '>', '100']\n);\n\n$orHavings = array(\n    ['amount2', '>', '1000'],\n    ['savings2', '>', '100']\n);\n\n$joinConditions = array(\n    ['Orders.customerID', '=', 'Customers.customerID'],\n    ['User.type', '=', 'Customer.type']\n);\n\n\n$db = new Cora\\Db_MySQL();\n\necho $db->select($fields)\n        ->from($tables)\n        ->join('customers', $joinConditions, 'OUTER')\n        ->where($conditions)\n        ->orWhere($conditions)\n        ->in('name', 'value1, value2, value3')\n        ->in('name', 'SELECT * FROM users')\n        ->in('type', $groupBys)\n        ->groupBy($groupBys)\n        ->having($havings)\n        ->orHaving($orHavings)\n        ->having($orHavings)\n        ->orderBy('name', 'DESC')\n        ->orderBy('type', 'ASC')\n        ->limit(10)\n        ->offset(20)\n        ->getQuery();",
            "title": "Advanced Examples"
        },
        {
            "location": "/documentation/databaseclass/methods_utility/",
            "text": "Utility Database Class Methods\n\n\ntable() method\n\n\nThe method for selecting a table you want to perform an operation on (whether selecting, updating, inserting, or deleting)\nis to use table(). However, in order to let developers construct queries in the same format they are used to when writing\nraw SQL, there are several aliases to this method.\n\n\nPurpose:\n \n\nThe table() method is for selecting the table(s) you want to perform an action on.\n\n\nFormat:\n  \n\n\ntable(table_name | array(table_name1, table_name2, ...))\n\n\n\n\nUsage and Aliases:\n \n\nAnywhere you would use a from(), into(), or update() method you can use this method instead.\n\n\nExamples:\n   \n\n\n// A SELECT query\n$db ->table('users')\n    ->select('*')\n    ->join('members', [['users.user_id', '=', 'members.user_id']])\n    ->orderBy('users.user_id', 'ASC')\n    ->exec();\n\n// An UPDATE query\n$db ->table('users')\n    ->set('name', 'John')\n    ->where('name', 'Randy', '>')\n    ->getQuery();        \n\n// An INSERT query\n$db ->table('users')\n    ->insert('name, email, type')\n    ->values([['bob', 'bob@gmail.com', 'admin'], ['john', 'john@gmail.com', 'admin']])\n    ->values(['bob', 'bob@gmail.com', 'admin'])\n    ->exec();\n\n\n\n\ngetQuery() method\n\n\nPurpose:\n \n\nThe getQuery() method returns the query that will be executed on the database. This is useful when trying\nto troubleshoot if you want to see what Cora's Database class is actually executing.\n\nFormat:\n  \n\n\ngetQuery()\n\n\n\n\nExamples:\n  \n\n\n// Constuct a CREATE table query, then echo it out (does not execute it)\necho $db->create('locations')\n        ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n        ->field('name', 'varchar(255)')\n        ->field('address', 'varchar(255)')\n        ->field('user_id', 'int')\n        ->primaryKey('id')\n        ->foreignKey('user_id', 'users', 'id')\n        ->getQuery();\n\n\n\n\nexec() method\n\n\nPurpose:\n \n\nThe exec() method executes a query, resets the database class by calling reset(), and returns any data if there's\ndata to return.\n\n\nFormat:\n  \n\n\nexec()\n\n\n\n\nExamples:\n  \n\n\n// Constuct a CREATE table query, then execute it.\n$db ->create('locations')\n    ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n    ->field('name', 'varchar(255)')\n    ->field('address', 'varchar(255)')\n    ->field('user_id', 'int')\n    ->primaryKey('id')\n    ->foreignKey('user_id', 'users', 'id')\n    ->exec();\n\n\n\n\nreset() method\n\n\nPurpose:\n \n\nThe reset() method clears out the stored data in the database class so that a new query can then be constructed.\n\nFormat:\n  \n\n\nreset()\n\n\n\n\nExamples:\n  \n\n\n// Constuct a CREATE table query, then echo it out (does not execute it)\necho $db->create('locations')\n        ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n        ->field('name', 'varchar(255)')\n        ->field('address', 'varchar(255)')\n        ->field('user_id', 'int')\n        ->primaryKey('id')\n        ->foreignKey('user_id', 'users', 'id')\n        ->getQuery();\n\n/* \n    Before we can start working on a 2nd query, we either need to execute the one we just constructed\n    (which clears out the stored data), OR we need to manually clear out the data if we don't plan\n    on executing the query.\n*/\n// Clear out the stored data from the first query we constructed.\n$db->reset()\n\n// Start constructing a 2nd query...\necho $db->select('*')\n        ->from('users')\n        ->join('members', [['users.user_id', '=', 'members.user_id']])\n        ->orderBy('users.user_id', 'ASC')\n        ->getQuery();",
            "title": "Utility Methods"
        },
        {
            "location": "/documentation/databaseclass/methods_utility/#utility-database-class-methods",
            "text": "",
            "title": "Utility Database Class Methods"
        },
        {
            "location": "/documentation/databaseclass/methods_utility/#table-method",
            "text": "The method for selecting a table you want to perform an operation on (whether selecting, updating, inserting, or deleting)\nis to use table(). However, in order to let developers construct queries in the same format they are used to when writing\nraw SQL, there are several aliases to this method.  Purpose:   \nThe table() method is for selecting the table(s) you want to perform an action on.  Format:     table(table_name | array(table_name1, table_name2, ...))  Usage and Aliases:   \nAnywhere you would use a from(), into(), or update() method you can use this method instead.  Examples:      // A SELECT query\n$db ->table('users')\n    ->select('*')\n    ->join('members', [['users.user_id', '=', 'members.user_id']])\n    ->orderBy('users.user_id', 'ASC')\n    ->exec();\n\n// An UPDATE query\n$db ->table('users')\n    ->set('name', 'John')\n    ->where('name', 'Randy', '>')\n    ->getQuery();        \n\n// An INSERT query\n$db ->table('users')\n    ->insert('name, email, type')\n    ->values([['bob', 'bob@gmail.com', 'admin'], ['john', 'john@gmail.com', 'admin']])\n    ->values(['bob', 'bob@gmail.com', 'admin'])\n    ->exec();",
            "title": "table() method"
        },
        {
            "location": "/documentation/databaseclass/methods_utility/#getquery-method",
            "text": "Purpose:   \nThe getQuery() method returns the query that will be executed on the database. This is useful when trying\nto troubleshoot if you want to see what Cora's Database class is actually executing. Format:     getQuery()  Examples:     // Constuct a CREATE table query, then echo it out (does not execute it)\necho $db->create('locations')\n        ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n        ->field('name', 'varchar(255)')\n        ->field('address', 'varchar(255)')\n        ->field('user_id', 'int')\n        ->primaryKey('id')\n        ->foreignKey('user_id', 'users', 'id')\n        ->getQuery();",
            "title": "getQuery() method"
        },
        {
            "location": "/documentation/databaseclass/methods_utility/#exec-method",
            "text": "Purpose:   \nThe exec() method executes a query, resets the database class by calling reset(), and returns any data if there's\ndata to return.  Format:     exec()  Examples:     // Constuct a CREATE table query, then execute it.\n$db ->create('locations')\n    ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n    ->field('name', 'varchar(255)')\n    ->field('address', 'varchar(255)')\n    ->field('user_id', 'int')\n    ->primaryKey('id')\n    ->foreignKey('user_id', 'users', 'id')\n    ->exec();",
            "title": "exec() method"
        },
        {
            "location": "/documentation/databaseclass/methods_utility/#reset-method",
            "text": "Purpose:   \nThe reset() method clears out the stored data in the database class so that a new query can then be constructed. Format:     reset()  Examples:     // Constuct a CREATE table query, then echo it out (does not execute it)\necho $db->create('locations')\n        ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n        ->field('name', 'varchar(255)')\n        ->field('address', 'varchar(255)')\n        ->field('user_id', 'int')\n        ->primaryKey('id')\n        ->foreignKey('user_id', 'users', 'id')\n        ->getQuery();\n\n/* \n    Before we can start working on a 2nd query, we either need to execute the one we just constructed\n    (which clears out the stored data), OR we need to manually clear out the data if we don't plan\n    on executing the query.\n*/\n// Clear out the stored data from the first query we constructed.\n$db->reset()\n\n// Start constructing a 2nd query...\necho $db->select('*')\n        ->from('users')\n        ->join('members', [['users.user_id', '=', 'members.user_id']])\n        ->orderBy('users.user_id', 'ASC')\n        ->getQuery();",
            "title": "reset() method"
        },
        {
            "location": "/documentation/databaseclass/methods_select/",
            "text": "Database Class Methods\n\n\nselect() method\n\n\nPurpose:\n \n\nThe select() method is for choosing the columns you want to return in your query.\n\n\nFormat:\n \n\n\nselect(column_name | array(column_name1, column_name2, ...))\n\n\n\n\nExamples:\n  \n\n\n// Grab a single column\n$db->select('id')\n\n// OR grab multiple columns\n$db->select('id')\n   ->select('first_name')\n\n// OR grab multiple columns by passing in an array\n$db->select(['id', 'first_name', 'last_name'])\n\n\n\n\ndistinct() method\n\n\nPurpose:\n \n\nThe distinct() method is for limiting the results returned so that there's no duplicates.\n\n\nFormat:\n  \n\n\ndistinct()\n\n\n\n\nExamples:\n  \n\n\n// The distinct method takes no parameters, you just call it when constructing your query.\n$db ->select('first_name')\n    ->distinct()\n    ->from('users');\n\n\n\n\nfrom() method\n\n\nAlias:\n \n\nThis method is an alias of table().\n\n\nPurpose:\n \n\nThe from() method is for selecting the table(s) you want to return or delete data from.\n\n\nFormat:\n  \n\n\nfrom(table_name | array(table_name1, table_name2, ...))\n\n\n\n\nExamples:\n   \n\n\n// Grab a single table\n$db->from('users')\n\n// OR join multiple tables\n$db->from('users')\n   ->from('user_profiles')\n\n// OR grab multiple tables by passing in an array\n$db->from(['users', 'user_profiles'])\n\n\n\n\njoin() method\n\n\nPurpose:\n \n\nThe join() method is for joining multiple tables together.\n\n\nFormat:\n  \n\n\n// f_table = Foreign Table Name\n// f_column = Foreign Column Name\njoin(f_table, array(array(table.column, operator, f_table.f_column)[, ...]) [, join_type ])\n\n\n\n\nExamples:\n  \n\n\n// Join a table when a certain single condition is met, using the default INNER join\n$db->join('members', [['users.user_id', '=', 'members.user_id']])\n\n// Join a table using a specifc type of join\n$db->join('members', [['users.user_id', '=', 'members.user_id']], 'OUTER')\n\n// Join a table when multiple conditions are met\n$db->join('members', [\n            ['Orders.customerID', '=', 'Customers.customerID'],\n            ['User.type', '=', 'Customer.type']\n        ], 'OUTER')\n\n// Apply multiple joins together\n$db ->join('members', [['users.user_id', '=', 'members.user_id']])\n    ->join('locations', [['users.location_id', '=', 'locations.id']])\n\n\n\n\nwhere() method\n\n\nPurpose:\n \n\nThe where() method is for limiting the records that get returned to only those that pass certain conditions.\n\n\nFormat:\n \n\n\nwhere(column_name, value [, operator] | array(array(column_name, operator, value [, conjunction])))\n\n\n\n\nExamples:\n  \n\n\n// Only return results where name = 'bob'\n$db->where('name', 'bob')\n\n// Only return results where the date is greater than or equal to january first 2014\n$db->where('date', '2014-01-01', '>=')\n\n// If the above format of passing in the operator as an optional 3rd parameter bothers you,\n// you can use the array format which uses the [column, operator, value] ordering.\n// Note that you need the double brackets though because it supports multiple statements.\n$db->where([['date', '>=', '2014-01-01']])\n\n// Only return results where the date is greater than or equal to january first 2014\n// and less than january 2016\n$db ->where('date', '2014-01-01', '>=')\n    ->where('date', '2016-01-01', '<')\n\n// Only return results where name = 'bob' OR name = 'jeff'\n$db ->where('name', 'bob')\n    ->orWhere('name', 'jeff')\n\n// Pass in an array...\n// Only return results where a user's name starts with 's' or was created after Jan 2016,\n// and the user is of type 'admin' or 'moderator'\n$db ->where([\n        ['created_time', '>=', '2016-01-01', 'OR'],\n        ['name', 'LIKE', 's%']\n    ])\n    ->where([\n        ['type', '=', 'admin', 'OR'],\n        ['type', '=', 'moderator']\n    ])  \n// Using the MySQL adaptor, the above produces:\n// WHERE (created_time >= '2016-01-01' OR name LIKE 's%') AND (type = 'admin' OR type = 'moderator')\n\n\n\n\norWhere() method\n\n\nPurpose:\n \n\nThe orWhere() method is for limiting the records that get returned to only those that pass certain conditions. \n\n\nSimilar To:\n \n\nIt works identically to the where() method except any conditions passed to it will be conjoined with 'OR' to any other Where declarations. See the where() section for more examples.\n\n\nExamples:\n  \n\n\n// Only return users who are named bob and also admins, or users named jeff\n$db ->where([\n        ['name', 'bob'],\n        ['type', 'admin']\n    ])\n    ->orWhere('name', 'jeff')\n// Using the MySQL adaptor, the above produces:\n// WHERE (name = 'bob' AND type = 'admin') OR (name = 'jeff')\n\n\n\n\nin() method\n\n\nPurpose:\n \n\nThe in() method is for checking if a column's value exists in another set of data.\n\n\nFormat:\n   \n\n\nin(column, value | string(value1, value2, value3, ...) | array(value1, value2, value3, ...))\n\n\n\n\nExamples:\n \n\n\n// Check if column value matches a single value (same as using where statement)\n$db ->in('name', 'bob')\n\n// Check if column value is present in a comma separated list\n// Note: The list gets translated into an array by the Database class.\n$db ->in('name', 'bob, jeff, susan')\n\n// Check if column value is present in an array of values\n$db ->in('name', ['bob', 'jeff', 'susan'])\n\n// NOT RECOMMENDED as it breaks cross-database functionality, but possible\n$db ->in('name', 'SELECT name FROM users WHERE name LIKE s%')\n// The better way of doing the above is to do a query to grab all the names that start with 's',\n// then pass the result set as an array to the in() method. This would preserve cross-database\n// functionality and not lock you into databases that support your SQL statement.\n\n\n\n\ngroupBy() method\n\n\nPurpose:\n \n\nThe groupBy() method is for combining data together.\n\n\nFormat:\n  \n\n\ngroupBy(column | array(column1, column2, ...))\n\n\n\n\nExamples:\n   \n\n\n// Group by a single column\n$db->groupBy('last_name')\n\n// OR group by multiple columns\n$db->groupBy('last_name')\n   ->groupBy('location')\n\n// OR group by multiple columns by passing in an array\n$db->groupBy(['last_name', 'location'])\n\n\n\n\nhaving() method\n\n\nPurpose:\n \n\nThe having() method is for further filtering the results returned. where() performs row level checks,\nhaving() performs checks on the result set that gets returned after row level conditions are satisfied.\nIt's for filtering based on aggregates which where() can't do.\n\n\nFormat:\n \n\n\nhaving(column_name, value [, operator] | array(array(column_name, operator, value [, conjunction])))\n\n\n\n\nExamples:\n \n\nhaving() follows the same format as where(), so feel free to look at the examples there if you need to.\nIn order to understand more about the SQL Having keyword, \nsee this example from w3schools.com\n\n\norHaving() method\n\n\nPurpose:\n \n\nJoins the given condition(s) with any previous condition statements joined by 'OR'.\n\n\nFollows the same format as having(). For examples see the syntactially identical orWhere() method.\n\n\norderBy() method\n\n\nPurpose:\n \n\nThe orderBy() method is for ordering the returned results from your query.\n\n\nFormat:\n \n\n\n// sort_direction = DESC (descending) | ASC (ascending)\norderBy(column_name, sort_direction)\n\n\n\n\nExamples:\n \n\n\n// Specifying a single column to order by...\n$db ->orderBy('name', 'ASC')\n\n// Specifying multiple columns to order by...\n$db ->orderBy('users.name', 'DESC')\n    ->orderBy('locations.name', 'DESC')\n\n\n\n\nlimit() method\n\n\nPurpose:\n \n\nThe limit() method is for limiting the number of returned results from a query.\n\n\nFormat:\n   \n\n\nlimit(number)\n\n\n\n\nExamples:\n   \n\n\n// Limit the number of result rows to 10\n$db ->limit(10)\n\n\n\n\noffset() method\n\n\nPurpose:\n \n\nThe offset() method is for specifying how many result rows should be skipped when returning a query.\nIt's most commonly used in conjunction with limit() to perform pagination.\n\n\nFormat:\n   \n\n\noffset(number)\n\n\n\n\nExamples:\n   \n\n\n// Skip returning the first 10 results from a query's result set.\n$db ->offset(10)\n\n// Return results 11-20 from a large result set\n$db ->limit(10)\n    ->offset(10)\n\n// Return results 21-30 from a large result set\n$db ->limit(10)\n    ->offset(20)",
            "title": "SELECT Methods"
        },
        {
            "location": "/documentation/databaseclass/methods_select/#database-class-methods",
            "text": "",
            "title": "Database Class Methods"
        },
        {
            "location": "/documentation/databaseclass/methods_select/#select-method",
            "text": "Purpose:   \nThe select() method is for choosing the columns you want to return in your query.  Format:    select(column_name | array(column_name1, column_name2, ...))  Examples:     // Grab a single column\n$db->select('id')\n\n// OR grab multiple columns\n$db->select('id')\n   ->select('first_name')\n\n// OR grab multiple columns by passing in an array\n$db->select(['id', 'first_name', 'last_name'])",
            "title": "select() method"
        },
        {
            "location": "/documentation/databaseclass/methods_select/#distinct-method",
            "text": "Purpose:   \nThe distinct() method is for limiting the results returned so that there's no duplicates.  Format:     distinct()  Examples:     // The distinct method takes no parameters, you just call it when constructing your query.\n$db ->select('first_name')\n    ->distinct()\n    ->from('users');",
            "title": "distinct() method"
        },
        {
            "location": "/documentation/databaseclass/methods_select/#from-method",
            "text": "Alias:   \nThis method is an alias of table().  Purpose:   \nThe from() method is for selecting the table(s) you want to return or delete data from.  Format:     from(table_name | array(table_name1, table_name2, ...))  Examples:      // Grab a single table\n$db->from('users')\n\n// OR join multiple tables\n$db->from('users')\n   ->from('user_profiles')\n\n// OR grab multiple tables by passing in an array\n$db->from(['users', 'user_profiles'])",
            "title": "from() method"
        },
        {
            "location": "/documentation/databaseclass/methods_select/#join-method",
            "text": "Purpose:   \nThe join() method is for joining multiple tables together.  Format:     // f_table = Foreign Table Name\n// f_column = Foreign Column Name\njoin(f_table, array(array(table.column, operator, f_table.f_column)[, ...]) [, join_type ])  Examples:     // Join a table when a certain single condition is met, using the default INNER join\n$db->join('members', [['users.user_id', '=', 'members.user_id']])\n\n// Join a table using a specifc type of join\n$db->join('members', [['users.user_id', '=', 'members.user_id']], 'OUTER')\n\n// Join a table when multiple conditions are met\n$db->join('members', [\n            ['Orders.customerID', '=', 'Customers.customerID'],\n            ['User.type', '=', 'Customer.type']\n        ], 'OUTER')\n\n// Apply multiple joins together\n$db ->join('members', [['users.user_id', '=', 'members.user_id']])\n    ->join('locations', [['users.location_id', '=', 'locations.id']])",
            "title": "join() method"
        },
        {
            "location": "/documentation/databaseclass/methods_select/#where-method",
            "text": "Purpose:   \nThe where() method is for limiting the records that get returned to only those that pass certain conditions.  Format:    where(column_name, value [, operator] | array(array(column_name, operator, value [, conjunction])))  Examples:     // Only return results where name = 'bob'\n$db->where('name', 'bob')\n\n// Only return results where the date is greater than or equal to january first 2014\n$db->where('date', '2014-01-01', '>=')\n\n// If the above format of passing in the operator as an optional 3rd parameter bothers you,\n// you can use the array format which uses the [column, operator, value] ordering.\n// Note that you need the double brackets though because it supports multiple statements.\n$db->where([['date', '>=', '2014-01-01']])\n\n// Only return results where the date is greater than or equal to january first 2014\n// and less than january 2016\n$db ->where('date', '2014-01-01', '>=')\n    ->where('date', '2016-01-01', '<')\n\n// Only return results where name = 'bob' OR name = 'jeff'\n$db ->where('name', 'bob')\n    ->orWhere('name', 'jeff')\n\n// Pass in an array...\n// Only return results where a user's name starts with 's' or was created after Jan 2016,\n// and the user is of type 'admin' or 'moderator'\n$db ->where([\n        ['created_time', '>=', '2016-01-01', 'OR'],\n        ['name', 'LIKE', 's%']\n    ])\n    ->where([\n        ['type', '=', 'admin', 'OR'],\n        ['type', '=', 'moderator']\n    ])  \n// Using the MySQL adaptor, the above produces:\n// WHERE (created_time >= '2016-01-01' OR name LIKE 's%') AND (type = 'admin' OR type = 'moderator')",
            "title": "where() method"
        },
        {
            "location": "/documentation/databaseclass/methods_select/#orwhere-method",
            "text": "Purpose:   \nThe orWhere() method is for limiting the records that get returned to only those that pass certain conditions.   Similar To:   \nIt works identically to the where() method except any conditions passed to it will be conjoined with 'OR' to any other Where declarations. See the where() section for more examples.  Examples:     // Only return users who are named bob and also admins, or users named jeff\n$db ->where([\n        ['name', 'bob'],\n        ['type', 'admin']\n    ])\n    ->orWhere('name', 'jeff')\n// Using the MySQL adaptor, the above produces:\n// WHERE (name = 'bob' AND type = 'admin') OR (name = 'jeff')",
            "title": "orWhere() method"
        },
        {
            "location": "/documentation/databaseclass/methods_select/#in-method",
            "text": "Purpose:   \nThe in() method is for checking if a column's value exists in another set of data.  Format:      in(column, value | string(value1, value2, value3, ...) | array(value1, value2, value3, ...))  Examples:    // Check if column value matches a single value (same as using where statement)\n$db ->in('name', 'bob')\n\n// Check if column value is present in a comma separated list\n// Note: The list gets translated into an array by the Database class.\n$db ->in('name', 'bob, jeff, susan')\n\n// Check if column value is present in an array of values\n$db ->in('name', ['bob', 'jeff', 'susan'])\n\n// NOT RECOMMENDED as it breaks cross-database functionality, but possible\n$db ->in('name', 'SELECT name FROM users WHERE name LIKE s%')\n// The better way of doing the above is to do a query to grab all the names that start with 's',\n// then pass the result set as an array to the in() method. This would preserve cross-database\n// functionality and not lock you into databases that support your SQL statement.",
            "title": "in() method"
        },
        {
            "location": "/documentation/databaseclass/methods_select/#groupby-method",
            "text": "Purpose:   \nThe groupBy() method is for combining data together.  Format:     groupBy(column | array(column1, column2, ...))  Examples:      // Group by a single column\n$db->groupBy('last_name')\n\n// OR group by multiple columns\n$db->groupBy('last_name')\n   ->groupBy('location')\n\n// OR group by multiple columns by passing in an array\n$db->groupBy(['last_name', 'location'])",
            "title": "groupBy() method"
        },
        {
            "location": "/documentation/databaseclass/methods_select/#having-method",
            "text": "Purpose:   \nThe having() method is for further filtering the results returned. where() performs row level checks,\nhaving() performs checks on the result set that gets returned after row level conditions are satisfied.\nIt's for filtering based on aggregates which where() can't do.  Format:    having(column_name, value [, operator] | array(array(column_name, operator, value [, conjunction])))  Examples:   \nhaving() follows the same format as where(), so feel free to look at the examples there if you need to.\nIn order to understand more about the SQL Having keyword,  see this example from w3schools.com",
            "title": "having() method"
        },
        {
            "location": "/documentation/databaseclass/methods_select/#orhaving-method",
            "text": "Purpose:   \nJoins the given condition(s) with any previous condition statements joined by 'OR'.  Follows the same format as having(). For examples see the syntactially identical orWhere() method.",
            "title": "orHaving() method"
        },
        {
            "location": "/documentation/databaseclass/methods_select/#orderby-method",
            "text": "Purpose:   \nThe orderBy() method is for ordering the returned results from your query.  Format:    // sort_direction = DESC (descending) | ASC (ascending)\norderBy(column_name, sort_direction)  Examples:    // Specifying a single column to order by...\n$db ->orderBy('name', 'ASC')\n\n// Specifying multiple columns to order by...\n$db ->orderBy('users.name', 'DESC')\n    ->orderBy('locations.name', 'DESC')",
            "title": "orderBy() method"
        },
        {
            "location": "/documentation/databaseclass/methods_select/#limit-method",
            "text": "Purpose:   \nThe limit() method is for limiting the number of returned results from a query.  Format:      limit(number)  Examples:      // Limit the number of result rows to 10\n$db ->limit(10)",
            "title": "limit() method"
        },
        {
            "location": "/documentation/databaseclass/methods_select/#offset-method",
            "text": "Purpose:   \nThe offset() method is for specifying how many result rows should be skipped when returning a query.\nIt's most commonly used in conjunction with limit() to perform pagination.  Format:      offset(number)  Examples:      // Skip returning the first 10 results from a query's result set.\n$db ->offset(10)\n\n// Return results 11-20 from a large result set\n$db ->limit(10)\n    ->offset(10)\n\n// Return results 21-30 from a large result set\n$db ->limit(10)\n    ->offset(20)",
            "title": "offset() method"
        },
        {
            "location": "/documentation/databaseclass/methods_update/",
            "text": "Database Class Methods\n\n\nupdate() method\n\n\nAlias:\n \n\nThis method is an alias of table().\n\n\nPurpose:\n \n\nThe update() method is for selecting the table(s) you want to perform an update on.\n\n\nFormat:\n  \n\n\nupdate(table_name | array(table_name1, table_name2, ...))\n\n\n\n\nset() method\n\n\nPurpose:\n \n\nThe set() method is for assigning a field a new value.\n\n\nFormat:\n   \n\n\nset(column_name, newValue)\n\n\n\n\nExamples:\n  \n\n\n// Rename any users with the name Randy to John.\n$db ->update('users')\n    ->set('name', 'John')\n    ->where('name', 'Randy')\n    ->exec();\n\n\n\n\nwhere() method\n\n\nPurpose:\n \n\nThe where() method is for limiting the records that get returned to only those that pass certain conditions.\n\n\nFormat:\n \n\n\nwhere(column_name, value [, operator] | array(array(column_name, operator, value [, conjunction])))\n\n\n\n\nExamples:\n  \n\n\n// Only return results where name = 'bob'\n$db->where('name', 'bob')\n\n// Only return results where the date is greater than or equal to january first 2014\n$db->where('date', '2014-01-01', '>=')\n\n// Only return results where the date is greater than or equal to january first 2014\n// and less than january 2016\n$db ->where('date', '2014-01-01', '>=')\n    ->where('date', '2016-01-01', '<')\n\n// Only return results where name = 'bob' OR name = 'jeff'\n$db ->where('name', 'bob')\n    ->orWhere('name', 'jeff')\n\n// Pass in an array...\n// Only return results where a user's name starts with 's' or was created after Jan 2016,\n// and the user is of type 'admin' or 'moderator'\n$db ->where([\n        ['created_time', '>=', '2016-01-01', 'OR'],\n        ['name', 'LIKE', 's%']\n    ])\n    ->where([\n        ['type', '=', 'admin', 'OR'],\n        ['type', '=', 'moderator']\n    ])  \n// Using the MySQL adaptor, the above produces:\n// WHERE (created_time >= '2016-01-01' OR name LIKE 's%') AND (type = 'admin' OR type = 'moderator')\n\n\n\n\norWhere() method\n\n\nPurpose:\n \n\nThe orWhere() method is for limiting the records that get returned to only those that pass certain conditions. \n\n\nSimilar To:\n \n\nIt works identically to the where() method except any conditions passed to it will be conjoined with 'OR' to any other Where declarations. See the where() section for more examples.\n\n\nExamples:\n  \n\n\n// Only return users who are named bob and also admins, or users named jeff\n$db ->where([\n        ['name', 'bob'],\n        ['type', 'admin']\n    ])\n    ->orWhere('name', 'jeff')\n// Using the MySQL adaptor, the above produces:\n// WHERE (name = 'bob' AND type = 'admin') OR (name = 'jeff')\n\n\n\n\nin() method\n\n\nPurpose:\n \n\nThe in() method is for checking if a column's value exists in another set of data.\n\n\nFormat:\n   \n\n\nin(column, value | string(value1, value2, value3, ...) | array(value1, value2, value3, ...))\n\n\n\n\nExamples:\n \n\n\n// Check if column value matches a single value (same as using where statement)\n$db ->in('name', 'bob')\n\n// Check if column value is present in a comma separated list\n// Note: The list gets translated into an array by the Database class.\n$db ->in('name', 'bob, jeff, susan')\n\n// Check if column value is present in an array of values\n$db ->in('name', ['bob', 'jeff', 'susan'])\n\n// NOT RECOMMENDED as it breaks cross-database functionality, but possible\n$db ->in('name', 'SELECT name FROM users WHERE name LIKE s%')\n// The better way of doing the above is to do a query to grab all the names that start with 's',\n// then pass the result set as an array to the in() method. This would preserve cross-database\n// functionality and not lock you into databases that support your SQL statement.\n\n\n\n\nformat as having(). For examples see the syntactially identical orWhere() method.\n\n\norderBy() method\n\n\nPurpose:\n \n\nThe orderBy() method is for ordering the returned results from your query.\n\n\nFormat:\n \n\n\n// sort_direction = DESC (descending) | ASC (ascending)\norderBy(column_name, sort_direction)\n\n\n\n\nExamples:\n \n\n\n// Specifying a single column to order by...\n$db ->orderBy('name', 'ASC')\n\n// Specifying multiple columns to order by...\n$db ->orderBy('users.name', 'DESC')\n    ->orderBy('locations.name', 'DESC')\n\n\n\n\nlimit() method\n\n\nPurpose:\n \n\nThe limit() method is for limiting the number of returned results from a query.\n\n\nFormat:\n   \n\n\nlimit(number)\n\n\n\n\nExamples:\n   \n\n\n// Limit the number of result rows to 10\n$db ->limit(10)",
            "title": "UPDATE Methods"
        },
        {
            "location": "/documentation/databaseclass/methods_update/#database-class-methods",
            "text": "",
            "title": "Database Class Methods"
        },
        {
            "location": "/documentation/databaseclass/methods_update/#update-method",
            "text": "Alias:   \nThis method is an alias of table().  Purpose:   \nThe update() method is for selecting the table(s) you want to perform an update on.  Format:     update(table_name | array(table_name1, table_name2, ...))",
            "title": "update() method"
        },
        {
            "location": "/documentation/databaseclass/methods_update/#set-method",
            "text": "Purpose:   \nThe set() method is for assigning a field a new value.  Format:      set(column_name, newValue)  Examples:     // Rename any users with the name Randy to John.\n$db ->update('users')\n    ->set('name', 'John')\n    ->where('name', 'Randy')\n    ->exec();",
            "title": "set() method"
        },
        {
            "location": "/documentation/databaseclass/methods_update/#where-method",
            "text": "Purpose:   \nThe where() method is for limiting the records that get returned to only those that pass certain conditions.  Format:    where(column_name, value [, operator] | array(array(column_name, operator, value [, conjunction])))  Examples:     // Only return results where name = 'bob'\n$db->where('name', 'bob')\n\n// Only return results where the date is greater than or equal to january first 2014\n$db->where('date', '2014-01-01', '>=')\n\n// Only return results where the date is greater than or equal to january first 2014\n// and less than january 2016\n$db ->where('date', '2014-01-01', '>=')\n    ->where('date', '2016-01-01', '<')\n\n// Only return results where name = 'bob' OR name = 'jeff'\n$db ->where('name', 'bob')\n    ->orWhere('name', 'jeff')\n\n// Pass in an array...\n// Only return results where a user's name starts with 's' or was created after Jan 2016,\n// and the user is of type 'admin' or 'moderator'\n$db ->where([\n        ['created_time', '>=', '2016-01-01', 'OR'],\n        ['name', 'LIKE', 's%']\n    ])\n    ->where([\n        ['type', '=', 'admin', 'OR'],\n        ['type', '=', 'moderator']\n    ])  \n// Using the MySQL adaptor, the above produces:\n// WHERE (created_time >= '2016-01-01' OR name LIKE 's%') AND (type = 'admin' OR type = 'moderator')",
            "title": "where() method"
        },
        {
            "location": "/documentation/databaseclass/methods_update/#orwhere-method",
            "text": "Purpose:   \nThe orWhere() method is for limiting the records that get returned to only those that pass certain conditions.   Similar To:   \nIt works identically to the where() method except any conditions passed to it will be conjoined with 'OR' to any other Where declarations. See the where() section for more examples.  Examples:     // Only return users who are named bob and also admins, or users named jeff\n$db ->where([\n        ['name', 'bob'],\n        ['type', 'admin']\n    ])\n    ->orWhere('name', 'jeff')\n// Using the MySQL adaptor, the above produces:\n// WHERE (name = 'bob' AND type = 'admin') OR (name = 'jeff')",
            "title": "orWhere() method"
        },
        {
            "location": "/documentation/databaseclass/methods_update/#in-method",
            "text": "Purpose:   \nThe in() method is for checking if a column's value exists in another set of data.  Format:      in(column, value | string(value1, value2, value3, ...) | array(value1, value2, value3, ...))  Examples:    // Check if column value matches a single value (same as using where statement)\n$db ->in('name', 'bob')\n\n// Check if column value is present in a comma separated list\n// Note: The list gets translated into an array by the Database class.\n$db ->in('name', 'bob, jeff, susan')\n\n// Check if column value is present in an array of values\n$db ->in('name', ['bob', 'jeff', 'susan'])\n\n// NOT RECOMMENDED as it breaks cross-database functionality, but possible\n$db ->in('name', 'SELECT name FROM users WHERE name LIKE s%')\n// The better way of doing the above is to do a query to grab all the names that start with 's',\n// then pass the result set as an array to the in() method. This would preserve cross-database\n// functionality and not lock you into databases that support your SQL statement.  format as having(). For examples see the syntactially identical orWhere() method.",
            "title": "in() method"
        },
        {
            "location": "/documentation/databaseclass/methods_update/#orderby-method",
            "text": "Purpose:   \nThe orderBy() method is for ordering the returned results from your query.  Format:    // sort_direction = DESC (descending) | ASC (ascending)\norderBy(column_name, sort_direction)  Examples:    // Specifying a single column to order by...\n$db ->orderBy('name', 'ASC')\n\n// Specifying multiple columns to order by...\n$db ->orderBy('users.name', 'DESC')\n    ->orderBy('locations.name', 'DESC')",
            "title": "orderBy() method"
        },
        {
            "location": "/documentation/databaseclass/methods_update/#limit-method",
            "text": "Purpose:   \nThe limit() method is for limiting the number of returned results from a query.  Format:      limit(number)  Examples:      // Limit the number of result rows to 10\n$db ->limit(10)",
            "title": "limit() method"
        },
        {
            "location": "/documentation/databaseclass/methods_insert/",
            "text": "Database Class Methods\n\n\ninsert() method\n\n\nPurpose:\n \n\nThe insert() method is for specifying the column names you want to insert into.\n\n\nFormat:\n   \n\n\nin(column | string(column1, column2, column3, ...) | array(column1, column2, column3, ...))\n\n\n\n\nExamples:\n \n\n\n// Insert two users 'Bob' and 'John' into the users table.\n$db ->insert('name, email, type')\n    ->into('users')\n    ->values([['bob', 'bob@gmail.com', 'admin'], ['john', 'john@gmail.com', 'admin']])\n    ->exec();\n\n\n\n\ninto() method\n\n\nAlias:\n \n\nThis method is an alias of table().\n\n\nPurpose:\n \n\nThe into() method is for selecting the table(s) you want to insert data into.\n\n\nFormat:\n  \n\n\ninto(table_name | array(table_name1, table_name2, ...))\n\n\n\n\nvalues() method\n\n\nPurpose:\n \n\nThe values() method is for specifying the values you want to insert when executing an insert statement.\nIt expects either a single array when inserting a single row of data, or an array of arrays when inserting\nmultiple rows of data.\n\n\nFormat:\n   \n\n\nvalues(array(value1, value2, ...) | array(array(value1, value2, ...), array(value1, value2, ...)))\n\n\n\n\nExamples:\n \n\n\n// Insert a single row of data.\n$db ->insert('name, email, type')\n    ->into('users')\n    ->values(['bob', 'bob@gmail.com', 'admin'])\n    ->exec();\n\n// Insert multiple rows of data\n$db ->insert('name, email, type')\n    ->into('users')\n    ->values([['bob', 'bob@gmail.com', 'admin'], ['john', 'john@gmail.com', 'admin']])\n    ->exec();\n\n// OR insert multiple rows of data by calling values() more than once...\n$db ->insert('name, email, type')\n    ->into('users')\n    ->values(['bob', 'bob@gmail.com', 'admin'])\n    ->values(['john', 'john@gmail.com', 'admin'])\n    ->exec();",
            "title": "INSERT Methods"
        },
        {
            "location": "/documentation/databaseclass/methods_insert/#database-class-methods",
            "text": "",
            "title": "Database Class Methods"
        },
        {
            "location": "/documentation/databaseclass/methods_insert/#insert-method",
            "text": "Purpose:   \nThe insert() method is for specifying the column names you want to insert into.  Format:      in(column | string(column1, column2, column3, ...) | array(column1, column2, column3, ...))  Examples:    // Insert two users 'Bob' and 'John' into the users table.\n$db ->insert('name, email, type')\n    ->into('users')\n    ->values([['bob', 'bob@gmail.com', 'admin'], ['john', 'john@gmail.com', 'admin']])\n    ->exec();",
            "title": "insert() method"
        },
        {
            "location": "/documentation/databaseclass/methods_insert/#into-method",
            "text": "Alias:   \nThis method is an alias of table().  Purpose:   \nThe into() method is for selecting the table(s) you want to insert data into.  Format:     into(table_name | array(table_name1, table_name2, ...))",
            "title": "into() method"
        },
        {
            "location": "/documentation/databaseclass/methods_insert/#values-method",
            "text": "Purpose:   \nThe values() method is for specifying the values you want to insert when executing an insert statement.\nIt expects either a single array when inserting a single row of data, or an array of arrays when inserting\nmultiple rows of data.  Format:      values(array(value1, value2, ...) | array(array(value1, value2, ...), array(value1, value2, ...)))  Examples:    // Insert a single row of data.\n$db ->insert('name, email, type')\n    ->into('users')\n    ->values(['bob', 'bob@gmail.com', 'admin'])\n    ->exec();\n\n// Insert multiple rows of data\n$db ->insert('name, email, type')\n    ->into('users')\n    ->values([['bob', 'bob@gmail.com', 'admin'], ['john', 'john@gmail.com', 'admin']])\n    ->exec();\n\n// OR insert multiple rows of data by calling values() more than once...\n$db ->insert('name, email, type')\n    ->into('users')\n    ->values(['bob', 'bob@gmail.com', 'admin'])\n    ->values(['john', 'john@gmail.com', 'admin'])\n    ->exec();",
            "title": "values() method"
        },
        {
            "location": "/documentation/databaseclass/methods_delete/",
            "text": "Database Class Methods\n\n\ndelete() method\n\n\nPurpose:\n \n\nThe delete() method tells the database class that you want to delete some records from a database table/collection.\n\n\nFormat:\n  \n\n\ndelete()\n\n\n\n\nExamples:\n  \n\n\n// Delete all the records from a users table where their type is 'test'\n$db ->delete()\n    ->from('users')\n    ->where('type', 'test')\n    ->exec();\n\n\n\n\nfrom() method\n\n\nAlias:\n \n\nThis method is an alias of table().\n\n\nPurpose:\n \n\nThe from() method is for selecting the table(s) you want to return or delete data from.\n\n\nFormat:\n  \n\n\nfrom(table_name | array(table_name1, table_name2, ...))\n\n\n\n\nExamples:\n   \n\n\n// Grab a single table\n$db->from('users')\n\n// OR join multiple tables\n$db->from('users')\n   ->from('user_profiles')\n\n// OR grab multiple tables by passing in an array\n$db->from(['users', 'user_profiles'])\n\n\n\n\nwhere() method\n\n\nPurpose:\n \n\nThe where() method is for limiting the records that get returned to only those that pass certain conditions.\n\n\nFormat:\n \n\n\nwhere(column_name, value [, operator] | array(array(column_name, operator, value [, conjunction])))\n\n\n\n\nExamples:\n  \n\n\n// Only return results where name = 'bob'\n$db->where('name', 'bob')\n\n// Only return results where the date is greater than or equal to january first 2014\n$db->where('date', '2014-01-01', '>=')\n\n// Only return results where the date is greater than or equal to january first 2014\n// and less than january 2016\n$db ->where('date', '2014-01-01', '>=')\n    ->where('date', '2016-01-01', '<')\n\n// Only return results where name = 'bob' OR name = 'jeff'\n$db ->where('name', 'bob')\n    ->orWhere('name', 'jeff')\n\n// Pass in an array...\n// Only return results where a user's name starts with 's' or was created after Jan 2016,\n// and the user is of type 'admin' or 'moderator'\n$db ->where([\n        ['created_time', '>=', '2016-01-01', 'OR'],\n        ['name', 'LIKE', 's%']\n    ])\n    ->where([\n        ['type', '=', 'admin', 'OR'],\n        ['type', '=', 'moderator']\n    ])  \n// Using the MySQL adaptor, the above produces:\n// WHERE (created_time >= '2016-01-01' OR name LIKE 's%') AND (type = 'admin' OR type = 'moderator')\n\n\n\n\norWhere() method\n\n\nPurpose:\n \n\nThe orWhere() method is for limiting the records that get returned to only those that pass certain conditions. \n\n\nSimilar To:\n \n\nIt works identically to the where() method except any conditions passed to it will be conjoined with 'OR' to any other Where declarations. See the where() section for more examples.\n\n\nExamples:\n  \n\n\n// Only return users who are named bob and also admins, or users named jeff\n$db ->where([\n        ['name', 'bob'],\n        ['type', 'admin']\n    ])\n    ->orWhere('name', 'jeff')\n// Using the MySQL adaptor, the above produces:\n// WHERE (name = 'bob' AND type = 'admin') OR (name = 'jeff')\n\n\n\n\nin() method\n\n\nPurpose:\n \n\nThe in() method is for checking if a column's value exists in another set of data.\n\n\nFormat:\n   \n\n\nin(column, value | string(value1, value2, value3, ...) | array(value1, value2, value3, ...))\n\n\n\n\nExamples:\n \n\n\n// Check if column value matches a single value (same as using where statement)\n$db ->in('name', 'bob')\n\n// Check if column value is present in a comma separated list\n// Note: The list gets translated into an array by the Database class.\n$db ->in('name', 'bob, jeff, susan')\n\n// Check if column value is present in an array of values\n$db ->in('name', ['bob', 'jeff', 'susan'])\n\n// NOT RECOMMENDED as it breaks cross-database functionality, but possible\n$db ->in('name', 'SELECT name FROM users WHERE name LIKE s%')\n// The better way of doing the above is to do a query to grab all the names that start with 's',\n// then pass the result set as an array to the in() method. This would preserve cross-database\n// functionality and not lock you into databases that support your SQL statement.\n\n\n\n\norderBy() method\n\n\nPurpose:\n \n\nThe orderBy() method is for ordering the returned results from your query.\n\n\nFormat:\n \n\n\n// sort_direction = DESC (descending) | ASC (ascending)\norderBy(column_name, sort_direction)\n\n\n\n\nExamples:\n \n\n\n// Specifying a single column to order by...\n$db ->orderBy('name', 'ASC')\n\n// Specifying multiple columns to order by...\n$db ->orderBy('users.name', 'DESC')\n    ->orderBy('locations.name', 'DESC')\n\n\n\n\nlimit() method\n\n\nPurpose:\n \n\nThe limit() method is for limiting the number of returned results from a query.\n\n\nFormat:\n   \n\n\nlimit(number)\n\n\n\n\nExamples:\n   \n\n\n// Limit the number of result rows to 10\n$db ->limit(10)",
            "title": "DELETE Methods"
        },
        {
            "location": "/documentation/databaseclass/methods_delete/#database-class-methods",
            "text": "",
            "title": "Database Class Methods"
        },
        {
            "location": "/documentation/databaseclass/methods_delete/#delete-method",
            "text": "Purpose:   \nThe delete() method tells the database class that you want to delete some records from a database table/collection.  Format:     delete()  Examples:     // Delete all the records from a users table where their type is 'test'\n$db ->delete()\n    ->from('users')\n    ->where('type', 'test')\n    ->exec();",
            "title": "delete() method"
        },
        {
            "location": "/documentation/databaseclass/methods_delete/#from-method",
            "text": "Alias:   \nThis method is an alias of table().  Purpose:   \nThe from() method is for selecting the table(s) you want to return or delete data from.  Format:     from(table_name | array(table_name1, table_name2, ...))  Examples:      // Grab a single table\n$db->from('users')\n\n// OR join multiple tables\n$db->from('users')\n   ->from('user_profiles')\n\n// OR grab multiple tables by passing in an array\n$db->from(['users', 'user_profiles'])",
            "title": "from() method"
        },
        {
            "location": "/documentation/databaseclass/methods_delete/#where-method",
            "text": "Purpose:   \nThe where() method is for limiting the records that get returned to only those that pass certain conditions.  Format:    where(column_name, value [, operator] | array(array(column_name, operator, value [, conjunction])))  Examples:     // Only return results where name = 'bob'\n$db->where('name', 'bob')\n\n// Only return results where the date is greater than or equal to january first 2014\n$db->where('date', '2014-01-01', '>=')\n\n// Only return results where the date is greater than or equal to january first 2014\n// and less than january 2016\n$db ->where('date', '2014-01-01', '>=')\n    ->where('date', '2016-01-01', '<')\n\n// Only return results where name = 'bob' OR name = 'jeff'\n$db ->where('name', 'bob')\n    ->orWhere('name', 'jeff')\n\n// Pass in an array...\n// Only return results where a user's name starts with 's' or was created after Jan 2016,\n// and the user is of type 'admin' or 'moderator'\n$db ->where([\n        ['created_time', '>=', '2016-01-01', 'OR'],\n        ['name', 'LIKE', 's%']\n    ])\n    ->where([\n        ['type', '=', 'admin', 'OR'],\n        ['type', '=', 'moderator']\n    ])  \n// Using the MySQL adaptor, the above produces:\n// WHERE (created_time >= '2016-01-01' OR name LIKE 's%') AND (type = 'admin' OR type = 'moderator')",
            "title": "where() method"
        },
        {
            "location": "/documentation/databaseclass/methods_delete/#orwhere-method",
            "text": "Purpose:   \nThe orWhere() method is for limiting the records that get returned to only those that pass certain conditions.   Similar To:   \nIt works identically to the where() method except any conditions passed to it will be conjoined with 'OR' to any other Where declarations. See the where() section for more examples.  Examples:     // Only return users who are named bob and also admins, or users named jeff\n$db ->where([\n        ['name', 'bob'],\n        ['type', 'admin']\n    ])\n    ->orWhere('name', 'jeff')\n// Using the MySQL adaptor, the above produces:\n// WHERE (name = 'bob' AND type = 'admin') OR (name = 'jeff')",
            "title": "orWhere() method"
        },
        {
            "location": "/documentation/databaseclass/methods_delete/#in-method",
            "text": "Purpose:   \nThe in() method is for checking if a column's value exists in another set of data.  Format:      in(column, value | string(value1, value2, value3, ...) | array(value1, value2, value3, ...))  Examples:    // Check if column value matches a single value (same as using where statement)\n$db ->in('name', 'bob')\n\n// Check if column value is present in a comma separated list\n// Note: The list gets translated into an array by the Database class.\n$db ->in('name', 'bob, jeff, susan')\n\n// Check if column value is present in an array of values\n$db ->in('name', ['bob', 'jeff', 'susan'])\n\n// NOT RECOMMENDED as it breaks cross-database functionality, but possible\n$db ->in('name', 'SELECT name FROM users WHERE name LIKE s%')\n// The better way of doing the above is to do a query to grab all the names that start with 's',\n// then pass the result set as an array to the in() method. This would preserve cross-database\n// functionality and not lock you into databases that support your SQL statement.",
            "title": "in() method"
        },
        {
            "location": "/documentation/databaseclass/methods_delete/#orderby-method",
            "text": "Purpose:   \nThe orderBy() method is for ordering the returned results from your query.  Format:    // sort_direction = DESC (descending) | ASC (ascending)\norderBy(column_name, sort_direction)  Examples:    // Specifying a single column to order by...\n$db ->orderBy('name', 'ASC')\n\n// Specifying multiple columns to order by...\n$db ->orderBy('users.name', 'DESC')\n    ->orderBy('locations.name', 'DESC')",
            "title": "orderBy() method"
        },
        {
            "location": "/documentation/databaseclass/methods_delete/#limit-method",
            "text": "Purpose:   \nThe limit() method is for limiting the number of returned results from a query.  Format:      limit(number)  Examples:      // Limit the number of result rows to 10\n$db ->limit(10)",
            "title": "limit() method"
        },
        {
            "location": "/documentation/databaseclass/methods_create/",
            "text": "Database Class Methods\n\n\ncreate() method\n\n\nPurpose:\n \n\nThe create() method tells the database class that you want to create a new table/collection.\n\n\nFormat:\n  \n\n\ncreate(new_table_name)\n\n\n\n\nExamples:\n  \n\n\n// Create a table/collection named 'locations'\n$db ->create('locations')\n    ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n    ->field('name', 'varchar(255)')\n    ->field('address', 'varchar(255)')\n    ->field('user_id', 'int')\n    ->primaryKey('id')\n    ->foreignKey('user_id', 'users', 'id')\n    ->exec();\n\n\n\n\nfield() method\n\n\nPurpose:\n \n\nThe field() method denotes a column you want to create on a table.\n\n\nFormat:\n  \n\n\nfield(column_name, column_type, special_attributes)\n\n\n\n\nExamples:\n  \n\n\n// Create a table/collection named 'locations'\n// Create id, name, address, and user_id columns on it.\n$db ->create('locations')\n    ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n    ->field('name', 'varchar(255)')\n    ->field('address', 'varchar(255)')\n    ->field('user_id', 'int')\n    ->primaryKey('id')\n    ->foreignKey('user_id', 'users', 'id')\n    ->exec();\n\n\n\n\nprimaryKey() method\n\n\nPurpose:\n \n\nThe primaryKey() method tells the database class you want to create a primary key index on a column if the underlying\ndatabase supports it.\n\n\nFormat:\n  \n\n\nprimaryKey(column_name)\n\n\n\n\nExamples:\n  \n\n\n// Create a table/collection named 'locations'\n// Sets the 'id' column as primary.\n$db ->create('locations')\n    ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n    ->field('name', 'varchar(255)')\n    ->field('address', 'varchar(255)')\n    ->field('user_id', 'int')\n    ->primaryKey('id')\n    ->foreignKey('user_id', 'users', 'id')\n    ->exec();\n\n\n\n\nforeignKey() method\n\n\nPurpose:\n \n\nThe foreignKey() method tells the database class that you want to create for foreign key relationship\nbetween a column on the table you are creating and a column in a different table.\n\n\nFormat:\n  \n\n\nforeignKey(column_name, foreign_table_name, foreign_column_name)\n\n\n\n\nExamples:\n  \n\n\n// Create a table/collection named 'locations'\n// Creates a relationship between the user_id column on this table and the\n// 'id' column on a different 'users' table.\n$db ->create('locations')\n    ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n    ->field('name', 'varchar(255)')\n    ->field('address', 'varchar(255)')\n    ->field('user_id', 'int')\n    ->primaryKey('id')\n    ->foreignKey('user_id', 'users', 'id')\n    ->exec();",
            "title": "CREATE Methods"
        },
        {
            "location": "/documentation/databaseclass/methods_create/#database-class-methods",
            "text": "",
            "title": "Database Class Methods"
        },
        {
            "location": "/documentation/databaseclass/methods_create/#create-method",
            "text": "Purpose:   \nThe create() method tells the database class that you want to create a new table/collection.  Format:     create(new_table_name)  Examples:     // Create a table/collection named 'locations'\n$db ->create('locations')\n    ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n    ->field('name', 'varchar(255)')\n    ->field('address', 'varchar(255)')\n    ->field('user_id', 'int')\n    ->primaryKey('id')\n    ->foreignKey('user_id', 'users', 'id')\n    ->exec();",
            "title": "create() method"
        },
        {
            "location": "/documentation/databaseclass/methods_create/#field-method",
            "text": "Purpose:   \nThe field() method denotes a column you want to create on a table.  Format:     field(column_name, column_type, special_attributes)  Examples:     // Create a table/collection named 'locations'\n// Create id, name, address, and user_id columns on it.\n$db ->create('locations')\n    ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n    ->field('name', 'varchar(255)')\n    ->field('address', 'varchar(255)')\n    ->field('user_id', 'int')\n    ->primaryKey('id')\n    ->foreignKey('user_id', 'users', 'id')\n    ->exec();",
            "title": "field() method"
        },
        {
            "location": "/documentation/databaseclass/methods_create/#primarykey-method",
            "text": "Purpose:   \nThe primaryKey() method tells the database class you want to create a primary key index on a column if the underlying\ndatabase supports it.  Format:     primaryKey(column_name)  Examples:     // Create a table/collection named 'locations'\n// Sets the 'id' column as primary.\n$db ->create('locations')\n    ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n    ->field('name', 'varchar(255)')\n    ->field('address', 'varchar(255)')\n    ->field('user_id', 'int')\n    ->primaryKey('id')\n    ->foreignKey('user_id', 'users', 'id')\n    ->exec();",
            "title": "primaryKey() method"
        },
        {
            "location": "/documentation/databaseclass/methods_create/#foreignkey-method",
            "text": "Purpose:   \nThe foreignKey() method tells the database class that you want to create for foreign key relationship\nbetween a column on the table you are creating and a column in a different table.  Format:     foreignKey(column_name, foreign_table_name, foreign_column_name)  Examples:     // Create a table/collection named 'locations'\n// Creates a relationship between the user_id column on this table and the\n// 'id' column on a different 'users' table.\n$db ->create('locations')\n    ->field('id', 'int', 'NOT NULL AUTO_INCREMENT')\n    ->field('name', 'varchar(255)')\n    ->field('address', 'varchar(255)')\n    ->field('user_id', 'int')\n    ->primaryKey('id')\n    ->foreignKey('user_id', 'users', 'id')\n    ->exec();",
            "title": "foreignKey() method"
        },
        {
            "location": "/documentation/databaseclass/databaseresult/",
            "text": "",
            "title": "DatabaseResult Class"
        },
        {
            "location": "/documentation/events/overview/",
            "text": "Event System\n\n\ntl;dr - You can fire events that trigger the execution of other blocks of code.\n\n\nSo Cora's event system offers an alternate way to execute code from the\nusual controller logic flow. Anything you can accomplish using events you can\nalso accomplish without them, but there are situations where\nusing events may make more sense than traditional controller logic.\n\n\nThe Basic Idea\n\n\nThe basic idea is that somewhere in your executed code (probably a controller),\nyou \"fire\" an Event. That Event will have any number of listeners attached to it\nthat \"listen\" for that event to happen. Each of those listeners are passed a\ncopy of the Event object and then execute whatever action they are designed to\nimplement.\n\n\nSay for instance you are building a game and want a number of things to happen\nwhen a new user registers on your site:\n\n\n\n\nSign the user up for your game's newsletter.\n\n\nCredit the new player's account with a starting amount of in-game credit.\n\n\nForward the user to a special \"Welcome new player\" page.\n\n\n\n\nDoing this using normal Controller based logic might look like this:\n\n\n// A Controller\nclass Users extends \\MyApp\n    public function register()\n    {\n        // Form submission verification\n        // Check that data is valid and username is available.\n        // (not shown)\n\n        // Grab registration form data\n        $username = $this->input->post('username');\n        $email    = $this->input->post('email');\n        $password = $this->input->post('password');\n\n        // Load an Authorization library\n        $auth = new \\Library\\Auth();\n\n        // Register User\n        $auth->register($username, $password, $email);\n\n        // Sign user up for newsletter\n        $newsletter = new Newsletter($this->container);\n        $newsletter->signup($username, $email);\n\n        // Credit user's account with game currency\n        $gameAccount = new GameAccount($this->container);\n        $gameAccount->addCredit($username, 500);\n\n        // Forward user to Welcome page\n        $this->welcome();\n    }\n}\n\n\n\n\nAnd honestly, if you look at the above example, it's not bad. There's perfectly\nnothing wrong with handling the user registration process that way. That said,\nif you wanted to keep your \"register\" method clean of extra code and focused\nsolely on the act of registering a user, using Events is an option. Let's do\nthe same thing again, but this time let's see what the Controller looks like\nwith an Event:",
            "title": "Overview"
        },
        {
            "location": "/documentation/events/overview/#event-system",
            "text": "tl;dr - You can fire events that trigger the execution of other blocks of code.  So Cora's event system offers an alternate way to execute code from the\nusual controller logic flow. Anything you can accomplish using events you can\nalso accomplish without them, but there are situations where\nusing events may make more sense than traditional controller logic.",
            "title": "Event System"
        },
        {
            "location": "/documentation/events/overview/#the-basic-idea",
            "text": "The basic idea is that somewhere in your executed code (probably a controller),\nyou \"fire\" an Event. That Event will have any number of listeners attached to it\nthat \"listen\" for that event to happen. Each of those listeners are passed a\ncopy of the Event object and then execute whatever action they are designed to\nimplement.  Say for instance you are building a game and want a number of things to happen\nwhen a new user registers on your site:   Sign the user up for your game's newsletter.  Credit the new player's account with a starting amount of in-game credit.  Forward the user to a special \"Welcome new player\" page.   Doing this using normal Controller based logic might look like this:  // A Controller\nclass Users extends \\MyApp\n    public function register()\n    {\n        // Form submission verification\n        // Check that data is valid and username is available.\n        // (not shown)\n\n        // Grab registration form data\n        $username = $this->input->post('username');\n        $email    = $this->input->post('email');\n        $password = $this->input->post('password');\n\n        // Load an Authorization library\n        $auth = new \\Library\\Auth();\n\n        // Register User\n        $auth->register($username, $password, $email);\n\n        // Sign user up for newsletter\n        $newsletter = new Newsletter($this->container);\n        $newsletter->signup($username, $email);\n\n        // Credit user's account with game currency\n        $gameAccount = new GameAccount($this->container);\n        $gameAccount->addCredit($username, 500);\n\n        // Forward user to Welcome page\n        $this->welcome();\n    }\n}  And honestly, if you look at the above example, it's not bad. There's perfectly\nnothing wrong with handling the user registration process that way. That said,\nif you wanted to keep your \"register\" method clean of extra code and focused\nsolely on the act of registering a user, using Events is an option. Let's do\nthe same thing again, but this time let's see what the Controller looks like\nwith an Event:",
            "title": "The Basic Idea"
        },
        {
            "location": "/documentation/events/eventmanager/",
            "text": "",
            "title": "Event Manager"
        },
        {
            "location": "/documentation/events/eventmapping/",
            "text": "",
            "title": "Event Mapping"
        },
        {
            "location": "/documentation/events/event/",
            "text": "",
            "title": "Event"
        },
        {
            "location": "/documentation/events/listener/",
            "text": "",
            "title": "Listener"
        },
        {
            "location": "/documentation/validationclass/overview/",
            "text": "Cora's Validation class\n\n\nThe Validate class is for checking that data matches a set of restrictions. For instance, if you have a form for users to submit and want to require that they fill out the 'email' field and enter something that at least looks like a valid email, Validate can help with that. It's main usage will typically be for validating form submissions, but it can be used to validate any data you pass in.\n\n\nNote that the Validate class must be called from a Controller as any errors returned will be loaded into that controller's \"$this->data->errors\" data member!\n\n\nFront-end vs. Back-end Validation:\n   \n\n\nIf you are unfamiliar with form validation, it's worth mentioning that front-end Javascript validators are easier to setup and can save you that tiny bit of server processing power if efficiency is important. The main drawbacks of front-end validation is that it can be \nbypassed\n (important to know if you didn't already know that) and you have to setup a special API in order to do things like check if a Username is already taken, etc. For this reason, for validation that is even remotely important, you should either use back-end validation like this Validation class provides, or use both a front-end validator and this class on the backend (in-case a user bypasses the front-end validation code).\n\n\nExample Usage\n\n\n// This is a method within a controller.\npublic function createPOST()\n{\n    // Load Validate\n    $this->load->library('Validate', $this, true);  \n\n    // Define validation rules for form inputs.\n    $this->Validate->rule('username', 'required|max_length[55]|trim');\n    $this->Validate->rule('email', 'required|valid_email');\n    $this->Validate->rule('password', 'required');\n    $this->Validate->rule('password2', 'required|matches[password]');\n\n    // Initiate validation\n    if ($this->Validate->run()) {        \n        // Form validation was successful! Do stuff with data.\n    }\n    else {      \n        // The form validation failed!\n        // Redisplay the form to the user so they can fix the errors.\n        $this->create();\n    }\n}\n\n\n\n\nIf you are using the Cora demo project, you can find an example form being used at:\n\n\n/controllers/articles/controller.News.php\n\n\n\n\nWhich can be navigated to in your web browser by going to:\n\n\nlocalhost/myProject/articles/news/create/\n\n\n\n\nTypical Usage Steps\n\n\nUsage typically includes the following steps:\n\n\n\n\nLoad the validation class.\n\n\nDefine any custom validation checks you need.\n\n\nApply validation checks to pieces of data by defining the rules that data must obey.\n\n\nRun the validation checker.\n\n\nDisplay any errors to the user and repopulate the form they submitted if necessary.\n\n\n\n\nLoading\n\n\nAlthough you can certainly load Validate like any other class, the recommended way of loading it into your controller is to use the Load class. The load class handles some references stuff for you automatically which I'll explain later. To use the Load class to get Validate, add the following to your controller:\n\n\n// Recommended way of setup\n$this->load->library('Validate', $this, true);\n\n\n\n\nThe fact that we're specifying that we want to load the Validate class as the first parameter should make sense. What you're probably wondering about is what the other two parameters do. For the 2nd parameter we're passing a reference to the current controller; Validate uses this reference to load any validation errors generated into that controller's \"$this->data->errors\" data member. The third parameter being true tells the Load class to create a reference in the calling controller to Validate for you. In other words it does the equivalent of this:\n\n\n$this->data->Validate = new \\Validate($this);\n\n\n\n\nOk... but why do you need a reference to Validate in the controller like that? Because in order to use Validate's form repopulation methods within a View file, you need a reference to Validate in the data you pass to that view! If this doesn't make sense at the moment, don't worry about it. You might understand it better once you see usage examples below, and even if you don't, it's not important so long as you follow the recommended way of loading specified above.\n\n\nBuilt-In Validation Checks\n\n\nThere are a few built-in validation checks for common concerns. They are:\n\n\n\n\n\n    \n'Check' Name\n\n    \nDescription\n\n\n\n\n\n    \nrequired\n\n    \nSpecifies that a value must be entered for this field (specifying form fields that MUST be filled out).\n\n\n\n\n\n    \nvalid_email\n\n    \nSpecifies that the value must match a valid email pattern.\n\n\n\n\n\n    \nmatches[name]\n\n    \nSpecifies that this field must match the one specified in the brackets (I.E. does 'password' match 'password2'?)\n\n\n\n\n\n    \nmin_length[x]\n\n    \nSpecifies that this field must be at least X characters in length.\n\n\n\n\n\n    \nmax_length[x]\n\n    \nSpecifies that this field must be at most X characters in length.\n\n\n\n\n\n    \ntrim\n\n    \nTrims whitespace from the beginning and end of the field. Doesn't ever fail, this is just a utility method.\n\n\n\n\n\n\n\nHowever, while these work great for general purpose kinda validations, there might be times when you need to check something specific such as \"Is this username already taken?\" In those scenarios you will need to define your own validation \"check\" which can then be applied to a field just like the built-in ones.\n\n\nCustom Validation Checks\n\n\nCustom validation checks allow you to call a method from whatever class you want within your app and pass that method the input value. Below is an example of us defining a custom check that calls a method named \"isNameAvailable\" within our User class, so that we can check if a username a person wants is available when they register. (Note: The 4th parameter is the error message if the name isn't available.)\n\n\nDefining a custom validation check is easy. Here's an example:\n\n\n// Define the check\n$this->Validate->def('userNameAvailable', 'User','isNameAvailable', 'Username already taken.');\n\n// Use the check in a rule\n$this->Validate->rule('username', 'required|userNameAvailable');\n\n\n\n\nThe \"def\" method takes 4 required parameters, with the 5th and 6th being optional. Below is the function signature and a description of what each parameter does:\n\n\n$this->Validate->def($checkName, $class, $method, $errorMessageOnFailure, $passingResponse, $arguments);\n\n\n\n\n\n\n\n    \nParameter Name\n\n    \nDescription\n\n\n\n\n\n    \n$checkName\n\n    \nThis is the name of your new custom check. It's what you will include when defining your data rules.\n\n\n\n\n\n    \n$class\n\n    \nThe class within your app that we want to invoke for this custom check.\n\n\n\n\n\n    \n$method\n\n    \nThe method within that Class that we want to call and pass our input to.\n\n\n\n\n\n    \n$errorMessageOnFailure\n\n    \nThe message to display if this check does not pass.\n\n\n\n\n\n    \n$passingResponse\n\n    \n[OPTIONAL] Custom check methods are expected to return a TRUE or FALSE response when given the form input. This specifies which response is the passing one! By default this is set to TRUE. See below for examples.\n\n\n\n\n\n    \n$arguments\n\n    \n\n        [OPTIONAL] The method you call will always receive as its first argument the value of the field being validated. However,\n        there may be situations in which you need to pass along additional info. This parameter will get passed in as the 2nd argument to the custom check.\n    \n\n\n\n\n\n\n\nSo the optional 5th parameter when defining a custom check needs a little explaining. Basically, whatever methods you call for custom checks are expected to return True or False when given a certain input. However, which response \"passes\" the check, depends on how the method is written - and is why this optional 5th parameter exists. See the examples below:\n\n\n// Example 1 - A 'TRUE' value means the check passes.\n// Check passes if 'isNameAvailable' returns TRUE.\n$this->Validate->def('userNameAvailable', 'User','isNameAvailable', 'Username already taken.', TRUE);\n$this->Validate->rule('username', 'required|userNameAvailable');\n\n// Example 2 - A 'FALSE' value means the check passes.\n// Check passes if 'isNameTaken' returns FALSE.\n$this->Validate->def('userNameIsTaken', 'User','isNameTaken', 'Username already taken.', FALSE);\n$this->Validate->rule('username', 'required|userNameIsTaken');\n\n// Example 3 - A 'FALSE' value means the check passes. But we also need to pass along\n// whether accounts are identified by username or by email.\n// Check passes if 'accountExists' returns FALSE.\n$validationType = 'email'; // As opposed to 'username'\n$this->Validate->def('accountExists', 'Library\\\\Auth','accountExists', \"An account with that $validationType already exists.\"\", false, $validationType);\n$this->Validate->rule('email', 'required|accountExists|trim');\n\n// Then in the Auth Library:\npublic static function accountExists($authValue = false, $authField = false)\n{\n    // $authField is the field we are using for login validation, usually this is either 'username' or 'email'\n    // $authValue is the form data that was passed in. If validating by email, then presumably it's be the user's email address.\n\n    // Do stuff to figure out if an account exists, then return True or False.\n}\n\n\n\n\nHuman Readable Field Names\n\n\nIf you have a form input that has a name which isn't super user friendly, you can replace the name of the input in any error messages with a custom specified name by specifying an optional 3rd parameter when making your rules:\n\n\n$this->Validate->rule('password2', 'required|matches[password]', 'Password Confirmation');\n\n\n\n\nThis will result in the following error message if validation fails: \n\n\n\"Password Confirmation does not match password!\"\n\n\nDisplaying errors\n\n\nFrom within a View, the array of errors can be found within the \"$errors\" variable. They can be displayed by using the Load class' \"repeat\" method (this is the easiest way), or else you can manually iterate over the errors. Both methods are shown below:\n\n\nRepeat Method:\n   \n\n\n// Parameter 1 = Array to iterate over.\n// Parameter 2 = Tag to surround array items with.\n// Parameter 3 = [OPTIONAL] CSS class to attach to each item.\n// Parameter 4 = [OPTIONAL] Tag to wrap entire repeat block with.\n// Parameter 5 = [OPTIONAL] CSS class to attach to wrapper.\n<?= $this->repeat($errors, 'li', 'item', 'ul', 'list'); ?>\n\n\n\n\nGenerates:\n\n\n<ul class=\"list\">\n    <li class=\"item\">Error 1</li>\n    <li class=\"item\">Error 2</li>\n    ...\n</ul>\n\n\n\n\nOR\n\n\nManual Method:\n   \n\n\n<?php if (isset($errors)) { ?>\n    <ul>\n        <?php foreach ($errors as $error) { ?>\n            <li><?= $error; ?></li>\n        <?php } ?>\n    </ul>\n<?php } ?>\n\n\n\n\nRepopulating Forms\n\n\nThere's three methods in the Validate class that are designed to help you repopulate a form if validation fails.\n\n\n// For repopulating text boxes and text areas.\n$Validate->setField($fieldName, $defaultValue = '')\n\n// For repopulating check boxes and ratio buttons.\n$Validate->setCheckbox($fieldName, $fieldValue, $checkedByDefault = FALSE)\n\n// For repopulating select boxes.\n$Validate->setSelect($fieldName, $fieldValue, $selectedByDefault = FALSE)\n\n\n\n\nThese need to be echo'ed inside the HTML tag in question. See below for an example of a complete form with errors display and repopulation of the fields:\n\n\n\n\n\n<h1>Create Article</h1>\n<form method=\"POST\">\n\n    <?= $this->repeat($errors, 'li', 'item', 'ul', 'list'); ?>\n\n\n    <div>\n        <h3>Title:</h3>\n        <input type=\"text\" name=\"title\" value=\"<?= $Validate->setField('title', 'test'); ?>\">\n    </div>\n    <div>\n        <h3>Content:</h3>\n        <textarea name=\"content\"><?= $Validate->setField('content'); ?></textarea>\n    </div>\n    <br>\n\n    <div>\n        Item 1:<input type=\"checkbox\" name=\"mycheck[]\" value=\"1\" <?=$Validate->setCheckbox('mycheck', '1');?>>\n        <br>\n        Item 2:<input type=\"checkbox\" name=\"mycheck[]\" value=\"2\" <?=$Validate->setCheckbox('mycheck', '2', true);?>>\n    </div>\n    <br>\n\n    <div>\n        <select name=\"myselect\">\n            <option value=\"Option One\" <?= $Validate->setSelect('myselect', 'Option One'); ?> >One</option>\n            <option value=\"Option Two\" <?= $Validate->setSelect('myselect', 'Option Two', true); ?> >Two</option>\n            <option value=\"Option Three\" <?= $Validate->setSelect('myselect', 'Option Three'); ?> >Three</option>\n        </select>\n    </div>\n    <br>\n\n    <input type=\"submit\" value=\"Submit\">\n</form>",
            "title": "Validate Class"
        },
        {
            "location": "/documentation/validationclass/overview/#coras-validation-class",
            "text": "The Validate class is for checking that data matches a set of restrictions. For instance, if you have a form for users to submit and want to require that they fill out the 'email' field and enter something that at least looks like a valid email, Validate can help with that. It's main usage will typically be for validating form submissions, but it can be used to validate any data you pass in.  Note that the Validate class must be called from a Controller as any errors returned will be loaded into that controller's \"$this->data->errors\" data member!  Front-end vs. Back-end Validation:      If you are unfamiliar with form validation, it's worth mentioning that front-end Javascript validators are easier to setup and can save you that tiny bit of server processing power if efficiency is important. The main drawbacks of front-end validation is that it can be  bypassed  (important to know if you didn't already know that) and you have to setup a special API in order to do things like check if a Username is already taken, etc. For this reason, for validation that is even remotely important, you should either use back-end validation like this Validation class provides, or use both a front-end validator and this class on the backend (in-case a user bypasses the front-end validation code).",
            "title": "Cora's Validation class"
        },
        {
            "location": "/documentation/validationclass/overview/#example-usage",
            "text": "// This is a method within a controller.\npublic function createPOST()\n{\n    // Load Validate\n    $this->load->library('Validate', $this, true);  \n\n    // Define validation rules for form inputs.\n    $this->Validate->rule('username', 'required|max_length[55]|trim');\n    $this->Validate->rule('email', 'required|valid_email');\n    $this->Validate->rule('password', 'required');\n    $this->Validate->rule('password2', 'required|matches[password]');\n\n    // Initiate validation\n    if ($this->Validate->run()) {        \n        // Form validation was successful! Do stuff with data.\n    }\n    else {      \n        // The form validation failed!\n        // Redisplay the form to the user so they can fix the errors.\n        $this->create();\n    }\n}  If you are using the Cora demo project, you can find an example form being used at:  /controllers/articles/controller.News.php  Which can be navigated to in your web browser by going to:  localhost/myProject/articles/news/create/",
            "title": "Example Usage"
        },
        {
            "location": "/documentation/validationclass/overview/#typical-usage-steps",
            "text": "Usage typically includes the following steps:   Load the validation class.  Define any custom validation checks you need.  Apply validation checks to pieces of data by defining the rules that data must obey.  Run the validation checker.  Display any errors to the user and repopulate the form they submitted if necessary.",
            "title": "Typical Usage Steps"
        },
        {
            "location": "/documentation/validationclass/overview/#loading",
            "text": "Although you can certainly load Validate like any other class, the recommended way of loading it into your controller is to use the Load class. The load class handles some references stuff for you automatically which I'll explain later. To use the Load class to get Validate, add the following to your controller:  // Recommended way of setup\n$this->load->library('Validate', $this, true);  The fact that we're specifying that we want to load the Validate class as the first parameter should make sense. What you're probably wondering about is what the other two parameters do. For the 2nd parameter we're passing a reference to the current controller; Validate uses this reference to load any validation errors generated into that controller's \"$this->data->errors\" data member. The third parameter being true tells the Load class to create a reference in the calling controller to Validate for you. In other words it does the equivalent of this:  $this->data->Validate = new \\Validate($this);  Ok... but why do you need a reference to Validate in the controller like that? Because in order to use Validate's form repopulation methods within a View file, you need a reference to Validate in the data you pass to that view! If this doesn't make sense at the moment, don't worry about it. You might understand it better once you see usage examples below, and even if you don't, it's not important so long as you follow the recommended way of loading specified above.",
            "title": "Loading"
        },
        {
            "location": "/documentation/validationclass/overview/#built-in-validation-checks",
            "text": "There are a few built-in validation checks for common concerns. They are:   \n     'Check' Name \n     Description   \n     required \n     Specifies that a value must be entered for this field (specifying form fields that MUST be filled out).   \n     valid_email \n     Specifies that the value must match a valid email pattern.   \n     matches[name] \n     Specifies that this field must match the one specified in the brackets (I.E. does 'password' match 'password2'?)   \n     min_length[x] \n     Specifies that this field must be at least X characters in length.   \n     max_length[x] \n     Specifies that this field must be at most X characters in length.   \n     trim \n     Trims whitespace from the beginning and end of the field. Doesn't ever fail, this is just a utility method.    However, while these work great for general purpose kinda validations, there might be times when you need to check something specific such as \"Is this username already taken?\" In those scenarios you will need to define your own validation \"check\" which can then be applied to a field just like the built-in ones.",
            "title": "Built-In Validation Checks"
        },
        {
            "location": "/documentation/validationclass/overview/#custom-validation-checks",
            "text": "Custom validation checks allow you to call a method from whatever class you want within your app and pass that method the input value. Below is an example of us defining a custom check that calls a method named \"isNameAvailable\" within our User class, so that we can check if a username a person wants is available when they register. (Note: The 4th parameter is the error message if the name isn't available.)  Defining a custom validation check is easy. Here's an example:  // Define the check\n$this->Validate->def('userNameAvailable', 'User','isNameAvailable', 'Username already taken.');\n\n// Use the check in a rule\n$this->Validate->rule('username', 'required|userNameAvailable');  The \"def\" method takes 4 required parameters, with the 5th and 6th being optional. Below is the function signature and a description of what each parameter does:  $this->Validate->def($checkName, $class, $method, $errorMessageOnFailure, $passingResponse, $arguments);   \n     Parameter Name \n     Description   \n     $checkName \n     This is the name of your new custom check. It's what you will include when defining your data rules.   \n     $class \n     The class within your app that we want to invoke for this custom check.   \n     $method \n     The method within that Class that we want to call and pass our input to.   \n     $errorMessageOnFailure \n     The message to display if this check does not pass.   \n     $passingResponse \n     [OPTIONAL] Custom check methods are expected to return a TRUE or FALSE response when given the form input. This specifies which response is the passing one! By default this is set to TRUE. See below for examples.   \n     $arguments \n     \n        [OPTIONAL] The method you call will always receive as its first argument the value of the field being validated. However,\n        there may be situations in which you need to pass along additional info. This parameter will get passed in as the 2nd argument to the custom check.\n        So the optional 5th parameter when defining a custom check needs a little explaining. Basically, whatever methods you call for custom checks are expected to return True or False when given a certain input. However, which response \"passes\" the check, depends on how the method is written - and is why this optional 5th parameter exists. See the examples below:  // Example 1 - A 'TRUE' value means the check passes.\n// Check passes if 'isNameAvailable' returns TRUE.\n$this->Validate->def('userNameAvailable', 'User','isNameAvailable', 'Username already taken.', TRUE);\n$this->Validate->rule('username', 'required|userNameAvailable');\n\n// Example 2 - A 'FALSE' value means the check passes.\n// Check passes if 'isNameTaken' returns FALSE.\n$this->Validate->def('userNameIsTaken', 'User','isNameTaken', 'Username already taken.', FALSE);\n$this->Validate->rule('username', 'required|userNameIsTaken');\n\n// Example 3 - A 'FALSE' value means the check passes. But we also need to pass along\n// whether accounts are identified by username or by email.\n// Check passes if 'accountExists' returns FALSE.\n$validationType = 'email'; // As opposed to 'username'\n$this->Validate->def('accountExists', 'Library\\\\Auth','accountExists', \"An account with that $validationType already exists.\"\", false, $validationType);\n$this->Validate->rule('email', 'required|accountExists|trim');\n\n// Then in the Auth Library:\npublic static function accountExists($authValue = false, $authField = false)\n{\n    // $authField is the field we are using for login validation, usually this is either 'username' or 'email'\n    // $authValue is the form data that was passed in. If validating by email, then presumably it's be the user's email address.\n\n    // Do stuff to figure out if an account exists, then return True or False.\n}",
            "title": "Custom Validation Checks"
        },
        {
            "location": "/documentation/validationclass/overview/#human-readable-field-names",
            "text": "If you have a form input that has a name which isn't super user friendly, you can replace the name of the input in any error messages with a custom specified name by specifying an optional 3rd parameter when making your rules:  $this->Validate->rule('password2', 'required|matches[password]', 'Password Confirmation');  This will result in the following error message if validation fails:   \"Password Confirmation does not match password!\"",
            "title": "Human Readable Field Names"
        },
        {
            "location": "/documentation/validationclass/overview/#displaying-errors",
            "text": "From within a View, the array of errors can be found within the \"$errors\" variable. They can be displayed by using the Load class' \"repeat\" method (this is the easiest way), or else you can manually iterate over the errors. Both methods are shown below:  Repeat Method:      // Parameter 1 = Array to iterate over.\n// Parameter 2 = Tag to surround array items with.\n// Parameter 3 = [OPTIONAL] CSS class to attach to each item.\n// Parameter 4 = [OPTIONAL] Tag to wrap entire repeat block with.\n// Parameter 5 = [OPTIONAL] CSS class to attach to wrapper.\n<?= $this->repeat($errors, 'li', 'item', 'ul', 'list'); ?>  Generates:  <ul class=\"list\">\n    <li class=\"item\">Error 1</li>\n    <li class=\"item\">Error 2</li>\n    ...\n</ul>  OR  Manual Method:      <?php if (isset($errors)) { ?>\n    <ul>\n        <?php foreach ($errors as $error) { ?>\n            <li><?= $error; ?></li>\n        <?php } ?>\n    </ul>\n<?php } ?>",
            "title": "Displaying errors"
        },
        {
            "location": "/documentation/validationclass/overview/#repopulating-forms",
            "text": "There's three methods in the Validate class that are designed to help you repopulate a form if validation fails.  // For repopulating text boxes and text areas.\n$Validate->setField($fieldName, $defaultValue = '')\n\n// For repopulating check boxes and ratio buttons.\n$Validate->setCheckbox($fieldName, $fieldValue, $checkedByDefault = FALSE)\n\n// For repopulating select boxes.\n$Validate->setSelect($fieldName, $fieldValue, $selectedByDefault = FALSE)  These need to be echo'ed inside the HTML tag in question. See below for an example of a complete form with errors display and repopulation of the fields:   <h1>Create Article</h1>\n<form method=\"POST\">\n\n    <?= $this->repeat($errors, 'li', 'item', 'ul', 'list'); ?>\n\n\n    <div>\n        <h3>Title:</h3>\n        <input type=\"text\" name=\"title\" value=\"<?= $Validate->setField('title', 'test'); ?>\">\n    </div>\n    <div>\n        <h3>Content:</h3>\n        <textarea name=\"content\"><?= $Validate->setField('content'); ?></textarea>\n    </div>\n    <br>\n\n    <div>\n        Item 1:<input type=\"checkbox\" name=\"mycheck[]\" value=\"1\" <?=$Validate->setCheckbox('mycheck', '1');?>>\n        <br>\n        Item 2:<input type=\"checkbox\" name=\"mycheck[]\" value=\"2\" <?=$Validate->setCheckbox('mycheck', '2', true);?>>\n    </div>\n    <br>\n\n    <div>\n        <select name=\"myselect\">\n            <option value=\"Option One\" <?= $Validate->setSelect('myselect', 'Option One'); ?> >One</option>\n            <option value=\"Option Two\" <?= $Validate->setSelect('myselect', 'Option Two', true); ?> >Two</option>\n            <option value=\"Option Three\" <?= $Validate->setSelect('myselect', 'Option Three'); ?> >Three</option>\n        </select>\n    </div>\n    <br>\n\n    <input type=\"submit\" value=\"Submit\">\n</form>",
            "title": "Repopulating Forms"
        },
        {
            "location": "/computerscience/computability/",
            "text": "Computability\n\n\nModern computers are based on what's called a Turing Machine, which was the first general purpose type of computer. What can a Turing Machine based computer compute? What can\u2019t a turing machine based computer compute? \nWhat kind of problems are impractical to compute for anything other than really small data sets? We\u2019ll briefly explore these questions below.\n\n\nStraight up Non-Computable\n\n\nLet's first talk about problems that current computers simply cannot compute.\n\n\nThe Halting Problem\n\n\nIf you are a software developer, you undoubtably have encountered infinite loops. Unlike interpretted\nlanguages such as PHP which will time out, lower level languages such as C++ will just keep running in an infinite loop forever if one exists.\nWith this in mind, it may seem like a good idea for someone to create a debugging program that detects those kinds of run-time errors in apps.\nHowever, you may be surprised to learn that \nthe reason why no such program exists is because it's impossible for a computer to determine if an\narbitrary computer program and input will finish running or not.\n\n\nTo informally prove this, let's assume we have a function called \"does_it_halt\" which we can pass an arbitrary program and input to and have it\ntell us if the program will halt or loop indefinitely.\n\n\n\n\nAssumption:\n \n\nThere exists a way for a computer to detect if any arbitrary program and input will halt or not.\n\n\n\n\nWith that assumption, let's assume someone wrote the following function as a simple way to utilize this knowledge:\n\n\nfunction does_it_halt(program, input) {\n    if (eventually halts)\n        return true;\n    else\n        return false;\n}\n\n\n\n\nFor simplicity's sake let's also say someone wrote wrapper for this function that passes the program as the input. Remember that our\ndoes_it_halt method is supposed to work on any arbitrary input, so passing in the memory location or text of a program works just fine.\n\n\nfunction debug_app(program) {\n    return does_it_halt(program, program);\n}\n\n\n\n\nAlright, hopefully you'll agree this is pretty straight forward. Now let's say someone really smart informed us that our does_it_halt function\ncouldn't possibly work, but we didn't believe him. As a result, he decided to write a cheeky little function called paradox that does the following:\n\n\nfunction paradox(program) {\n    if(debug_app(program))\n        while(1) {};\n    else\n        return true;\n}\n\necho debug_app(paradox);\n\n\n\n\nHa ha ha... so this dude wrote a function that puts itself into an intentional infinite loop if the does_it_halt says the program stops,\nand returns \"true\" if the program does not stop. Then he follows this up by calling our debug function on his code. \nSurely this is the most useless bit of code ever written right?\n\n\nWell, before we can answer that, we have to examine what happens when this dude calls debug_app(paradox).\n\n\nLet's say our debug_app() method returns true when passed Paradox. Let's logically think through what that means in terms of execution:\n\n\n\n\nFirst up, since \"echo debug_app(Paradox)\" returned True, that means that Paradox halts.\n\n\nIn the process of testing if Paradox halts, does_it_halt(), somewhere in its magical logic would have to run Paradox with the given input. That input is also a reference to Paradox. So the call to paradox would look like \"paradox(paradox)\".\n\n\nHowever, inside of Paradox is also a call to debug_app()! This call to \"debug_app(program)\" within Paradox would resolve to \"debug_app(Paradox)\" at runtime.\n\n\nIn order for does_it_halt to detect that Paradox halts, that means the call to \"debug_app(Paradox)\" within Paradox returns False, because otherwise Paradox would send itself into an infinite loop.\n\n\n\n\nUhh oh! Turns out that little piece of code wasn't as useless as we originally thought because it just proved that our does_it_halt function can't possibly exist as we've defined it.\nWe know from point #1 above that \"echo debug_app(Paradox)\" returns true, however, we also know that in order for that to happen, the call to \"debug_app(Paradox)\" as mentioned in point #4 above must return false. So two different calls to \"debug_app(Paradox)\" are returning differing results which is impossible. As such, our premise is proved false by what's called a Proof By Contradiction.\n\n\nThis problem (\"will a program halt\") which is unsolvable by computers by is known commonly as The Halting Problem. Alan Turing proved back in 1936 that a general algorithm to solve it is not possible.\n\n\nPost-Correspondance Problem (PCP)\n\n\nAnother quick example just to peak your interest. Let's say you have a list of some arbitrary number of dominoes which look something like this:\n\n\n\n    \nc\n\n    \ncb\n\n\n\n\n\n\n    \nac\n\n    \na\n\n\n\n\n\n\n    \nb\n\n    \nbc\n\n\n\n\n\n\n    \na\n\n    \nba\n\n\n\n\n\n\n    \na\n\n    \nc\n\n\n\n\n\n\n    \nc\n\n    \nac\n\n\n\n\n\n\n    \ncb\n\n    \n \nc\n\n\n\n\n\n\n    \naa\n\n    \nb\n\n\n\n\n\n\n\n\nYou want to have a computer tell you whether there's a way in which you can order the dominoes such that the sequence of the top row matches the sequence of the bottom row.\nHere's an example of a match where both the top and the bottom read \"abbcbba\":\n\n\n\n\n\n\n    \na\n\n    \nabb\n\n\n\n\n\n\n    \nbb\n\n    \nc\n\n\n\n\n\n\n    \ncb\n\n    \nbb\n\n\n\n\n\n\n    \nba\n\n    \na\n\n\n\n\n\n\n\n\nCan a computer program be made for you that determines if there's an ordering that results in a match for an arbitrary set of dominoes? The answer is \"no\". This is called the Post Correspondence Problem and was introduced by Emil Post back in 1946.\n\n\nEffectively Uncomputable (with our current algorithms)\n\n\nP vs NP\n\n\nIn order to discuss problems that fall into this \"effectively uncomputable\" category, we quickly need to discuss the concept of P vs. NP.\n\"P\" are a class of problems for which their exists an algorithm to both find and verify an answer in polynomial time.\n\"NP\" (non-deterministic polynomial time) are a class of problems for which there exists algorithms to verify an answer in polynomial time, but \nmay or may not\n have algorithms to find an answer.\nNote the \"may or may not\" statement... P vs. NP is actually one of the biggest unknowns in Mathematics/CS because no-one has been able to prove definitively \nthat P = NP or that P != NP. \n\n\nIf P = NP, then that means there DOES exist polynomial time algorithms to solve problems we lump into this category, but that we just haven't found them yet. If P != NP, then that would confirm that no such polynomial time algorithms exist, and we could stop looking. There has been a 1 million dollar reward on the table since the year 2000 for anyone that can prove this one way or the other.\n\n\nSo if you're wondering at this point what the heck polynomial time is, and wishing you could remember all your math lessons from high school, no fear - let's look at an example:\n\n\nx^3 + 2x^2 + 3x = A Polynomial\n\n\n\n\nThe importance of polynomials is that they, and anything less complex than them, can be quickly solved by computers. Equations can be generally clumped into one of a number of different time groups:\n\n\ny = 1       // Constant time\ny = x       // Linear time\ny = x^2     // Polynomial time\ny = 2^x     // Exponential time\ny = x!      // Factorial time\n\n\n\n\nFor a more complete list of time complexities see: \nTime Complexity\n.\n\n\nThe problems we will be discussing which fall into this \"practically uncomputable\" category are \"NP\" problems for which we have no good algorithms to solve them. These are technically referred to as the \"NP-Complete\" class of problems, a term coined in the 1970s by researchers who realized that these problems are all essentially variations of the same thing, and if a solution could be found for one of them, it would mean all of them could in turn be solved.\n\n\nFor a good video on this topic, I'd recommend the following:\n\n\n\n\n\nThe Travelling Salesman Problem\n\n\nThe travelling salesman problem is a certain instance of a problem that has many general purpose applications. The scenario goes like this: you are a salesman who needs to travel to a bunch of cities, and end your trip where you started in your home city. You obviously want to minimize your travel time by taking the most efficient route that takes you through all the cities.\n\n\nFor an example of this problem, let's use a scenario where we want to visit just 4 cities, and so starting at city A, we need to calculate the optimal route. Each city has a travel time \"cost\" to travel between them that we'll use to calculate the best route.\n\n\n\n\nWe are starting in city A, so we just need to evaluate all our options that take us through all the cities and add up the travel costs like so:\n\n\n\n    \n\n        \nRoute\nRoute Costs\nTotal Cost\n\n    \n\n    \n\n        \nA->B->C->D->A\n3+5+6+2\n16\n\n    \n\n    \n\n        \nA->B->D->C->A\n3+3+6+8\n20\n\n    \n\n    \n\n        \nA->D->C->B->A\n2+6+5+3\n16\n\n    \n\n    \n\n        \nA->D->B->C->A\n2+3+5+8\n18\n\n    \n\n    \n\n        \nA->C->B->D->A\n8+5+3+2\n18\n\n    \n\n    \n\n        \nA->C->D->B->A\n8+6+3+3\n20\n\n    \n\n\n\n\n\nOne thing you might notice is that there's two routes that cost 16, two routes that cost 18, and two routes that cost 20. This is because one of each of these pairs is just the same route in reverse. So if you do ABCDA, it's the same route if you do it backwards as ADCBA! For this reason we can eliminate these duplicate routes, cutting our total routes to consider in half, and narrow our choices down to 3 real options. Obviously we would choose the one that costs 16.\n\n\n\n    \n\n        \nRoute\nRoute Costs\nTotal Cost\n\n    \n\n    \n\n        \nA->B->C->D->A\n3+5+6+2\n16\n\n    \n\n    \n\n        \nA->B->D->C->A\n3+3+6+8\n20\n\n    \n\n    \n\n        \nA->C->B->D->A\n8+5+3+2\n18\n\n    \n\n\n\n\n\nNow what if we needed to travel between 5 cities instead of 4? How much extra work would this be to figure out? Let's call this 5th city 'E' and examine just a piece of this expanded problem by determining the routes possible when we start with city B:\n\n\n\n\n\n    \n\n        \nRoute\nRoute Costs\nTotal Cost\n\n    \n\n    \n\n        \nA->B->C->D->E->A\n3+5+6+4+7\n25\n\n    \n\n    \n\n        \nA->B->C->E->D->A\n3+5+2+4+2\n16\n\n    \n\n    \n\n        \nA->B->D->C->E->A\n3+3+6+2+7\n21\n\n    \n\n    \n\n        \nA->B->D->E->C->A\n3+3+4+2+8\n20\n\n    \n\n    \n\n        \nA->B->E->C->D->A\n3+6+2+6+2\n19\n\n    \n\n    \n\n        \nA->B->E->D->C->A\n3+6+4+6+8\n27\n\n    \n\n    \n\n        \nA->C->...(continued)\n...\n...\n\n    \n\n\n\n\n\nWow! Not only does that graph look WAYYYYY more complicated, expanding the problem size to 5 cities gives us a lot more routes to consider.\n\n\nAs you can see, going from just 4 cities to 5 increased our options when we start our travels by going to city B first from just two, up to six! Similarly, our total number of route combinations increased from 6 up to 24 (if you finish the above example by mapping out all the possibilities you'll see there are 24). Of course we can still eliminate duplicates and cut that number of possible routes in half down to 12... but that's still a big jump from the 3 possibilities we had previously. \n\n\nWhat's important to realize is that this travelling salesman problem is one that has a factorial growth rate! To be more exact, the formula for the number of combinations that need to be considered when the number of cities is 'X' is this:\n\n\n(X - 1)! / 2\n\n\n\n\nIf you don't quite remember how factorials are calculated, here's an example:\n\n\n4! = 1 * 2 * 3 * 4 = 24\n\n\n\n\nFactorial growth is even worse than exponential growth!!!\n\n\n\n    \nn\n  \nn! (# of permutations)\n         \n~Time to Compute\n\n    \n\n        \n4\n  \n        \n24\n                             \n        \n-\n\n    \n\n    \n\n        \n5\n  \n        \n120\n                            \n        \n-\n\n    \n\n    \n\n        \n6\n  \n        \n720\n                            \n        \n-\n\n    \n\n    \n\n        \n7\n  \n        \n5,040\n                          \n        \n-\n\n    \n\n    \n\n        \n8\n  \n        \n40,320\n                         \n        \n-\n\n    \n\n    \n\n        \n9\n  \n        \n362,880\n                        \n        \n-\n\n    \n\n    \n\n        \n10\n \n        \n3,628,800\n                      \n        \n3 seconds\n\n    \n\n    \n\n        \n11\n \n        \n39,916,800\n                     \n        \n56 seconds\n\n    \n\n    \n\n        \n12\n \n        \n479,001,600\n                    \n        \n>11 minutes\n\n    \n\n    \n\n        \n13\n \n        \n6,227,020,800\n                  \n        \n~2.5 hours\n\n    \n\n    \n\n        \n14\n \n        \n87,178,291,200\n                 \n        \n~34 hours\n\n    \n\n    \n\n        \n15\n \n        \n1,307,674,368,000\n              \n        \n~21 days\n\n    \n\n    \n\n        \n16\n \n        \n20,922,789,888,000\n             \n        \n~340 days\n\n    \n\n    \n\n        \n17\n \n        \n355,687,428,096,000\n            \n        \n~15.8 years\n\n    \n\n    \n\n        \n18\n \n        \n6,402,373,705,728,000\n          \n        \n~284 years\n\n    \n\n    \n\n        \n19\n \n        \n121,645,100,408,832,000\n        \n        \n~5,411 years\n\n    \n\n    \n\n        \n20\n \n        \n2,432,902,008,176,640,000\n      \n        \n~108,230 years\n\n    \n\n\n\n\n\nExplanation of Factorial Growth\n\n\nLooking at the table to the left, you can see that factorial growth is extremely fast! We very quickly go from small, manageable numbers like the 4! we did an example of above, to astronomically large numbers very quickly. Why this matters is that in order to brute-force a solution to the Travelling Salesman problem, we have to calculate all the routes to determine the best one. So if there are 'n' route permutations (a permutation is a set of data where the order of the data matters), then that means 'n' routes we have to consider. And since the number of possible routes is growing factorially, this quickly means huge numbers as can be seen in the table.\n\n\nIn order to give you an idea of how difficult solving the Travelling Salesman problem is for a modern computer, I decided to do some tests with my Macbook Pro, 2.4ghz Intel i7, with 16 gigs of RAM. I didn't have an exact implementation of the Travelling Salesman on hand for testing, however, I did have an implementation of the Johnson-Trotter algorithm that I wrote. The Johnson-Trotter algorithm is used to generate all the possible permutations of a number of length 'n'. For instance, if you run Johnson-Trotter on number sequences of length 3, you get the following: \n123,\n132, \n312, \n321, \n231, \n213. A total of 6 permutations, which equals 3!. \nIn other words, this is the same factorial growth, consider all the possible permutations, type of problem that we are dealing with for the Travelling Salesman. I ran this algorithm for numbers of length 10 and 11 (thus calculating all the permutations of each), and used the calculation speed gathered from those tests to make estimates for the larger numbers. I think you can see how calculating the best route for the salesman via considering all the possible routes is simply not calculatable for any reasonably large number of cities.\n\n\nIt's not all doom and gloom though! In the same way that humans can look at a map and know that traveling from LA to Boston, then to Seattle, then back to Florida is going to be a horribly inefficient route without even thinking about it, there are ways to figure out the TSP quicker than considering all the possible permutations. The current fastest methods are known as Branch and Bound methods, which you can research if you want to learn more.\n\n\nThe Knapsack Problem\n\n\nAnother problem that falls into the same NP-Complete category as the Travelling Salesman that you might find interesting is the Knapsack Problem. It goes like this: say you are a thief with a backpack that can hold a max of 50 pounds in weight. With a collection of different objects nearby of differing weights and values, you want to know what the most optimal set of items you should steal are that can fit into your pack. This problem is also a factorial growth example.\n\n\nHope these examples peaked your interest into computability!",
            "title": "Computability"
        },
        {
            "location": "/computerscience/computability/#computability",
            "text": "Modern computers are based on what's called a Turing Machine, which was the first general purpose type of computer. What can a Turing Machine based computer compute? What can\u2019t a turing machine based computer compute? \nWhat kind of problems are impractical to compute for anything other than really small data sets? We\u2019ll briefly explore these questions below.",
            "title": "Computability"
        },
        {
            "location": "/computerscience/computability/#straight-up-non-computable",
            "text": "Let's first talk about problems that current computers simply cannot compute.",
            "title": "Straight up Non-Computable"
        },
        {
            "location": "/computerscience/computability/#the-halting-problem",
            "text": "If you are a software developer, you undoubtably have encountered infinite loops. Unlike interpretted\nlanguages such as PHP which will time out, lower level languages such as C++ will just keep running in an infinite loop forever if one exists.\nWith this in mind, it may seem like a good idea for someone to create a debugging program that detects those kinds of run-time errors in apps.\nHowever, you may be surprised to learn that  the reason why no such program exists is because it's impossible for a computer to determine if an\narbitrary computer program and input will finish running or not.  To informally prove this, let's assume we have a function called \"does_it_halt\" which we can pass an arbitrary program and input to and have it\ntell us if the program will halt or loop indefinitely.   Assumption:   \nThere exists a way for a computer to detect if any arbitrary program and input will halt or not.   With that assumption, let's assume someone wrote the following function as a simple way to utilize this knowledge:  function does_it_halt(program, input) {\n    if (eventually halts)\n        return true;\n    else\n        return false;\n}  For simplicity's sake let's also say someone wrote wrapper for this function that passes the program as the input. Remember that our\ndoes_it_halt method is supposed to work on any arbitrary input, so passing in the memory location or text of a program works just fine.  function debug_app(program) {\n    return does_it_halt(program, program);\n}  Alright, hopefully you'll agree this is pretty straight forward. Now let's say someone really smart informed us that our does_it_halt function\ncouldn't possibly work, but we didn't believe him. As a result, he decided to write a cheeky little function called paradox that does the following:  function paradox(program) {\n    if(debug_app(program))\n        while(1) {};\n    else\n        return true;\n}\n\necho debug_app(paradox);  Ha ha ha... so this dude wrote a function that puts itself into an intentional infinite loop if the does_it_halt says the program stops,\nand returns \"true\" if the program does not stop. Then he follows this up by calling our debug function on his code. \nSurely this is the most useless bit of code ever written right?  Well, before we can answer that, we have to examine what happens when this dude calls debug_app(paradox).  Let's say our debug_app() method returns true when passed Paradox. Let's logically think through what that means in terms of execution:   First up, since \"echo debug_app(Paradox)\" returned True, that means that Paradox halts.  In the process of testing if Paradox halts, does_it_halt(), somewhere in its magical logic would have to run Paradox with the given input. That input is also a reference to Paradox. So the call to paradox would look like \"paradox(paradox)\".  However, inside of Paradox is also a call to debug_app()! This call to \"debug_app(program)\" within Paradox would resolve to \"debug_app(Paradox)\" at runtime.  In order for does_it_halt to detect that Paradox halts, that means the call to \"debug_app(Paradox)\" within Paradox returns False, because otherwise Paradox would send itself into an infinite loop.   Uhh oh! Turns out that little piece of code wasn't as useless as we originally thought because it just proved that our does_it_halt function can't possibly exist as we've defined it.\nWe know from point #1 above that \"echo debug_app(Paradox)\" returns true, however, we also know that in order for that to happen, the call to \"debug_app(Paradox)\" as mentioned in point #4 above must return false. So two different calls to \"debug_app(Paradox)\" are returning differing results which is impossible. As such, our premise is proved false by what's called a Proof By Contradiction.  This problem (\"will a program halt\") which is unsolvable by computers by is known commonly as The Halting Problem. Alan Turing proved back in 1936 that a general algorithm to solve it is not possible.",
            "title": "The Halting Problem"
        },
        {
            "location": "/computerscience/computability/#post-correspondance-problem-pcp",
            "text": "Another quick example just to peak your interest. Let's say you have a list of some arbitrary number of dominoes which look something like this:  \n     c \n     cb   \n     ac \n     a   \n     b \n     bc   \n     a \n     ba   \n     a \n     c   \n     c \n     ac   \n     cb \n       c   \n     aa \n     b    You want to have a computer tell you whether there's a way in which you can order the dominoes such that the sequence of the top row matches the sequence of the bottom row.\nHere's an example of a match where both the top and the bottom read \"abbcbba\":   \n     a \n     abb   \n     bb \n     c   \n     cb \n     bb   \n     ba \n     a    Can a computer program be made for you that determines if there's an ordering that results in a match for an arbitrary set of dominoes? The answer is \"no\". This is called the Post Correspondence Problem and was introduced by Emil Post back in 1946.",
            "title": "Post-Correspondance Problem (PCP)"
        },
        {
            "location": "/computerscience/computability/#effectively-uncomputable-with-our-current-algorithms",
            "text": "",
            "title": "Effectively Uncomputable (with our current algorithms)"
        },
        {
            "location": "/computerscience/computability/#p-vs-np",
            "text": "In order to discuss problems that fall into this \"effectively uncomputable\" category, we quickly need to discuss the concept of P vs. NP.\n\"P\" are a class of problems for which their exists an algorithm to both find and verify an answer in polynomial time.\n\"NP\" (non-deterministic polynomial time) are a class of problems for which there exists algorithms to verify an answer in polynomial time, but  may or may not  have algorithms to find an answer.\nNote the \"may or may not\" statement... P vs. NP is actually one of the biggest unknowns in Mathematics/CS because no-one has been able to prove definitively \nthat P = NP or that P != NP.   If P = NP, then that means there DOES exist polynomial time algorithms to solve problems we lump into this category, but that we just haven't found them yet. If P != NP, then that would confirm that no such polynomial time algorithms exist, and we could stop looking. There has been a 1 million dollar reward on the table since the year 2000 for anyone that can prove this one way or the other.  So if you're wondering at this point what the heck polynomial time is, and wishing you could remember all your math lessons from high school, no fear - let's look at an example:  x^3 + 2x^2 + 3x = A Polynomial  The importance of polynomials is that they, and anything less complex than them, can be quickly solved by computers. Equations can be generally clumped into one of a number of different time groups:  y = 1       // Constant time\ny = x       // Linear time\ny = x^2     // Polynomial time\ny = 2^x     // Exponential time\ny = x!      // Factorial time  For a more complete list of time complexities see:  Time Complexity .  The problems we will be discussing which fall into this \"practically uncomputable\" category are \"NP\" problems for which we have no good algorithms to solve them. These are technically referred to as the \"NP-Complete\" class of problems, a term coined in the 1970s by researchers who realized that these problems are all essentially variations of the same thing, and if a solution could be found for one of them, it would mean all of them could in turn be solved.  For a good video on this topic, I'd recommend the following:",
            "title": "P vs NP"
        },
        {
            "location": "/computerscience/computability/#the-travelling-salesman-problem",
            "text": "The travelling salesman problem is a certain instance of a problem that has many general purpose applications. The scenario goes like this: you are a salesman who needs to travel to a bunch of cities, and end your trip where you started in your home city. You obviously want to minimize your travel time by taking the most efficient route that takes you through all the cities.  For an example of this problem, let's use a scenario where we want to visit just 4 cities, and so starting at city A, we need to calculate the optimal route. Each city has a travel time \"cost\" to travel between them that we'll use to calculate the best route.   We are starting in city A, so we just need to evaluate all our options that take us through all the cities and add up the travel costs like so:  \n     \n         Route Route Costs Total Cost \n     \n     \n         A->B->C->D->A 3+5+6+2 16 \n     \n     \n         A->B->D->C->A 3+3+6+8 20 \n     \n     \n         A->D->C->B->A 2+6+5+3 16 \n     \n     \n         A->D->B->C->A 2+3+5+8 18 \n     \n     \n         A->C->B->D->A 8+5+3+2 18 \n     \n     \n         A->C->D->B->A 8+6+3+3 20 \n       One thing you might notice is that there's two routes that cost 16, two routes that cost 18, and two routes that cost 20. This is because one of each of these pairs is just the same route in reverse. So if you do ABCDA, it's the same route if you do it backwards as ADCBA! For this reason we can eliminate these duplicate routes, cutting our total routes to consider in half, and narrow our choices down to 3 real options. Obviously we would choose the one that costs 16.  \n     \n         Route Route Costs Total Cost \n     \n     \n         A->B->C->D->A 3+5+6+2 16 \n     \n     \n         A->B->D->C->A 3+3+6+8 20 \n     \n     \n         A->C->B->D->A 8+5+3+2 18 \n       Now what if we needed to travel between 5 cities instead of 4? How much extra work would this be to figure out? Let's call this 5th city 'E' and examine just a piece of this expanded problem by determining the routes possible when we start with city B:   \n     \n         Route Route Costs Total Cost \n     \n     \n         A->B->C->D->E->A 3+5+6+4+7 25 \n     \n     \n         A->B->C->E->D->A 3+5+2+4+2 16 \n     \n     \n         A->B->D->C->E->A 3+3+6+2+7 21 \n     \n     \n         A->B->D->E->C->A 3+3+4+2+8 20 \n     \n     \n         A->B->E->C->D->A 3+6+2+6+2 19 \n     \n     \n         A->B->E->D->C->A 3+6+4+6+8 27 \n     \n     \n         A->C->...(continued) ... ... \n       Wow! Not only does that graph look WAYYYYY more complicated, expanding the problem size to 5 cities gives us a lot more routes to consider.  As you can see, going from just 4 cities to 5 increased our options when we start our travels by going to city B first from just two, up to six! Similarly, our total number of route combinations increased from 6 up to 24 (if you finish the above example by mapping out all the possibilities you'll see there are 24). Of course we can still eliminate duplicates and cut that number of possible routes in half down to 12... but that's still a big jump from the 3 possibilities we had previously.   What's important to realize is that this travelling salesman problem is one that has a factorial growth rate! To be more exact, the formula for the number of combinations that need to be considered when the number of cities is 'X' is this:  (X - 1)! / 2  If you don't quite remember how factorials are calculated, here's an example:  4! = 1 * 2 * 3 * 4 = 24  Factorial growth is even worse than exponential growth!!!  \n     n    n! (# of permutations)           ~Time to Compute \n     \n         4   \n         24                              \n         - \n     \n     \n         5   \n         120                             \n         - \n     \n     \n         6   \n         720                             \n         - \n     \n     \n         7   \n         5,040                           \n         - \n     \n     \n         8   \n         40,320                          \n         - \n     \n     \n         9   \n         362,880                         \n         - \n     \n     \n         10  \n         3,628,800                       \n         3 seconds \n     \n     \n         11  \n         39,916,800                      \n         56 seconds \n     \n     \n         12  \n         479,001,600                     \n         >11 minutes \n     \n     \n         13  \n         6,227,020,800                   \n         ~2.5 hours \n     \n     \n         14  \n         87,178,291,200                  \n         ~34 hours \n     \n     \n         15  \n         1,307,674,368,000               \n         ~21 days \n     \n     \n         16  \n         20,922,789,888,000              \n         ~340 days \n     \n     \n         17  \n         355,687,428,096,000             \n         ~15.8 years \n     \n     \n         18  \n         6,402,373,705,728,000           \n         ~284 years \n     \n     \n         19  \n         121,645,100,408,832,000         \n         ~5,411 years \n     \n     \n         20  \n         2,432,902,008,176,640,000       \n         ~108,230 years",
            "title": "The Travelling Salesman Problem"
        },
        {
            "location": "/computerscience/computability/#explanation-of-factorial-growth",
            "text": "Looking at the table to the left, you can see that factorial growth is extremely fast! We very quickly go from small, manageable numbers like the 4! we did an example of above, to astronomically large numbers very quickly. Why this matters is that in order to brute-force a solution to the Travelling Salesman problem, we have to calculate all the routes to determine the best one. So if there are 'n' route permutations (a permutation is a set of data where the order of the data matters), then that means 'n' routes we have to consider. And since the number of possible routes is growing factorially, this quickly means huge numbers as can be seen in the table.  In order to give you an idea of how difficult solving the Travelling Salesman problem is for a modern computer, I decided to do some tests with my Macbook Pro, 2.4ghz Intel i7, with 16 gigs of RAM. I didn't have an exact implementation of the Travelling Salesman on hand for testing, however, I did have an implementation of the Johnson-Trotter algorithm that I wrote. The Johnson-Trotter algorithm is used to generate all the possible permutations of a number of length 'n'. For instance, if you run Johnson-Trotter on number sequences of length 3, you get the following: \n123,\n132, \n312, \n321, \n231, \n213. A total of 6 permutations, which equals 3!. \nIn other words, this is the same factorial growth, consider all the possible permutations, type of problem that we are dealing with for the Travelling Salesman. I ran this algorithm for numbers of length 10 and 11 (thus calculating all the permutations of each), and used the calculation speed gathered from those tests to make estimates for the larger numbers. I think you can see how calculating the best route for the salesman via considering all the possible routes is simply not calculatable for any reasonably large number of cities.  It's not all doom and gloom though! In the same way that humans can look at a map and know that traveling from LA to Boston, then to Seattle, then back to Florida is going to be a horribly inefficient route without even thinking about it, there are ways to figure out the TSP quicker than considering all the possible permutations. The current fastest methods are known as Branch and Bound methods, which you can research if you want to learn more.",
            "title": "Explanation of Factorial Growth"
        },
        {
            "location": "/computerscience/computability/#the-knapsack-problem",
            "text": "Another problem that falls into the same NP-Complete category as the Travelling Salesman that you might find interesting is the Knapsack Problem. It goes like this: say you are a thief with a backpack that can hold a max of 50 pounds in weight. With a collection of different objects nearby of differing weights and values, you want to know what the most optimal set of items you should steal are that can fit into your pack. This problem is also a factorial growth example.  Hope these examples peaked your interest into computability!",
            "title": "The Knapsack Problem"
        }
    ]
}